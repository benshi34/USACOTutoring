{"1404_platinum_lazy_cow": {"name": "Lazy Cow", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1404", "test_data_link": "http://www.usaco.org/current/data/prob1_platinum_feb24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob1_platinum_feb24.html", "contest_link": "http://www.usaco.org/index.php?page=feb24results", "inner_contest_link": null, "problem_level": "platinum", "cp_id": "1404", "problem_id": "1404_platinum_lazy_cow", "description": "\nBessie is hard at work preparing test cases for the USA Cowmputing Olympiad\nFebruary contest. Each minute, she can choose to not prepare any tests,\nexpending no energy; or expend $3^{a-1}$ energy preparing $a$ test cases, for\nsome positive integer $a$.\n\nFarmer John has $D$ ($1\\le D\\le 2\\cdot 10^5$) demands. For the $i$th demand, he\ntells Bessie that within the first $m_i$ minutes, she needs to have prepared  at\nleast $b_i$ test cases in total ($1\\le m_i\\le 10^6, 1 \\leq b_i \\leq 10^{12}$).\n\nLet $e_i$ be the smallest amount of energy Bessie needs to spend to satisfy the\nfirst $i$ demands. Print $e_1,\\dots,e_D$ modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $D$. The $i$th of the next $D$ lines contains two\nspace-separated integers $m_i$ and $b_i$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput $D$ lines, the $i$th containing $e_i \\text{ mod } 10^9+7$.\n\nSAMPLE INPUT:\n4\n5 11\n6 10\n10 15\n10 30\nSAMPLE OUTPUT: \n21\n21\n25\n90\n\nFor the first test case, \n $i=1$: If Bessie creates $[2, 3, 2, 2, 2]$ test cases on the first $5$\ndays, respectively, she would have expended $3^1 + 3^2 + 3^1 + 3^1 + 3^1 = 21$\nunits of energy and created $11$ test cases by the end of day $5$. \n$i=2$: Bessie can follow the above strategy to ensure $11$ test cases are\ncreated by the end of day $5$, and this will automatically satisfy the second\ndemand. $i=3$: If Bessie creates $[2, 3, 2, 2, 2, 0, 1, 1, 1, 1]$ test\ncases on the first $10$ days, respectively, she would have expended $25$ units\nof energy and satisfied all demands. It can be shown that she cannot expend less\nenergy. $i=4$: If Bessie creates 3 test cases on each of the first\n$10$ days she would have expended $3^{2}\\cdot 10 = 90$ units of energy and\nsatisfied all demands. \nFor each $i$, it can be shown that Bessie cannot satisfy the first $i$ demands using\nless energy.\n\nSAMPLE INPUT:\n2\n100 5\n100 1000000000000\nSAMPLE OUTPUT: \n5\n627323485\n\nSAMPLE INPUT:\n20\n303590 482848034083\n180190 112716918480\n312298 258438719980\n671877 605558355401\n662137 440411075067\n257593 261569032231\n766172 268433874550\n8114 905639446594\n209577 11155741818\n227183 874665904430\n896141 55422874585\n728247 456681845046\n193800 632739601224\n443005 623200306681\n330325 955479269245\n377303 177279745225\n880246 22559233849\n58084 155169139314\n813702 758370488574\n929760 785245728062\nSAMPLE OUTPUT: \n108753959\n108753959\n108753959\n148189797\n148189797\n148189797\n148189797\n32884410\n32884410\n32884410\n32884410\n32884410\n32884410\n32884410\n3883759\n3883759\n3883759\n3883759\n3883759\n3883759\n\nSCORING:\nInputs 4-5: $D\\le 100$ and $m_i \\le 100$ for all $i$ Inputs 6-8: $D\\le 3000$Inputs 9-20: No additional constraints.\n\n\nProblem credits: Brandon Wang and Claire Zhang\n", "num_tests": 20, "solution": "\n(Analysis by Benjamin Qi, Brandon Wang, Claire Zhang)\nLet us first suppose we compute each $e_n$ separately, and then we will do this\n$D$ times. (Later we will describe how to support updates.) Suppose\n$(m_1, b_1), \\ldots, (m_n, b_n)$ are in increasing order of $m_i$. We can make\nthe following observations:\n\nIf $b_i \\geq b_j$ for $i < j$, then we can ignore demand $j$.\n\nLet us suppose we create $a_i$ tasks on day $i$. Then, we can assume\n$a_1 \\geq a_2 \\geq a_3 \\cdots$ (since if $a_i < a_j$ with $i > j$, we can swap\n$a_i$ and $a_j$). \n\n Subtask 1 ($D\\le100$, $m_i \\le 100$):\nLet the cost of a sequence of increments $(a_i)$ be the energy required\n$\\left(\\sum_i 3^{a_i}\\right)$. Additionally, say $(a_i)$ is valid if it\nsatisfies all demands.\nClaim: The lexicographically minimal sequence $(a_i)$ which is\nnon-increasing and valid attains minimum cost.\nProof: Let $(a_i)$ be the lexicographically minimal sequence which is\nnon-increasing and valid. Suppose for sake of contradiction that the lowest-cost\nnon-increasing, valid sequence $(b_i)$ has lower cost than $(a_i)$.  Without\nloss of generality, say the first index $i$ where $a_i\\ne b_i$ is $i=1$. For\nexample, consider\n$(a_i) = [4, 4, 4, 4, 2]$\n$(b_i) = [5, 5, 4, 3, 1]$\nThen we claim $(b_i)$ is not the lowest-cost sequence which is non-increasing\nand valid: consider decrementing $b_j$, where $j$ is maximum index such that\n$b_j=b_1$, and incrementing $b_k$, where $k$ is the minimum index such that\n$b_k \\le b_1-2$ (if such exists). In the example, \n$(b_i) = [5, 5, 4, 3, 1] \\rightarrow (b'_i) = [5, 5-1, 4, 3+1, 2]$\n$(b'_i)$\nmeets all demands because the first $k-1$ prefixes have sum at least that of\n$a$, and all other prefix sums are the same as in $b$ (which are valid),  is non-increasing because the only consecutive difference that we decrease\nis between $b_j$ and $b_{j+1}$ ($b_j > b_{j+1}$) and we only decrease it by\n1, and has smaller cost as $3^x + 3^y > 3^{x-1} + 3^{y+1}$ when\n$x>y+1$.\n$(b'_i)$ is a valid, non-increasing, sequence with lower cost than $(b_i)$-- a\ncontradiction. (end of proof)\nUsing this claim, we can greedily select the smallest $a_i$ for\n$i=1, \\ldots, D$. If there are 0 test cases on day 0 and at least $b_i$ on day\n$m_i$, there must be a day $1 \\le j \\le  m_i$ where\n$\\lceil \\frac{b_i}{m_i} \\rceil$ test cases are prepared (max 1-day increase is\nat least average increase).  $a_1$ is the maximum $a_i$, so $a_1$ must be at\nleast $\\max_{i=1}^D \\lceil \\frac{b_i}{m_i} \\rceil$. Let\n$a_1 = \\max_{i=1}^D \\lceil \\frac{b_i}{m_i} \\rceil$ and decrement all $m_i$. If\nwe set all $a_i$ in this manner, $(a_i)$ is \nvalid, because on day $m_i$ we make at least\n$\\lceil \\frac{b_i-\\sum_{j=1}^{m_i-1}a_j}{1}\\rceil \\ge b_i-\\sum_{j=1}^{m_i-1}a_j$\ntest cases,  lexicographically minimal by construction, and\nnon-increasing because\n$\\lceil\\frac{b_i-\\lceil \\frac{b_i}{m_i}\\rceil}{m_i-1} \\rceil \\le \\lceil\\frac{b_i}{m_i}\\rceil$\n\nTherefore, this greedy algorithm (code below) attains the lex. min valid\nsequence, which we have shown is cost-optimal. Its time complexity is\n$O(D^3 + D^2 \\log(B))$.\n\ndef ceildiv(a, b):\n    return -(a // -b)\n\n\ndef solve(demands):\n    MOD = 10**9 + 7\n    ans = 0\n    while len(demands) > 0:\n        a1 = max(ceildiv(b, m) for m, b in demands)\n        demands = [(m - 1, b - a1) for m, b in demands if b > a1]\n        ans = (ans + pow(3, a1 - 1, MOD)) % MOD\n    return ans\n\n\nD = int(input())\n\ndemands = []\nfor _ in range(D):\n    m, b = map(int, input().split())\n    demands.append((m, b))\n    print(solve(demands))\n\nSubtask 2 ($D \\leq 3000$):\nObservation 2 implies that we only need to satisfy $(m_i, b_i)$ that are on the\n\"upper left\" hull of the demand set (where we assume $(0, 0)$ is also a demand).\nLet's take some $(a_1, a_2, \\ldots)$ that satisfies everything on the upper left\nhull. We claim that we can \"massage\" the $a_i$ so that each $(m_i, b_i)$ on the\nupper left hull is exactly satisfied. We will also do this in a way so\nthat if $(m_i, b_i)$, $(m_j, b_j)$ are consecutive on the hull, then\n$a_{m_i+1} \\geq a_{i+2} \\geq \\cdots a_{m_j}$ still holds (so everything not on\nthe hull is still automatically satisfied). To see how to do this, suppose\n$a_1 + a_2 + \\cdots + a_{m_i} > b_i$ with $i$ minimal, and let $j > i$ be\nminimal such that $a_1 + a_2 + \\cdots + a_{m_j} = b_j$ (also, $i, j$ are both on\nthe hull). Then, we have $a_{m_{i-1}+1} + \\cdots + a_{m_i} > b_i - b_{i-1}$, but\n$a_{m_{j-1}} + \\cdots + a_{m_j} < b_j - b_{j-1}$. By convexity, we must have\n$\\frac{b_i - b_{i-1}}{m_i - m_{i-1}} \\geq \\frac{b_j - b_{j-1}}{m_j - m_{j-1}}$,\nso we have $a_{m_{i-1}+1} > a_{m_j}$. We can then move $1$ test-case from the\nlast $a_k = a_{m_{i-1}+1}$ (with $m_{i-1}+1\\leq k \\leq m_i$) to the first\n$a_\\ell = a_{m_j}$ (with $m_{j-1}+1\\leq \\ell \\leq m_j$). In this way, we have\nmoved a subtask from a day with $a_k$ subtasks to a day with $a_\\ell < a_k$\nsubtasks, which does not increase the total cost.\nThe point of this argument is as follows: Suppose\n$(0, 0), (m_{i_1}, b_{i_1}), \\ldots, (m_{i_k}, b_{i_k})$  is the upper left\nhull. Then, we can assume Bessie has prepared exactly $b_{i_t}$ test-cases by\nday $m_{i_t}$. In particular, between days $m_{i_{t-1}+1}$ and $m_{i_t}$\n(inclusive), Bessie prepares $b_{i_t} - b_{i_{t-1}}$ test cases. By convexity of\n$3^{a-1}$, we want the number of test cases per day to be as close together as\npossible, so we should have them all be either $\\lceil x \\rceil$ or\n$\\lfloor x \\rfloor$,  $x$ being the average number of test cases prepared in\nthis interval.\nThis gives us an $O(D^2(\\log D + \\log B))$ solution (code below).\n\n#include <algorithm>\n#include <iostream>\n#include <stack>\n \ntypedef long long ll;\ntypedef std::pair<ll,ll> pi;\n \nconst int MAXN = 2e5+5;\nconst ll P = 1000000007;\n \nint N;\npi p[MAXN];\n \nll modexp (ll a, ll n) {\n\tif (n == 0) return 1;\n\tll b = modexp((a*a)%P, n/2);\n\treturn (n%2?(a*b)%P:b);\n}\n \nvoid input () {\n\tstd::cin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tstd::cin >> p[i].first >> p[i].second;\n\t}\n}\n \nbool pre (pi p, pi q) {\n\t// returns true if line to p is on or below line to q\n\treturn p.second*q.first <= q.second*p.first;\n}\n \nll diff (pi p, pi q) {\n\tll dy = q.second - p.second;\n\tll dx = q.first - p.first;\n\tll nh = dy%dx%P;\n\tll lo = dy/dx;\n\tif (lo == 0) {\n\t\treturn ((nh%P) * modexp(3, lo))%P;\n\t}\n\treturn (modexp(3, lo-1)*((dx-nh)%P) + modexp(3, lo)*(nh%P))%P;\n}\n \nll query (int M) {\n\tstd::sort(p, p+M);\n\tstd::stack<pi> stk;\n\tstk.push({0, 0});\n\tfor (int i = 0; i < M; i++) {\n\t\twhile (int(stk.size()) > 1) {\n\t\t\tpi q = stk.top();\n\t\t\tstk.pop();\n\t\t\tpi r = stk.top();\n\t\t\tif (pre({q.first-r.first, q.second-r.second}, {p[i].first-r.first, p[i].second-r.second})) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstk.push(q);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (stk.top().second < p[i].second) {\n\t\t\tstk.push(p[i]);\n\t\t}\n\t}\t\n\tll ans = 0;\n\tpi cur = stk.top();\n\tstk.pop();\n\twhile (!stk.empty()) {\n\t\tans = (ans + diff(stk.top(), cur))%P;\n\t\tcur = stk.top();\n\t\tstk.pop();\n\t}\n\treturn ans;\n}\n \nint main () {\n\tinput();\n\tfor (int i = 1; i <= N; i++) {\n\t\tstd::cout << query(i) << \"\\n\";\n\t}\n}\n\nSubtask 3 ($D \\leq 2\\cdot 10^5$):\nTo optimize, we need to efficiently maintain consecutive pairs of points on the\nhull as points are added. For two sets of points $A$, $B$,\n$h(A \\cup B)=h(h(A), h(B))$, where $h(S)$ denotes the convex hull of $S$, a set\nof 2d points. This means that a point that's not on the convex hull will never\nbe after new points are added. Thus, inserting a new point inserts at most 1 new\npoint to the hull and deletes possibly many. \nWe can maintain a set of $(x,y)$ points on the hull, sorted by $x$ (and $y$).\nUpdating the convex hull after inserting a point $p$ could require removing a\nball of points around $p$. Say $p$ has index $i$ in the sorted set. We can\nrepeatedly check if $i \\rightarrow (i+1) \\rightarrow (i+2)$ forms a left turn;\nif so, $i+1$ does not belong on the hull. Similarly, check for right turns of\nthe form $(i-2)\\leftarrow(i-1)\\leftarrow i$. \nNote that $a_i$s should never be negative, so we should remove $i+1$ whenever\n$i\\rightarrow(i+1)$ is downward sloping. Each point is removed at most once in\n$O(\\log D)$ time, and exponentiating to calculate the costs involving it is $O(\\log B)$ per hull edge. The total work is\n$O(D(\\log D+\\log B))$. \nCode:\n\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <ll Mod>\nstruct ModInt {\n  ll n;\n\n  ModInt(const ll x = 0) : n(x) {\n    while (n < 0) n += Mod;\n    n %= Mod;\n  }\n  explicit operator int() const { return n; }\n  inline ModInt operator+(const ModInt r) const noexcept { return ModInt(*this) += r; }\n  inline ModInt operator-(const ModInt r) const noexcept { return ModInt(*this) -= r; }\n  inline ModInt operator*(const ModInt r) const noexcept { return ModInt(*this) *= r; }\n  inline ModInt operator/(const ModInt r) const noexcept { return ModInt(*this) /= r; }\n  inline ModInt &operator+=(const ModInt r) noexcept {\n    n += r.n;\n    if (n >= Mod) n -= Mod;\n    return *this;\n  }\n  inline ModInt &operator-=(const ModInt r) noexcept {\n    if (n < r.n) n += Mod;\n    n -= r.n;\n    return *this;\n  }\n  inline ModInt &operator*=(const ModInt r) noexcept {\n    n = n * r.n % Mod;\n    return *this;\n  }\n  inline ModInt &operator/=(const ModInt r) noexcept { return *this *= r.inv(); }\n\n  inline ModInt pow(ll x) const noexcept {\n    ModInt<Mod> ret(1), tmp(*this);\n    while (x) {\n      if (x&1) ret *= tmp;\n      tmp *= tmp;\n      x >>= 1;\n    }\n    return ret;\n  }\n  inline ModInt inv() const noexcept { return pow(Mod-2); }\n\n  friend ostream& operator<<(ostream& os, const ModInt& obj) { return os << obj.n; }\n  friend istream& operator>>(istream& is, ModInt& obj) {\n    ll t;\n    is >> t;\n    obj = ModInt(t);\n    return is;\n  }\n};\n\nconst ll mod = 1000000007;\nusing mi = ModInt<mod>;\n\n\nint main(){\n    cin.tie(0)->sync_with_stdio(0);\n\n    int D; cin >> D;\n\n    mi ans=0;\n\n    map<int, ll> ys;\n    set<int> xs({0});\n\n    auto left_turn=[&](int x1, int x2, int x3)->bool{\n        return (ys[x2]-ys[x1])*(x3-x2) <= (ys[x3]-ys[x2])*(x2-x1);\n    };\n\n    auto right_turn=[&](int x1, int x2, int x3)->bool{\n        return !left_turn(x1, x2, x3);\n    };\n\n    auto f=[&](int x1, int x2)->mi{\n        int dx = x2 - x1;\n        ll dy = ys[x2] - ys[x1];\n        if(dy<=0) return 0;\n        // dx*k <= dy <= dx*(k+1)\n        ll step = dy/dx;\n        if(dy%dx) return mi(3).pow(dy/dx)*(dy%dx) + (dy/dx? mi(3).pow(dy/dx-1) : 0) *(dx-(dy%dx));\n        return dy/dx? mi(3).pow(dy/dx-1)*dx : 0;\n    };\n\n    auto upd=[&](int x, bool del = 0){\n        auto it = xs.lower_bound(x);\n        assert(*it == x);\n        assert(it != xs.begin());\n        int x_bef = *prev(it);\n        if(del){\n            ans -= f(x_bef, x);\n            it++;\n            if(it != xs.end()){\n                int x_af = *it;\n                ans += f(x_bef, x_af) - f(x, x_af);\n            }\n            xs.erase(x);\n            ys[x] = 0;\n        } else{\n            ans += f(x_bef, x);\n            it++;\n            if(it != xs.end()){\n                int x_af = *it;\n                ans += f(x, x_af) - f(x_bef, x_af);\n            }\n        }\n    };\n\n    auto ins=[&](int x, ll y){\n        // check if x -- y -- z y is below segment (x-z) in CH -- if so return\n        if(ys[x] and ys[x] >= y) return;\n        if(ys[x]) upd(x, 1);\n        ys[x] = y;\n        xs.insert(x);\n        upd(x);\n        while(true){\n            auto it = xs.lower_bound(x);\n            bool ch = 0;\n            for(int i=0; i<3; i++){\n                if(it!=xs.end() and next(it)!=xs.end() and next(next(it))!=xs.end()){\n                    int a=*it, b=*next(it), c=*next(next(it));\n                    if(left_turn(a, b, c)){\n                        ch = 1;\n                        upd(b, 1);\n                        break;\n                    }\n                }\n                if(it==xs.begin()) break;\n                it--;\n            }\n            if(!ch) break;\n        }\n    };\n\n    while(D--){\n        int t;\n        ll b;\n        cin >> t >> b;\n        ins(t, b);\n        cout << ans << \"\\n\";\n    }\n}\n\n\nNote that the solution is correct even if you divide when computing left_turn\ninstead of multiply:\n\nauto left_turn = [&](int x1, int x2, int x3) -> bool {\n\treturn ys[x2] <= ys[x3] && (ys[x2] - ys[x1]) / (x2 - x1) <= (ys[x3] - ys[x2]) / (x3 - x2);\n};\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1405_platinum_minimum_sum_of_maximums": {"name": "Minimum Sum of Maximums", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1405", "test_data_link": "http://www.usaco.org/current/data/prob2_platinum_feb24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob2_platinum_feb24.html", "contest_link": "http://www.usaco.org/index.php?page=feb24results", "inner_contest_link": null, "problem_level": "platinum", "cp_id": "1405", "problem_id": "1405_platinum_minimum_sum_of_maximums", "description": "\nBessie has $N$ ($2\\le N\\le 300$) tiles in a line with ugliness values \n$a_1, a_2, \\dots, a_N$ in that order ($1\\le a_i\\le 10^6$). $K$\n($0\\le K\\le \\min(N,6)$) of the tiles are stuck in place; specifically, those at\nindices $x_1,\\dots, x_K$ ($1\\le x_1 < x_2<\\dots< x_K\\le N$). \n\nBessie wants to minimize the total ugliness of the tiles, which is defined as\nthe sum of the maximum ugliness over every consecutive pair of tiles; that is,\n$\\sum_{i=1}^{N-1}\\max(a_i,a_{i+1})$. She is allowed to perform the following\noperation any number of times: choose two tiles, neither of which are stuck in\nplace, and swap them. \n\nDetermine the minimum possible total ugliness Bessie can achieve if she performs\noperations optimally.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$ and $K$.\n\nThe next line contains $a_1,\\dots,a_N$.\n\nThe next line contains the $K$ indices $x_1,\\dots,x_K$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput the minimum possible total ugliness.\n\nSAMPLE INPUT:\n3 0\n1 100 10\n\nSAMPLE OUTPUT: \n110\n\nBessie can swap the second and third tiles so that $a=[1,10,100]$, achieving\ntotal ugliness $\\max(1,10)+\\max(10,100)=110$. Alternatively, she could swap the\nfirst and second tiles so that $a=[100,1,10]$, also achieving  total ugliness\n$\\max(100,1)+\\max(1,10)=110$.\n\nSAMPLE INPUT:\n3 1\n1 100 10\n3\nSAMPLE OUTPUT: \n110\n\nBessie could swap the first and second tiles so that $a=[100,1,10]$, achieving \ntotal ugliness $\\max(100,1)+\\max(1,10)=110$.\n\nSAMPLE INPUT:\n3 1\n1 100 10\n2\nSAMPLE OUTPUT: \n200\n\nThe initial total ugliness of the tiles is $\\max(1,100)+\\max(100,10)=200$.\nBessie is only allowed to swap the first and third tiles, which does not allow\nher to reduce the total ugliness.\n\nSAMPLE INPUT:\n4 2\n1 3 2 4\n2 3\nSAMPLE OUTPUT: \n9\n\nSCORING:\nInput 5: $K=0$Inputs 6-7: $K=1$Inputs 8-12: $N\\le 50$Inputs 13-24: No additional constraints\n\nProblem credits: Benjamin Qi\n", "num_tests": 24, "solution": "\n(Analysis by Benjamin Qi, Richard Qi)\nCall the tiles which are stuck in place \"fixed values\", and call all other\nvalues \"unfixed values\".  First, append large fixed values (say, $10^6$) to\neither end of the array, so that every unfixed value is between two fixed\nvalues. At the end, we then subtract $2 \\cdot 10^6$ from the answer.\nDefine a range to be the space between two consecutive fixed tiles $a_l$ and\n$a_r$.\nInstead of the original scenario of a sequence of tiles, we can imagine that we\nhave $K+1$ \"ranges\", where the $i$th range consists of two values\n$m_i = \\min(a_l, a_r), M_i = \\max(a_l, a_r)$, and some size $len_i$, satisfying\n$\\sum_{i=1}^{K+1} len_i = N-K$. Our job is to allocate $N-K$ values to the $K+1$\nranges, where the $i$th range gets a sequence of values\n$b_{i, 1}, b_{i, 2}, \\dots, b_{i, len_i}$, such that the value we want to\nminimize is $\\sum_{i=1}^{K+1} \\sum_{j=0}^{len_i} \\max(b_{i, j}, b_{i, j+1})$\nwhere we also define $b_{i, 0} = m_i$, $b_{i, len_i+1} = M_i$ as fixed values.\nClaim: For a range $i$, it is optimal for the values to be sorted such that\n$b_{i, j} \\le b_{i, j+1}$ for $j \\in [1, len_i-1]$. \nProof: This holds from the $0-1$ principle. If all numbers are $0$ or $1$, then\nclearly it is optimal for the values to be sorted in the above manner. So, it is\noptimal to sort even when the numbers are not $0$ or $1$. \nMore rigorously, the objective function we want to minimize can be written as\n$\\sum_{i=1}^{K+1} \\sum_{j=0}^{len_i} \\sum_{v=0}^{\\infty} \\max(f_v(b_{i, j}), f_v(b_{i, j+1})) = \\sum_{v=0}^{\\infty} \\sum_{i=1}^{K+1} \\sum_{j=0}^{len_i} \\max(f_v(b_{i, j}), f_v(b_{i, j+1}))$.\nwhere $f_v(x) = 1$ if $x > v$, and otherwise $f_v(x) = 0$. Now, for each value\nof $v$, the inner summation is minimized when the values are sorted. So, it is\noptimal to sort the values in increasing order.\nSo, for the $K = 0$ case, there is only one range, and we simply sort the values\nto compute $\\sum_{j=0}^{len_1} \\max(b_{1, j}, b_{1, j+1})$.\nFor $N \\le 50$, we can do a\n$O(\\prod_{i=1}^{K+1} len_i) \\le O((\\frac{N}{K+1})^{K+1})$ state DP. For each of\nthe unfixed values in increasing value order, we decide which range to put it\nin, and place the value in the first position which is unfilled in the range.\nThe DP state is the number of elements filled for each range so far\n$(placed_1, placed_2, \\dots, placed_{K+1})$, and the value of the state is the\nsum over all $i$ of $\\sum_{j=0}^{placed_i-1} \\max(b_{i, j}, b_{i, j+1})$ if\n$placed_i < len_i$, and $\\sum_{j=0}^{len_i} \\max(b_{i, j}, b_{i, j+1})$ if\n$placed_i = len_i$. \nRichard's Code for $N \\le 50$:\n\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define sz(x) int((x).size())\n \nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tint N, K;\n\tcin >> N >> K;\n\tmultiset<int> multi_vals;\n\tvector<int> inp_a;\n\tfor (int i = 1; i <= N; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tmulti_vals.insert(a);\n\t\tinp_a.push_back(a);\n\t}\n \n\tvector<pair<int, int>> xys;\n\tfor (int i = 1; i <= K; i++) {\n\t\tint x, y;\n\t\tcin >> x;\n\t\ty = inp_a[x - 1];\n\t\txys.push_back(make_pair(x, y));\n\t\tmulti_vals.erase(multi_vals.find(y));\n\t}\n\txys.push_back(make_pair(0, 1000000));\n\txys.push_back(make_pair(N + 1, 1000000));\n\tsort(begin(xys), end(xys));\n \n\tvector<int> vals;\n\tfor (auto u : multi_vals) vals.push_back(u);\n \n\t// xys and vals store the input\n \n\tvector<pair<pair<int, int>, int>> rangs; //ranges: ((min value, max value), size)\n\t\n\tint addon_zerosz = 0;\n\tfor (int i = 0; i + 1 < sz(xys); i++) {\n\t\tint rang_size = xys[i + 1].first - xys[i].first - 1;\n\t\tif (rang_size == 0) {\n\t\t\taddon_zerosz += max(xys[i + 1].second, xys[i].second);\n\t\t} else {\n\t\t\tpair<int, int> rang_vals = make_pair(xys[i].second, xys[i + 1].second);\n\t\t\tif (rang_vals.first > rang_vals.second) swap(rang_vals.first, rang_vals.second);\n\t\t\trangs.push_back(make_pair(rang_vals, rang_size));\n\t\t}\n\t}\n \n\tmap<vector<int>, int> dp;\n\tdp[vector<int>(sz(rangs), 0)] = 0;\n \n\tfor(auto v: vals){ //for each value in increasing order\n\t\tmap<vector<int>, int> ndp;\n\t\tfor(const auto& u: dp){\n\t\t\tvector<int> st = u.first; //current # of placed values in each range\n\t\t\tfor(int i = 0; i < sz(rangs); i++){ //place the next value in range i\n\t\t\t\tif(st[i]+1 <= rangs[i].second){\n\t\t\t\t\tvector<int> new_st = st;\n\t\t\t\t\tint new_val = u.second;\n\t\t\t\t\tnew_st[i]++;\n\t\t\t\t\tif(st[i] == 0){\n\t\t\t\t\t\tnew_val+=max(v, rangs[i].first.first)-v;\n\t\t\t\t\t}\n\t\t\t\t\tif(st[i] == rangs[i].second-1){\n\t\t\t\t\t\tnew_val+=max(v, rangs[i].first.second)-rangs[i].first.second;\n\t\t\t\t\t}\n \n\t\t\t\t\tif(!ndp.count(new_st) || ndp[new_st] >= new_val){\n \t\t\t\t\t\tndp[new_st] = new_val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(dp, ndp);\n\t}\n \n\tassert(sz(dp) == 1);\n\tint ans = dp.begin()->second;\n \n\t//add in fixed values\n\tfor (auto u : vals) { ans += u; }\n\tfor (auto u : rangs) { ans += u.first.second; }\n\tans += addon_zerosz;\n\tans -= 2 * 1000000;\n\tcout << ans << \"\\n\";\n}\n\nNow, using the sorted property, notice that in the expression\n$\\sum_{i=1}^{K+1} \\sum_{j=0}^{len_i} \\max(b_{i, j}, b_{i, j+1})$, we almost\nalways have $\\max(b_{i, j}, b_{i, j+1}) = b_{i, j+1}$. The only $j$ where this\nmight not be the case are $j = 0, len_i$.  However, we know the value of\n$\\sum_{i=1}^{K+1} \\sum_{j=0}^{len_i} b_{i, j+1}$ is just the sum of all\nnon-fixed values plus $\\sum_{i=1}^{K+1} M_i$. \nSo, it suffices to minimize\n$\\sum_{i=1}^{K+1} \\sum_{j=0}^{len_i} \\max(b_{i, j}, b_{i, j+1}) - b_{i, j+1}$\ninstead. From the above observation, we know that\n$\\sum_{i=1}^{K+1} \\sum_{j=0}^{len_i} \\max(b_{i, j}, b_{i, j+1}) - b_{i, j+1} = \\sum_{i=1}^{K+1} \\max(b_{i, 0}, b_{i, 1}) - b_{i, 1} + \\max(b_{i, len_i}, b_{i, len_i+1})-b_{i, len_i + 1} = \\sum_{i=1}^{K+1} \\max(m_i, b_{i, 1}) - b_{i, 1} + \\max(b_{i, len_i}, M_i)-M_i$\nFor the $K = 1$ subtask, we have $2$ ranges. Notice that $M_1 = M_2 = +10^6,$ so\nthat for $i = 1, 2$, we have\n$\\max(b_{i, len_i}, b_{i, len_i+1})-b_{i, len_i + 1} = M_i-M_i = 0$. Also, for\n$K = 1$, we have both $m_1 = m_2 = m$ as the only fixed value. So, we want to\nminimize $\\sum_{i=1}^{2} \\max(m, b_{i, 1}) - b_{i, 1}$. Let the unfixed values\nbe $c_1, c_2, \\dots, c_{N-1}$, in increasing value order. One of the values\n$b_{i, 1}$ is forced to be the value $c_1$, and because\n$\\max(m, b_{i, 1}) - b_{i, 1}$ is a decreasing function in $b_{i, 1}$, it\nsuffices to maximize the other $b_{i, 1}$. It is easy to prove that the maximum\nsuch value is $c_{\\max(len_1, len_2)+1}$, where we allocate a prefix of the\nvalues $c_1, c_2, \\dots, c_{N-1}$ to be in one range, and a suffix of the values\nto be in the other range.\nNow, we go for the full solution. Define the bounds of a range $i$ to be\n$[b_{i, 1}, b_{i, len_i}]$. Define the sequence of non-fixed values in\nincreasing order as $c_1, c_2, \\dots, c_{N-K}$. \nClaim: There is an optimal solution where for every two ranges one of the bounds\ncontains the other, or the bounds do not intersect. \nProof: WLOG, let the two ranges be ranges $1$ and $2$. Let the values currently\nallocated to range $1$ and $2$ be\n$c_{s_1} \\le c_{s_2} \\le \\dots \\le c_{s_{len_1+len_2}}$ for some sequence of\nindices $s_1 < s_2 \\dots < s_{len_1+len_2}$, such that $len_1$ of the values are\nallocated to range $1$ and $len_2$ of the values are allocated to range $2$.\nNow, if indices $s_1, s_{len_1+len_2}$ both belonged to the same range, then one\nrange would contain the other. Thus, we can assume WLOG that range $1$ contains\nindex $s_1$ and range $2$ contains index $s_{len_1+len_2}$. Also, if first\n$len_1$ values corresponding to indices $s_1, \\dots, s_{len_1}$ all belong to\nrange $1$, then the bounds do not intersect, and we are done. \nOtherwise, there is a $k$ such that $s_k$ belongs to range $2$ and $s_{k+1}$\nbelongs to range $1$. Now, if we can show that we can swap the values such that\n$s_k$ belongs to range $1$ and $s_{k+1}$ belongs to range $2$, then after making\nas many of these repeated swaps as possible, we are left in the case where the\nbounds do not intersect, and we are done. This is because if we list out which\nrange each $s_k$ belongs to as a sequence of $1$s and $2$s, each swap decreases\nthe number of inversions by $1$.\nNotice that because $s_1$ corresponds to $b_{1, 1}$ and $s_{len_1+len_2}$\ncorresponds to $b_{2, len_2}$, $s_k$ does not correspond to $b_{2, len_2}$, and\n$s_{k+1}$ does not correspond to $b_{1, 1}$. So, the effect of making the swap\non $s_k, s_{k+1}$ on $b_{1, 1}, b_{1, len_1}, b_{2, 1}, b_{2, len_2}$ can only\nresult in increasing $b_{2, 1}$ and decreasing $b_{1, len_1}$. \nRecall that the quantity for range $i$ that we want to minimize is\n$\\max(m_i, b_{i, 1}) - b_{i, 1} + \\max(b_{i, len_i}, M_i)-M_i$, which is\ndecreasing when we increase $b_{i, 1}$ and decrease $b_{i, len_i}$. Thus, making\nthe swap does not decrease the summation, as desired.\nNow, we can use dynamic programming, on consecutive subsegments of the array\n$c_1, c_2, \\dots, c_{N-K}$ and a subset of ranges ($O(N^22^K)$ states in total).\nThe state stores the  minimum sum of differences attainable if for each range in\nthe subset we only allocate values within the contiguous subsequence to it.\nSpecifically, $dp[L][R][sub]$ to be the minimum cost of assigning non-fixed\nvalues $c_L, c_{L+1}, \\dots, c_{R}$ to completely fill the ranges determined by\nthe mask $sub$, where do not necessarily use all of the values\n$c_L, \\dots, c_R$. \nFirst, if the number of required values to fill all ranges in $sub$ is more than\n$R-L+1$, then we set the cost to $+\\infty$. Now, there are three types of\ntransitions: \n\nIf $c_L$ does not belong to any range in $sub$, we transition to state\n$dp[L+1][R][sub]$. Similarly, if $c_R$ does not belong to any range in $sub$ we\ntransition to state $dp[L][R-1][sub]$. \n\nIf $c_L$ and $c_R$ belong to the same range $i$, then we know the value\n$\\max(m_i, b_{i, 1}) - b_{i, 1} + \\max(b_{i, len_i}, M_i)-M_i$ for range $i$,\nwhich we add to the current cost, and then transition to\n$dp[L+1][R-1][sub-2^i]$.\n\nElse, there must be some split point $M$ such that $c_L, \\dots, c_M$ belong to\nsome nonempty subset of ranges $sub_1$, and $c_{M+1}, \\dots, c_R$ belong to some\nnonempty subset of ranges $sub_2$, where $sub_1 \\cap sub_2 = \\emptyset$, and\n$sub_1 \\cup sub_2 = sub$.  So, we transition to\n$dp[L][M][sub_1] + dp[M+1][R][sub_2]$. \nClearly, we must have $M \\ge L+size(sub_1)-1$, where\n$size(sub_1) = \\sum_{i \\in sub_1} len_i$. Using a similar swapping argument as\nthe proof of the previous claim, it can be shown that it is optimal for\n$M = L+size(sub_1)-1$ (in other words, all of the values in the range $[L, M]$\nexactly correspond to ranges in $sub_1$ and no other ranges. \n\nThe answer is $dp[1][N-K][2^{\\text{# of ranges}}-1]$, plus the fixed quantity\nthat we subtracted out earlier.\nFor each $L, R$ and mask $sub$, we iterate over all submasks of $sub$, for a\ntotal time complexity of $O(N^2 3^K)$. \nRichard's Code (Full Solution):\n\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define sz(x) int((x).size())\n \nconst int MOD = 1e9+7;\n \nint dp[305][305][1<<7];\nint size_sum[1<<7];\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0);\n    int N, K; cin >> N >> K;\n    multiset<int> multi_vals;\n    vector<int> inp_a;\n    for(int i = 1; i <= N; i++){\n        int a; cin >> a; multi_vals.insert(a);\n        inp_a.push_back(a);\n    }\n \n    vector<pair<int, int>> xys;\n    for(int i = 1; i <= K; i++){\n        int x, y; cin >> x; y = inp_a[x-1];\n        xys.push_back(make_pair(x, y));\n        multi_vals.erase(multi_vals.find(y));\n    }\n    xys.push_back(make_pair(0, 1000000));\n    xys.push_back(make_pair(N+1, 1000000));\n    sort(begin(xys), end(xys));\n \n    vector<int> vals;\n    for(auto u: multi_vals) vals.push_back(u);\n \n    //xys and vals store the input\n \n    vector<pair<pair<int, int>, int>> rangs;\n    //((min, max), size)\n    int addon_zerosz = 0;\n    for(int i = 0; i+1 < sz(xys); i++){\n        int rang_size = xys[i+1].first-xys[i].first-1;\n        if(rang_size == 0){\n            addon_zerosz+=max(xys[i+1].second, xys[i].second);\n        }\n        else{\n            pair<int, int> rang_vals = make_pair(xys[i].second, xys[i+1].second);\n            if(rang_vals.first > rang_vals.second) swap(rang_vals.first, rang_vals.second);\n            rangs.push_back(make_pair(rang_vals, rang_size));\n        }\n    }\n \n    for(int i = 0; i < (1<<sz(rangs)); i++){\n        for(int j = 0; j < sz(rangs); j++){\n            if((i>>j)&1){\n                size_sum[i]+=rangs[j].second;\n            }\n        }\n    }\n \n \n    for(int i = 0; i < 305; i++) for(int j = 0; j < 305; j++) for(int k = 0; k < (1<<7); k++) dp[i][j][k] = MOD;\n \n    for(int L = sz(vals)-1; L >= 0; L--){\n        for(int R = L; R < sz(vals); R++){\n            for(int mask = 0; mask < (1<<sz(rangs)); mask++){\n                //compute dp[L][R][mask]\n                int rang_size = R-L+1;\n                if(size_sum[mask] > rang_size) continue;\n \n                if(size_sum[mask] <= rang_size-1){ //not use either end\n                    dp[L][R][mask] = min(dp[L][R][mask], dp[L+1][R][mask]);\n                    dp[L][R][mask] = min(dp[L][R][mask], dp[L][R-1][mask]);\n                }\n \n                //split in half somewhere by some submask\n                for(int submask = mask; ; submask = ((submask-1)&mask)){\n                    if(submask == 0) break;\n                    if(submask == mask) continue;\n                    dp[L][R][mask] = min(dp[L][R][mask], dp[L][L+size_sum[submask]-1][submask]+dp[L+size_sum[submask]][R][mask^submask]);\n                }\n \n                for(int k = 0; k < sz(rangs); k++){\n                    //assign L, R to be left and right of range k\n                    if((mask>>k)&1){\n                        if(size_sum[1<<k] == 1 && L < R) continue;\n                        \n                        //compute contribution of range k to the sum\n                        int small_val = vals[L];\n                        int big_val = vals[R];\n                        int contrib = max(big_val, rangs[k].first.second)-rangs[k].first.second + max(small_val, rangs[k].first.first)-small_val;\n                        assert(contrib >= 0);\n \n                        if((1<<k) == mask){\n                            //only thing left\n                        }\n                        else{\n                            assert(L+1 <= R-1);\n                            contrib+=dp[L+1][R-1][mask^(1<<k)];\n                        }\n                        dp[L][R][mask] = min(dp[L][R][mask], contrib);\n                    }\n                }\n                \n            }\n        }\n    }\n \n    int ans = dp[0][sz(vals)-1][(1<<sz(rangs))-1];\n \n    //add fixed term\n    for(auto u: vals){\n        ans+=u;\n    }\n    for(auto u: rangs){\n        ans+=u.first.second;\n    }\n    ans+=addon_zerosz;\n    ans-=2*1000000;\n    cout << ans << \"\\n\";\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1406_platinum_infinite_adventure": {"name": "Infinite Adventure", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1406", "test_data_link": "http://www.usaco.org/current/data/prob3_platinum_feb24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob3_platinum_feb24.html", "contest_link": "http://www.usaco.org/index.php?page=feb24results", "inner_contest_link": null, "problem_level": "platinum", "cp_id": "1406", "problem_id": "1406_platinum_infinite_adventure", "description": "\n**Note: The memory limit for this problem is 512MB, twice the default.**\nBessie is planning an infinite adventure in a land with $N$\n($1\\leq N \\leq 10^5$) cities. In each city $i$, there is a portal, as well as a\ncycling time $T_i$.  All $T_i$'s are powers of $2$, and\n$T_1 + \\cdots + T_N \\leq 10^5$. If you enter city $i$'s portal on day $t$, then\nyou instantly exit the portal in city\n$c_{i, t\\bmod{T_i}}$.\n\nBessie has $Q$ ($1\\leq Q \\leq 5\\cdot 10^4$) plans for her trip, each of which\nconsists of a tuple $(v, t, \\Delta)$. In each plan, she will start in city $v$\non day $t$. She will then do the following $\\Delta$ times: She will follow the\nportal in her current city, then wait one day. For each of her plans, she wants\nto know what city she will end up in.  \n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains two space-separated integers: $N$, the number of nodes,\nand $Q$, the number of queries.\n\nThe second line contains $N$ space-separated integers: $T_1, T_2, \\ldots, T_N$\n($1\\leq T_i$, $T_i$ is a power of $2$, and $T_1 + \\cdots + T_N \\leq 10^5$).\n\nFor $i = 1, 2, \\ldots, N$, line $i+2$ contains $T_i$ space-separated positive\nintegers, namely $c_{i, 0}, \\ldots, c_{i, T_i-1}$ ($1\\leq c_{i, t} \\leq N$).\n\nFor $j = 1, 2, \\ldots, Q$, line $j+N+2$ contains three space-separated positive\nintegers, $v_j, t_j, \\Delta_j$ ($1\\leq v_j \\leq N$, $1\\leq t_j \\leq 10^{18}$,\nand $1\\leq \\Delta_j \\leq 10^{18}$) representing the $j$th query.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nPrint $Q$ lines. The $j$th line must contain the answer to the $j$th query.\n\nSAMPLE INPUT:\n5 4\n1 2 1 2 8\n2\n3 4\n4\n2 3\n5 5 5 5 5 1 5 5\n2 4 3\n3 3 6\n5 3 2\n5 3 7\nSAMPLE OUTPUT: \n2\n2\n5\n4\n\nBessie's first three adventures proceed as follows:\n\nIn the first adventure, she goes from city $2$ at time $4$ to city $3$ at time $5$, to city $4$ at time $6$, to city $2$ at time $7$.\n\nIn the second adventure, she goes from city $3$ at time $3$ to city $4$ at time $4$, to city $2$ at time $5$, to city $4 $ at time $6$, to city $2$ at time $7$, to city $4$ at time $8$, to city $2$ at time $9$.\n\nIn the third adventure, she goes from city $5$ at time $3$ to city $5$ at time $4$, to city $5$ at time $5$.\n\nSAMPLE INPUT:\n5 5\n1 2 1 2 8\n2\n3 4\n4\n2 3\n5 5 5 5 5 1 5 5\n2 4 3\n3 2 6\n5 3 2\n5 3 7\n5 3 1000000000000000000\nSAMPLE OUTPUT: \n2\n3\n5\n4\n2\n\nSCORING:\nInput 3: $\\Delta_j \\leq 2\\cdot 10^2$.Inputs 4-5: $N, \\sum T_j\\leq 2\\cdot 10^3$.Inputs 6-8: $N, \\sum T_j\\leq 10^4$.Inputs 9-18: No additional constraints.\n\n\nProblem credits: Brandon Wang\n", "num_tests": 18, "solution": "\n(Analysis by Danny Mittal)\nDefine $D$ to be the maximum value of $\\Delta_j$ over all queries $j$ and $S$ to\nbe the maximum value of $T_i$ over all cities $i$.\nSubtask 1: $D \\leq 200$\nBy storing the sequence $c_{i, 0}, \\ldots, c_{i, T_i - 1}$ as an array for each\ncity $i$, we can calculate the next city Bessie will go to each day in constant\ntime given the current day $t$ and her current city $i$ by looking at index\n$t \\bmod T_i$ in the array for $i$.\nThis means that we can answer each query in $O(\\Delta_j)$ time, making this\nsolution $O(\\sum T_i + QD)$, which is fast enough here.\nSubtask 2: $N, \\sum T_i \\leq 2 \\cdot 10^3$\nConsider a situation where Bessie is currently at city $i$ on day $t$, and we\nknow $i$ but only know $t \\bmod S$. In order to figure out which city Bessie\nwill go to next, we need to know $t$ modulo $T_i$. Crucially, because $T_i$ is a\npower of $2$ for all $i$, and $S$ is the maximum of all them, $S$ will also be a\npower of $2$ at least as large as $T_i$ and will therefore be a multiple of\n$T_i$. This means that given $t \\bmod S$ we can simply mod by $T_i$ to get\n$t \\bmod T_i$.\nThus, given $i$ and $t \\bmod S$, we know exactly what city Bessie will go to\nnext. This suggests constructing a directed graph whose nodes are pairs $(i, t)$\nof a city $i$ and a day $t$ that we consider to be modulo $S$ (so in particular,\nthere are only $S$ values of $t$). Each node has one outgoing edge pointing to\nanother node (which makes this a functional graph, though we don't need to\nexploit this structure).\nWe now wish to be able to calculate which node we will get to if we follow the\noutgoing edge $\\Delta$ times for large $\\Delta$. To do this, we can use binary\nlifting (construct a table storing for each node which node we will get to if we\nfollow the outgoing edge $2^k$ times for all $2^k \\leq D$, then use this table\nto answer each query in $O(\\log D)$).\nThere are $N \\cdot S$ nodes, and for each one we calculate $O(\\log D)$ entries,\nmaking the construction $O(NS\\log D)$. Answering queries is then $O(Q\\log D)$,\nmaking the overall runtime $O((NS + Q)\\log D)$. $S$ is bounded by $\\sum T_i$,\nand in this case is at most $2^{10}$, making this fast enough. \nJava code:\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class InfiniteAdventureN2 {\n    public static final int LG = 60;\n    public static final int S = 1024;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        int q = Integer.parseInt(tokenizer.nextToken());\n        int[][] period = new int[n + 1][];\n        tokenizer = new StringTokenizer(in.readLine());\n        for (int city = 1; city <= n; city++) {\n            period[city] = new int[Integer.parseInt(tokenizer.nextToken())];\n        }\n        for (int city = 1; city <= n; city++) {\n            tokenizer = new StringTokenizer(in.readLine());\n            for (int t = 0; t < period[city].length; t++) {\n                period[city][t] = Integer.parseInt(tokenizer.nextToken());\n            }\n        }\n\n        int[][][] binaryLift = new int[n + 1][S][LG];\n        for (int city = 1; city <= n; city++) {\n            for (int t = 0; t < S; t++) {\n                binaryLift[city][t][0] = period[city][t % period[city].length];\n            }\n        }\n\n        for (int k = 1; k < LG; k++) {\n            for (int city = 1; city <= n; city++) {\n                for (int t = 0; t < S; t++) {\n                    int halfwayCity = binaryLift[city][t][k - 1];\n                    int halfwayT = (int) ((t + (1L << (k - 1))) % S);\n                    binaryLift[city][t][k] = binaryLift[halfwayCity][halfwayT][k - 1];\n                }\n            }\n        }\n\n        StringBuilder out = new StringBuilder();\n        for (int j = 0; j < q; j++) {\n            tokenizer = new StringTokenizer(in.readLine());\n            int currentCity = Integer.parseInt(tokenizer.nextToken());\n            long currentDay = Long.parseLong(tokenizer.nextToken());\n            long daysAdventured = Long.parseLong(tokenizer.nextToken());\n\n            for (int k = LG - 1; k >= 0; k--) {\n                if ((daysAdventured & (1L << k)) != 0L) {\n                    int t = (int) (currentDay % S);\n                    currentCity = binaryLift[currentCity][t][k];\n                    currentDay += 1L << k;\n                }\n            }\n\n            out.append(currentCity).append('\\n');\n        }\n        System.out.print(out);\n    }\n}\n\nSubtask 3: $N, \\sum T_i \\leq 10^4$\nWe want to do binary lifting like we did for Subtask 2, but a graph with $NS$\nnodes would now be too large. Therefore, instead of considering pairs of the\nform $(i, t)$ where $t$ is modulo $S$ for all $i$, we will consider $t$ to be\nmodulo $T_i$, so that the number of pairs is equal to $\\sum T_i \\leq 10^5$. \nWhat goes wrong if we try to now just do binary lifting on these pairs? Consider\na situation where we have two cities $a$ and $b$ such that $T_a < T_b$. Suppose\nthat when Bessie is at city $a$ and the day is $t$ modulo $T_a$, Bessie goes\nnext to city $b$. To calculate the binary lifting entry for Bessie going\n$2^1 = 2$ steps from $(a, t)$, we want to know where Bessie will go immediately\nafter city $b$. However, we can't know this just from $t \\bmod T_a$, because\nthat doesn't determine $t \\bmod T_b$.\nThis problem makes constructing a full binary lifting table impossible. To solve\nthis, we will divide the cities into levels. At this point, there are two\npotential  approaches:\nApproach 1 (Level by $T_i$):\nEach level contains all the cities with the same value of $T_i$.\nFor each city, we can at least construct the binary lifting table for that city\nup to the point where we reach a city of a higher level. If we also store the\namount of days it takes for us to get to that first city of a higher level, then\nwe can use the binary lifting table as follows:\nTo figure out where Bessie ends up if she starts at $(i, t)$ and adventures for\n$\\Delta$ days, we repeatedly do the following:\nIf, starting from $(i, t)$ it takes at most $\\Delta$ days to reach a city of\na higher level, then go to that city.Otherwise, find the highest power\nof $2$ at most $\\Delta$ and use the binary lifting table to travel that many\ndays.Update $i, t, \\Delta$ accordingly.\nThe second bullet point can be done at most $\\lg D$ times, and because there are\nat most $\\lg S$ levels, the first bullet point can be done at most $\\lg S$ times\nin a row. This means that such a calculation takes $O(\\lg D \\lg S)$ time.\nWe can first construct the binary lifting table by going in order of increasing\npowers of $2$ and applying the above procedure to the existing entries (and also\ncalculate when a higher level is reached where applicable), then use the same\nprocedure to answer the queries. There are $\\sum T_i \\lfloor\\lg D\\rfloor$\nentries and $Q$ queries, so the runtime complexity is\n$$O\\left(\\left(\\sum T_i\\lg D + Q\\right)\\lg D \\lg S\\right)$$\nwhich is fast enough.\nApproach 2 (sqrt decomposition):\nWe will split the nodes into small and large nodes, where small nodes have\n$T_i \\leq \\sqrt S$ and large nodes have $T_i > \\sqrt S$. For each large node\n$i$, we will compute the binary lifting table for all $(i, t)$,  but for each\nsmall node we will only compute the binary lifting table for $(i, t)$ for\n$0\\leq t < \\sqrt S$ (i.e. for small nodes we only consider time mod $\\sqrt S$).\nIn addition, for each small node we will store the min. time required to reach a\nbig node,  and only store the $k$th entry of the $(i, t)$ table (corresponding\nto location after $2^k$ steps) if after $2^k$ steps we have never encountered a\nlarge node.\nWe can compute the small nodes in just $O(N\\sqrt S \\lg D)$,  For large nodes, to\ncompute the $k$th entry, we first refer to the $k-1$th entry. If this is a large\nnode, we are immediately done, otherwise we jump to the next large node, and\nthen recurse (roughly we are performing a query). This takes\n$O(\\sum T_i\\sqrt S \\lg^2 D)$.\nTo do a query, we do the following, for $k = 60, 59, \\ldots, 0$: If the next\nlarge node is within $\\Delta$ away, jump to the next large node (and increment\n$t$ and decrement $\\Delta$). Now, if $\\Delta \\geq 2^k$, jump to the next\nposition in the binary lifting table (and modify $t$ and $\\Delta$). This takes\n$O(\\lg D)$ per query, so the total runtime is\n$O(\\sum T_i \\sqrt S \\lg^2 D + Q\\lg D)$.\nJava code for the first approach:\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class InfiniteAdventure {\n    public static final int LG = 60;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        int q = Integer.parseInt(tokenizer.nextToken());\n        int[][] period = new int[n + 1][];\n        tokenizer = new StringTokenizer(in.readLine());\n        for (int city = 1; city <= n; city++) {\n            period[city] = new int[Integer.parseInt(tokenizer.nextToken())];\n        }\n        for (int city = 1; city <= n; city++) {\n            tokenizer = new StringTokenizer(in.readLine());\n            for (int t = 0; t < period[city].length; t++) {\n                period[city][t] = Integer.parseInt(tokenizer.nextToken());\n            }\n        }\n\n        int[][][] binaryLift = new int[n + 1][][];\n        int[][] firstHigher = new int[n + 1][];\n        long[][] firstHigherDays = new long[n + 1][];\n        for (int a = 1; a <= n; a++) {\n            binaryLift[a] = new int[period[a].length][LG];\n            firstHigherDays[a] = new long[period[a].length];\n            firstHigher[a] = new int[period[a].length];\n            for (int k = 0; k < period[a].length; k++) {\n                if (period[period[a][k]].length > period[a].length) {\n                    firstHigherDays[a][k] = 1;\n                    firstHigher[a][k] = period[a][k];\n                } else {\n                    binaryLift[a][k][0] = period[a][k];\n                }\n            }\n        }\n\n        for (int k = 1; k < LG; k++) {\n            for (int city = 1; city <= n; city++) {\n                for (int t = 0; t < period[city].length; t++) {\n                    if (firstHigherDays[city][t] == 0) {\n                        int laterCity = binaryLift[city][t][k - 1];\n                        long remainingDays = 1L << (k - 1);\n                        int e = k - 1;\n                        long currentDay = ((long) t) + (1L << (k - 1));\n                        while (remainingDays > 0 && period[laterCity].length <= period[city].length) {\n                            while ((1L << e) > remainingDays) {\n                                e--;\n                            }\n                            int laterT = (int) (currentDay % period[laterCity].length);\n                            if (firstHigherDays[laterCity][laterT] != 0 && firstHigherDays[laterCity][laterT] <= (1L << e)) {\n                                remainingDays -= firstHigherDays[laterCity][laterT];\n                                currentDay += firstHigherDays[laterCity][laterT];\n                                laterCity = firstHigher[laterCity][laterT];\n                            } else {\n                                remainingDays -= 1L << e;\n                                currentDay += 1L << e;\n                                laterCity = binaryLift[laterCity][laterT][e];\n                            }\n                        }\n                        if (period[laterCity].length > period[city].length) {\n                            firstHigherDays[city][t] = (1L << k) - remainingDays;\n                            firstHigher[city][t] = laterCity;\n                        } else {\n                            binaryLift[city][t][k] = laterCity;\n                        }\n                    }\n                }\n            }\n        }\n\n        StringBuilder out = new StringBuilder();\n        for (int j = 0; j < q; j++) {\n            tokenizer = new StringTokenizer(in.readLine());\n            int currentCity = Integer.parseInt(tokenizer.nextToken());\n            long currentDay = Long.parseLong(tokenizer.nextToken());\n            long remainingDays = Long.parseLong(tokenizer.nextToken());\n\n            int k = LG - 1;\n\n            while (remainingDays > 0) {\n                while ((1L << k) > remainingDays) {\n                    k--;\n                }\n                int t = (int) (currentDay % period[currentCity].length);\n                if (firstHigherDays[currentCity][t] != 0 && firstHigherDays[currentCity][t] <= (1L << k)) {\n                    remainingDays -= firstHigherDays[currentCity][t];\n                    currentDay += firstHigherDays[currentCity][t];\n                    currentCity = firstHigher[currentCity][t];\n                } else {\n                    remainingDays -= 1L << k;\n                    currentDay += 1L << k;\n                    currentCity = binaryLift[currentCity][t][k];\n                }\n            }\n\n            out.append(currentCity).append('\\n');\n        }\n        System.out.print(out);\n    }\n}\n\nFull solution\nThe bottleneck in the first approach to Subtask 3 is the fact that the amount of\nentries in the binary lifting table is already $\\log$ times linear, and we then\nhave to spend $\\log^2$ on calculating each entry. In a normal binary lifting\ntable, calculation of each entry is constant because you just look at two\nexisting entries.\nSo, we want to make our binary lifting table more like a normal one. To do this,\nwe will construct a binary lifting table for each level instead: the $k$th entry\nfor $(i, t)$ will, instead of telling you what city you will reach after $2^k$\ndays, tell you the $2^k$th city you will reach that is at the same level as $i$.\nThis can then be computed in constant time using previous entries.\nTo construct the base of the binary lifting table, we will need to know for each\npair $(i, t)$ what the soonest is that Bessie reaches a city $j$ at the\nsame level as $i$ (and what $j$ is), in addition to the same for Bessie\nreaching a higher level.\nIf Bessie starts from $(i, t)$, let the first city she encounters of the same\nlevel be $f(i, t)$ and the first city she encounters of the same level\n$g(i, t)$. Before, we calculated $g(i, t)$ as part of the binary lifting\nconstruction, but now $f$ needs to be calculated beforehand, so we will\ncalculate $f$ and $g$ together recursively:\nFrom $(i, t)$, check what city $j$ Bessie will go to next.\nIf $j$ is at a higher level than $i$, then we know that $f(i, t)$ doesn't\nexist and $g(i, t) = j$.If\n$j$ is at the same level as $i$, then we know that $f(i, t) = j$ and\n$g(i, t) = g(j, t + 1)$.Otherwise, we can update $t$ and repeatedly compute $j = g(j, t)$ until we\nreach one of the first two situations, taking $O(\\log S)$ time as there are\n$O(\\log S)$ levels (note that we also need to store the number of days needed to\nreach $f(i, t)$ and $g(i, t)$).This step thus takes\n$O(\\sum T_i \\log S)$ time.\nOnce those are calculated, we can calculate the binary lifting tables for each\nlevel, which will store not only the $2^k$th city in the same level that we get\nto but also the number of days needed to get there. The time taken is constant\nfor each of the $O(\\log D)$ entries per pair $(i, t)$, so $O(\\sum T_i \\log D)$\noverall.\nTo answer a query, we take a greedy strategy similar to in Subtask 3. Keeping\ntrack of our current city i and current day t, as well as the day that Bessie\nstops:\nWhile we have time to go to the next city with a higher level $g(i, t)$, we\ngo there. This takes $O(\\log S)$ steps.Then, we use the binary lifting\ntable to go as far as we can in our current level (note that for each\n$2^k \\leq D$ instead of checking whether the number of days left to go is at\nleast $2^k$, we need to check against the number of days needed to travel to\n$2^k$ cities in the same level, which we also stored in our table), which takes\n$O(\\log D)$ steps.If we have gone as far as possible in the current\nlevel and haven't finished Bessie's adventure yet, we go to the immediately next\ncity (using $1$ day) and repeat the process from there.\nEach iteration of this process takes $O(\\log S + \\log D)$ time, and each time we\nrepeat it, after we increase our level as much as possible (the first bullet\npoint) we end up at a lower level than last time, which means that we repeat the\nprocess at most $O(\\log S)$ times. Thus, the entire calculation takes\n$O(\\log S(\\log S + \\log D))$ time.\nThe overall runtime is therefore\n$$O\\left(\\sum T_i \\log S + \\sum T_i\\log D + Q\\log S \\left(\\log S + \\log D\\right)\\right) = O\\left(\\left(\\sum T_i + Q\\log S\\right)\\left(\\log S + \\log D\\right)\\right)$$\nwhich is fast enough.\nJava code:\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class InfiniteAdventure {\n    public static final int LG = 60;\n    public static final long LIMIT = 1_000_000_000_000_000_000L;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        int q = Integer.parseInt(tokenizer.nextToken());\n        int[][] period = new int[n + 1][];\n        tokenizer = new StringTokenizer(in.readLine());\n        for (int city = 1; city <= n; city++) {\n            period[city] = new int[Integer.parseInt(tokenizer.nextToken())];\n        }\n        for (int city = 1; city <= n; city++) {\n            tokenizer = new StringTokenizer(in.readLine());\n            for (int t = 0; t < period[city].length; t++) {\n                period[city][t] = Integer.parseInt(tokenizer.nextToken());\n            }\n        }\n\n        int[][] firstHigher = new int[n + 1][];\n        long[][] firstHigherDays = new long[n + 1][];\n        int[][][] binaryLift = new int[n + 1][][];\n        long[][][] binaryLiftDays = new long[n + 1][][];\n\n\n        for (int a = 1; a <= n; a++) {\n            firstHigher[a] = new int[period[a].length];\n            firstHigherDays[a] = new long[period[a].length];\n            binaryLift[a] = new int[period[a].length][LG];\n            binaryLiftDays[a] = new long[period[a].length][LG];\n        }\n\n        new Object() {\n            boolean[][] seen = new boolean[n + 1][];\n\n            void perform() {\n                for (int a = 1; a <= n; a++) {\n                    seen[a] = new boolean[period[a].length];\n                }\n                for (int a = 1; a <= n; a++) {\n                    for (int k = 0; k < period[a].length; k++) {\n                        calc(a, k);\n                    }\n                }\n            }\n\n            void calc(int city, int t) {\n                if (!seen[city][t]) {\n                    seen[city][t] = true;\n\n                    int laterCity = period[city][t];\n                    long days = 1;\n                    while (laterCity != 0 && period[laterCity].length <= period[city].length) {\n                        int laterT = (int) ((t + days) % period[laterCity].length);\n                        calc(laterCity, laterT);\n                        if (period[laterCity].length == period[city].length) {\n                            binaryLift[city][t][0] = laterCity;\n                            binaryLiftDays[city][t][0] = days;\n                        }\n                        days += firstHigherDays[laterCity][laterT];\n                        laterCity = firstHigher[laterCity][laterT];\n                    }\n                    if (laterCity != 0) {\n                        firstHigher[city][t] = laterCity;\n                        firstHigherDays[city][t] = days;\n                    }\n                }\n            }\n        }.perform();\n\n        for (int k = 1; k < LG; k++) {\n            for (int city = 1; city <= n; city++) {\n                for (int t = 0; t < period[city].length; t++) {\n                    if (firstHigher[city][t] == 0 || firstHigherDays[city][t] > (1L << k)) {\n                        int halfwayCity = binaryLift[city][t][k - 1];\n                        if (halfwayCity != 0) {\n                            int halfwayT = (int) ((t + binaryLiftDays[city][t][k - 1]) % period[city].length);\n                            long days = binaryLiftDays[city][t][k - 1] + binaryLiftDays[halfwayCity][halfwayT][k - 1];\n                            if (binaryLift[halfwayCity][halfwayT][k - 1] != 0 && days <= LIMIT) {\n                                binaryLift[city][t][k] = binaryLift[halfwayCity][halfwayT][k - 1];\n                                binaryLiftDays[city][t][k] = days;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        StringBuilder out = new StringBuilder();\n        for (int j = 0; j < q; j++) {\n            tokenizer = new StringTokenizer(in.readLine());\n            int currentCity = Integer.parseInt(tokenizer.nextToken());\n            long currentDay = Long.parseLong(tokenizer.nextToken());\n            long remainingDays = Long.parseLong(tokenizer.nextToken());\n\n            while (remainingDays > 0) {\n                while (true) {\n                    int t = (int) (currentDay % period[currentCity].length);\n                    if (firstHigher[currentCity][t] == 0 || remainingDays < firstHigherDays[currentCity][t]) {\n                        break;\n                    }\n                    currentDay += firstHigherDays[currentCity][t];\n                    remainingDays -= firstHigherDays[currentCity][t];\n                    currentCity = firstHigher[currentCity][t];\n                }\n\n                for (int k = LG - 1; k >= 0; k--) {\n                    int t = (int) (currentDay % period[currentCity].length);\n                    if (binaryLift[currentCity][t][k] != 0 && remainingDays >= binaryLiftDays[currentCity][t][k]) {\n                        currentDay += binaryLiftDays[currentCity][t][k];\n                        remainingDays -= binaryLiftDays[currentCity][t][k];\n                        currentCity = binaryLift[currentCity][t][k];\n                    }\n                }\n                if (remainingDays > 0) {\n                    int t = (int) (currentDay % period[currentCity].length);\n                    currentDay++;\n                    remainingDays--;\n                    currentCity = period[currentCity][t];\n                }\n            }\n\n            out.append(currentCity).append('\\n');\n        }\n        System.out.print(out);\n    }\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": ["\n**Note: The memory limit for this problem is 512MB, twice the default."], "runtime_limit": 2, "memory_limit": 512}, "1401_gold_bessla_motors": {"name": "Bessla Motors", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1401", "test_data_link": "http://www.usaco.org/current/data/prob1_gold_feb24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob1_gold_feb24.html", "contest_link": "http://www.usaco.org/index.php?page=feb24results", "inner_contest_link": null, "problem_level": "gold", "cp_id": "1401", "problem_id": "1401_gold_bessla_motors", "description": "\n**Note: The time limit for this problem is 3s, 1.5x the default. The memory\nlimit for this problem is 512MB, twice the default.**\nFarmer John would like to promote his line of Bessla electric tractors by\nshowcasing Bessla's network of charging stations. He has identified $N$\n($2\\le N\\le 5\\cdot 10^4$) points of interest labeled $1\\dots N$, of which the\nfirst $C$ ($1\\le C < N$) are charging stations and the remainder are travel\ndestinations. These points of interest are interconnected by $M$\n($1\\le M\\le 10^5$) bidirectional roads, the $i$-th of which connects distinct\npoints $u_i$ and $v_i$ ($1\\le u_i, v_i\\le N$) and has length $\\ell_i$ miles\n($1\\le\\ell_i\\le 10^9$).\n\nA Bessla can travel up to $2R$ miles ($1\\le R\\le 10^9$) on a single charge,\nallowing it to reach any destination within $R$ miles of a charging station. A\ndestination is deemed well-connected if it is reachable from at least $K$\n($1\\le K\\le 10$) distinct charging stations. Your task is to assist Farmer John\nin identifying the set of well-connected travel destinations.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains five space-separated integers $N$, $M$, $C$, $R$, and\n$K$. Each of the following $M$ lines contains three space-separated integers\n$u_i$, $v_i$, and $\\ell_i$ such that $u_i\\neq v_i$.\n\nThe charging stations are labeled $1, 2, \\ldots, C$. The remaining points of\ninterest are all travel destinations.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFirst, output the number of well-connected travel destinations on a single line.\nThen, list all well-connected travel destinations in ascending order, each on a\nseparate line.\n\nSAMPLE INPUT:\n3 3 1 4 1\n1 2 3\n1 3 5\n2 3 2\nSAMPLE OUTPUT: \n1\n2\n\nWe have one charging station at $1$. From this charging station, we can reach\npoint $2$ (since it is distance $3$ away from $1$), but not point $3$ (since it\nis distance $5$ away from $1$). Thus, only point $2$ is well-connected.\n\nSAMPLE INPUT:\n4 3 2 101 2\n1 2 1\n2 3 100\n1 4 10\nSAMPLE OUTPUT: \n2\n3\n4\n\nWe have charging stations at $1$ and $2$, and both points $3$ and $4$ are within\ndistance $101$ of both $1$ and $2$. Thus, both points $3$ and $4$ are well-connected.\n\nSAMPLE INPUT:\n4 3 2 100 2\n1 2 1\n2 3 100\n1 4 10\nSAMPLE OUTPUT: \n1\n4\n\nSCORING:\nInputs 4 and 5: $K = 2$ and $N \\le 500$ and\n$M\\le 1000$.Inputs 6 and 7: $K = 2$.Inputs 8-15: No additional constraints.\n\n\nProblem credits: Alexander Wei\n", "num_tests": 15, "solution": "\nWe can represent the given network of chargers and destinations as a weighted,\nundirected graph $G$, whose vertices correspond to chargers (vertex IDs $1$\nthrough $C$) and destinations (vertex IDs $C+1$ through $N$) and whose edges\ncorrespond to roads.\nSubtask 1\nFor the first subtask, we can run Dijkstra's algorithm once using each\ndestination as a source to check whether that destination can reach $K$ distinct\ncharging stations. This runs in $O(NM\\log N)$ time.\nSubtask 2\nFor the second subtask, we solve the problem in $O(M\\log^2 N)$ for the case\n$K = 2$.\nGiven a partition of the chargers into two groups, we first describe how to find\nall destinations reachable from at least one charger in each group in\n$O(M\\log N)$. For any group of chargers, we can find all destinations reachable\nby some charger in the group with a \"multi-source\" version of Dijkstra's\nalgorithm by initializing all chargers in the group to distance $0$. Running\nthis once for each group lets us identify all well-connected destinations\n\"verified\" by a given partition of the chargers into two groups. \nTo turn this into a full solution for $K=2$, we construct a set of partitions\nsuch that each pair of chargers ends up in distinct groups at least once.\nSpecifically, partition the chargers by the $i$th binary digit of their vertex\nIDs, for each $i$ between $0$ and $\\log N$. Each pair of vertex IDs differs in\nat least one bit, so this set of partitions will separate each pair of chargers\nat least once. Then, running the above subroutine for each partition will\n\"verify\" every well-connected vertex at least once. Since we have $O(\\log N)$\npartitions, this algorithm runs in $O(M\\log^2 N)$.\nSubtask 3\nTo solve the last subtask, one can directly modify Dijkstra's algorithm. Rather\nthan running \"multi-source\" Dijkstra's as in Subtask 2, we simulate running\n$C$ parallel copies of Dijkstra's algorithm, one from each charger. In our\nsimulation, we process all vertices at distance $d$ from each source before\nprocessing vertices at distance $d+1$. We also break after processing after\nprocessing all vertices at distance $>R$. Exactly those vertices that are\nvisited from at least $K$ distinct chargers are well-connected.\nHowever, this approach as described is inefficient, because each vertex can be\nvisited up to $C$ times. The key observation to make this approach run in time\nis to note that we only need to visit each vertex $v$ from $K$ distinct\nchargers. We can skip further visits because the first $K$ visits to $v$ will\ncover any well-connected vertex $u$ that is reachable through $v$.\nTo implement these runs of Dijkstra from $C$ sources in parallel, we can have a\nheap consisting of tuples (distance, vertex, root), with root denoting the\nDijkstra source of that heap element. And rather than having a boolean \"visited\"\narray (which would use $O(N^2)$ memory), we track visited pairs (vertex, root)\nin a hash map for $O(1)$ lookups and $O(1)$ memory per entry. When visiting\nvertices, we skip any vertex that has been visited $K$ times and any vertex with\ndistance $>R$.\nAll together, this leads to an algorithm that runs in $O(KM\\log N)$. Since each\nvertex is visited at most $K$ times, each edge is processed at most $2K$ times.\nHence, at most $O(KM)$ elements are ever inserted into the heap.\n\n#include <iostream>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n \nconst int MAXN = 50000;\n \nint N, M, C, R, K;\nvector<pair<int, int>> adj[MAXN];\n \nint visits[MAXN];\nunordered_set<int> visitors[MAXN];\n \nint main() {\n  ios_base::sync_with_stdio(false);\n \n  cin >> N >> M >> C >> R >> K;\n \n  for (int i = 0; i < M; i++) {\n    int u, v, l;\n    cin >> u >> v >> l;\n    u -= 1;\n    v -= 1;\n    adj[u].push_back({v, l});\n    adj[v].push_back({u, l});\n  }\n \n  priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\n  // Initialize with all charging stations in the queue\n  for (int i = 0; i < C; i++) {\n    pq.push({0, i, i});\n  }\n \n  // Dijkstra's algorithm, except we (i) visit each node up to K times and (ii) only visit nodes\n  // along paths of length at most R\n  int well_connected = 0;\n  while (!pq.empty()) {\n    const auto [d, u, r] = pq.top();\n    pq.pop();\n    if (visits[u] == K || visitors[u].find(r) != visitors[u].end()) {\n      continue;\n    }\n    // Update the number of visits and our count of well-connected destinations\n    visits[u] += 1;\n    visitors[u].insert(r);\n    if (u >= C && visits[u] == K) {\n      well_connected += 1;\n    }\n    // Add all neighbors within the range that have not been visited K times to the queue\n    for (const auto& [v, l] : adj[u]) {\n      if (d + l <= R && visits[v] < K) {\n        pq.push({d + l, v, r});\n      }\n    }\n  }\n \n  cout << well_connected << \"\\n\";\n  for (int i = C; i < N; i++) {\n    if (visits[i] == K) {\n      cout << i + 1 << \"\\n\";\n    }\n  }\n}\n\n", "runtime_limit_sentences": ["\n**Note: The time limit for this problem is 3s, 1."], "memory_limit_sentences": [" The memory\nlimit for this problem is 512MB, twice the default."], "runtime_limit": 3, "memory_limit": 512}, "1402_gold_milk_exchange": {"name": "Milk Exchange", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1402", "test_data_link": "http://www.usaco.org/current/data/prob2_gold_feb24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob2_gold_feb24.html", "contest_link": "http://www.usaco.org/index.php?page=feb24results", "inner_contest_link": null, "problem_level": "gold", "cp_id": "1402", "problem_id": "1402_gold_milk_exchange", "description": "\nFarmer John's $N$ $(1 \\leq N \\leq 5 \\cdot 10^5)$ cows are lined up in a circle.\nThe $i$th cow has a bucket with integer capacity $a_i$ $(1 \\leq a_i \\leq 10^9)$\nliters. All buckets are initially full.\n\nEvery minute, cow $i$ will pass all the milk in their bucket to cow $i+1$ for\n$1\\le i<N$, with cow $N$ passing its milk to cow $1$. All exchanges happen\nsimultaneously (i.e., if a cow has a full bucket but gives away $x$ liters of\nmilk and also receives $x$ liters, her milk is preserved). If a cow's total milk\never ends up exceeding $a_i$, then the excess milk will be lost.\n\nAfter each of $1, 2, \\dots, N$ minutes, how much total milk is left among all\ncows?\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$. \n\nThe next line contains integers $a_1,a_2,...,a_N$.\n\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput $N$ lines, where the $i$-th line is the total milk left among all cows\nafter $i$ minutes.\n\nSAMPLE INPUT:\n6\n2 2 2 1 2 1\nSAMPLE OUTPUT: \n8\n7\n6\n6\n6\n6\n\nInitially, the amount of milk in each bucket is $[2, 2, 2, 1, 2, 1]$.\nAfter $1$ minute, the amount of milk in each bucket is $[1, 2, 2, 1, 1, 1]$\nso the total amount of milk is $8$.After $2$ minutes, the amount of\nmilk in each bucket is $[1, 1, 2, 1, 1, 1]$ so the total amount of milk is\n$7$.After $3$ minutes, the amount of milk in each bucket is\n$[1, 1, 1, 1, 1, 1]$ so the total amount of milk is $6$.After $4$\nminutes, the amount of milk in each bucket is  $[1, 1, 1, 1, 1, 1]$ so the total\namount of milk is $6$.After $5$ minutes, the amount of milk in each\nbucket is $[1, 1, 1, 1, 1, 1]$ so the total amount of milk is $6$.After $6$ minutes, the amount of milk in each bucket is $[1, 1, 1, 1, 1, 1]$\nso the total amount of milk is\n$6$.\nSAMPLE INPUT:\n8\n3 8 6 4 8 3 8 1\nSAMPLE OUTPUT: \n25\n20\n17\n14\n12\n10\n8\n8\n\nAfter $1$ minute, the amount of milk in each bucket is\n$[1, 3, 6, 4, 4, 3, 3, 1]$ so the total amount of milk is $25$.\n\nSAMPLE INPUT:\n10\n9 9 10 10 6 8 2 1000000000 1000000000 1000000000\nSAMPLE OUTPUT: \n2000000053\n1000000054\n56\n49\n42\n35\n28\n24\n20\n20\n\nSCORING:\nInputs 4-5: $N \\le 2000$Inputs 6-8: $a_i \\le 2$Inputs\n9-13: All $a_i$ are generated uniformly at random in the range $[1,10^9]$. Inputs 14-23: No additional constraints.\n\n\nProblem credits: Chongtian Ma, Alex Liang, Patrick Deng\n", "num_tests": 23, "solution": "\n(Analysis by Chongtian Ma, Alex Liang, and Patrick Deng)\nSubtask 1: $N \\le 2000$.\nWe can directly simulate the process according to the problem statement. We can\nkeep track of the amount of milk that each cow has and update in\n$\\mathcal{O}(N)$ each minute leading to an $\\mathcal{O}(N^2)$ solution.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0); \n    int n;\n    cin >> n;\n\n    vector<int> cap(n), cur(n); \n    \n    for (int i = 0; i < n; i++){\n        cin >> cap[i];\n        cur[i] = cap[i];\n    }\n    \n    for (int minute = 1; minute <= n; minute++){\n        rotate(cur.begin(), cur.begin() + n - 1, cur.end());\n\n        for (int i = 0; i < n; i++)\n            cur[i] = min(cur[i], cap[i]);\n\n        cout<<accumulate(cur.begin(), cur.end(), 0LL)<<\"\\n\";\n    }\n}\n\nSubtask 2: $a_i \\le 2$.\nEach bucket has capacity of either $1$ or $2$ in this subtask. Consider a cow\nthat starts off with $2$ unit of milk. That specific $2$ units of milk will keep\ngetting passed until  it reaches a bucket with capacity $1$ where it will be\nreduced to $1$ unit of milk.\nFor each $a_i=2$ we want to find the time $t$ in which it will reach a bucket\nwith capacity $1$. Then we know that $1$ milk is lost at time $t$. We can find\n$t$ by finding the first $a_j=1$ on the right of $i$.\nWe can rotate the array such that the minimum element appears at the end.\nIterating over the array backwards and keeping track of the most recent $1$\nleads to an $\\mathcal{O}(N)$ solution.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0); \n    int n;\n    cin >> n;\n\n    vector<int> A(n); \n    vector<int> reduce(n + 5, 0);\n\n    int sum = 0;\n\n    for (int &i : A){\n        cin >> i;\n        sum += i;\n    }\n    rotate(A.begin(), next(min_element(A.begin(), A.end())), A.end());\n    \n    for (int i = n - 1, lst = -1; i >= 0; i--){\n        if (A[i] == 1)\n            lst = i;\n        if (A[i] == 2 and lst != -1){\n            // At time lst - i the 2 will get reduced to a 1\n            reduce[lst - i]++;\n        }\n    }\n    \n    for (int i = 1; i <= n; i++){\n        sum -= reduce[i];\n        cout<<sum<<\"\\n\";\n    }\n}\n\nSubtask 3: All $a_i$ are generated uniformly at random in the range\n$[1,10^9]$.\nLet's rotate the array such that the minimum element appears at the end.\nIn the previous subtask, for each $a_i=2$, we wanted to find when that specific\n$2$ units of milk will reach a bucket with capacity $1$. We can extend this\nreasoning. For some $a_i$, we want to find all times in which that milk will get\nreduced. \nThe first time the milk is reduced is when it reaches the first\n$a_{j_1}<a_i$ on the right of $i$. It will be reduced by $a_i-a_{j_1}$ at time\n$j_1-i$.The second time the milk is reduced is when it reaches the\nfirst $a_{j_2}<a_{j_1}$ on the right of $j_1$. It will be reduced by\n$a_{j_1}-a_{j_2}$ at time\n$j_2-i$.The third time the milk is reduced is when it reaches the first\n$a_{j_3}<a_{j_2}$ on the right of $j_2$. It will be reduced by $a_{j_2}-a_{j_3}$\nat time $j_3-i$....The $k$-th time the milk is reduced is when it reaches the first\n$a_{j_k}<a_{j_{k-1}}$ on the right of $j_{k-1}$. It will be reduced by\n$a_{j_{k-1}}-a_{j_k}$ at time $j_k-i$.\nTo find these values, we can iterate over the array backwards and keep a\nmonotonic stack. At each element, we can iterate over the entire stack and\nupdate our answer.\nBecause all $a_i$ are generated uniformly at random, the expected size of the\nmonotonic stack at each $i$ is $\\mathcal{O}(\\log N)$. This is since the\nprobability of  $j$ ($i \\le j < i+N$) being in the stack is at most\n$\\frac{1}{j-i+1}$ since $a_j$ must be smaller than $[a_i,a_{i+1},...,a_{j-1}]$.\nBy the linearity of expectation, the expected size of the stack is\n$\\frac{1}{1}+\\frac{1}{2}+ \\dots +\\frac{1}{N}=\\mathcal{O}(\\log N)$ by the\nharmonic series. Thus, the solution runs in $\\mathcal{O}(N\\log N)$ time.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0); \n    int n;\n    cin >> n;\n\n    vector<int> A(n); \n    ll sum = 0;\n\n    for (int &i : A){\n        cin >> i;\n        sum += i;\n    }\n    rotate(A.begin(), next(min_element(A.begin(), A.end())), A.end());\n\n    vector<int> stk;\n    vector<ll> reduce(n + 5, 0);\n\n    auto procStack = [&](int pos){\n        for (int i = 1; i < stk.size(); i++){\n            int delta = A[stk[i]] - A[stk[i - 1]];\n            reduce[stk[i - 1] - pos] += delta; \n        }\n    };\n\n    for (int i = n - 1; i >= 0; i--){\n        while (stk.size() and A[stk.back()] >= A[i]){\n            stk.pop_back();\n        }\n        stk.push_back(i);\n        procStack(i);\n    }\n\n    for (int i = 1; i <= n; i++){\n        sum -= reduce[i];\n        cout<<sum<<\"\\n\";\n    }\n}\n\nFull Solution 1:\nLet's look at what is redundant in our subtask $3$ solution. Suppose the bottom\n$2$ elements of the stack remain there for a long time. Then we will be\niterating over them each time we process the stack.\nLet's speed up our subtask $3$ solution. Consider some adjacent pair of elements\n($j_{p-1},j_p$) in the stack. We know that $d=a_{j_{p-1}}-a_{j_p}$ milk is lost\nby going from $j_{p-1}$ to $j_p$. Let's look at all $i$ ($1 \\le i \\le N$) where \n($j_{p-1},j_p$) is in the stack at $i$ (meaning the milk originating from $i$\nwill be reduced by $d$ at time $j_p-i$). Clearly, all such $i$ will form an\ninterval.\nWhen $i=j_{p-1}$, $d$ milk is lost at time $j_p-j_{p-1}$.When\n$i=j_{p-1}-1$, $d$ milk is lost at time $j_p-j_{p-1}+1$.When\n$i=j_{p-1}-2$, $d$ milk is lost at time $j_p-j_{p-1}+2$.And so on\nuntil we remove $j_{p-1}$ from the stack.\nWhen we remove an element from the top of the stack, we can get the interval it\nwas active for and perform a range add to keep track of how much milk is lost at\nwhat time. This leads to an $\\mathcal{O}(N)$ solution.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0); \n    int n;\n    cin >> n;\n\n    vector<int> A(n); \n    ll sum = 0;\n\n    for (int &i : A){\n        cin >> i;\n        sum += i;\n    }\n    rotate(A.begin(), next(min_element(A.begin(), A.end())), A.end());\n\n    vector<int> stk;\n    vector<ll> reduce(n + 5, 0);\n\n    for (int i = n - 1; i >= 0; i--){\n        while (stk.size() and A[stk.back()] >= A[i]){\n            if (stk.size() > 1){\n                // i < t1 < t2\n                int t1 = stk.back();\n                int t2 = stk[stk.size() - 2];\n\n                // Milk lost from going from t1 to t2\n                int delta = A[t1] - A[t2];\n                \n                // When does the pair begin applying delta\n                int st = t2 - t1;\n\n                // For how long does the pair apply delta\n                int sz = t1 - i;\n\n                reduce[st] += delta;\n                reduce[st + sz] -= delta;\n            }\n            stk.pop_back();\n        }\n        stk.push_back(i);\n    }\n\n    // Finish proccessing rest of stack\n    while (stk.size() > 1){\n        int t1 = stk.back();\n        int t2 = stk[stk.size() - 2];\n\n        int delta = A[t1] - A[t2];\n        int st = t2 - t1;\n        int sz = t1 + 1;\n\n        reduce[st] += delta;\n        reduce[st + sz] -= delta;\n\n        stk.pop_back();\n    }\n\n    // Get answer\n    for (int i = 1; i <= n; i++){\n        reduce[i] += reduce[i - 1];\n        sum -= reduce[i];\n\n        cout<<sum<<\"\\n\";\n    }\n}\n\nFull Solution 2:\nFor each $i$, we want to find the number of buckets with milk $a_i$ at each\nminute. To deal with the case where there are multiple same $a_i$, we only\nconsider the number of buckets equal to $a_i$ whose milk was specifically \nreduced (by a non-zero amount) to $a_i$ by the bucket at  $i$ (we also count the\nmilk starting at $i$).\nLet $l_i$ be the index of the first element less than or equal to $a_i$ on the\nleft of $i$. Consider all elements strictly between $l_i$ and $i$.\nAll these elements will be greater than $a_i$\nand thus will be reduced to $a_i$ when they reach $i$. Suppose there are $s$\nsuch elements including $a_i$. Then we will gain one additional element equal to $a_i$ at times\n$0,1,...,s-1$ (if we suppose we start off with $0$ elements equal to $a_i$). \nLet $w_i$ store the total amount of milk at time $i$. We should perform the\nfollowing update: \n$w_0 = w_0 + a_i$$w_1 = w_1 + 2a_i$...$w_{s-1} = w_{s-1} + sa_i$\n$w_{s} = w_{s} + sa_i$$w_{s+1} = w_{s+1} + sa_i$...$w_{N} = w_{N} + sa_i$\nWe also know that buckets with $a_i$ milk can be reduced to a smaller value.  \nLet $r_i$ be the index of the first element strictly less than $a_i$ on the\nright of $i$. Let time $t$ be the time for the milk originating at $i$ to reach\n$r_i$. Then we will lose one element equal to $a_i$ at times $t,t+1,...,t+s-1$.\nA similar update to the one above should be performed.\nWe can use a monotonic stack to find $l_i$ and $r_i$. Implementation can be made\neasier by prepending and appending the array to itself. We can use prefix sums\nof prefix sums to perform the updates on $w$ efficiently. See the following\nexample:\nOriginal: $[0,1,0,0,0,0,-1,0]$Prefix sum: $[0,1,1,1,1,1,0,0]$Prefix sum of prefix sum: $[0,1,2,3,4,5,5,5]$\nThus, this solution runs in $\\mathcal{O}(N)$ time.\n\n#include <bits/stdc++.h>\nusing namespace std; \n \n#define ll long long\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n;\n    cin >> n;\n\n    vector<int> A(n);\n\n    for (int &i : A)\n        cin >> i;\n    \n    for (int i = 0; i < 2 * n; i++)\n        A.push_back(A[i]);\n    \n    // L is first <= on left and R is first < on right\n    vector<int> L(A.size()), R(A.size());\n    {\n        stack<int> stk;\n        for (int i = 0; i < A.size(); i++){\n            while (stk.size() and A[i] < A[stk.top()])\n                stk.pop();\n\n            L[i] = stk.empty() ? -1 : stk.top();\n            stk.push(i);\n        }\n    }\n    {\n        stack<int> stk;\n        for (int i = (int)A.size() - 1; i >= 0; i--){\n            while (stk.size() and A[i] <= A[stk.top()])\n                stk.pop();\n            \n            R[i] = stk.empty() ? -1 : stk.top();\n            stk.push(i);\n        }\n    }\n\n    vector<ll> psm(n + 5, 0);\n\n    for (int i = n; i < 2 * n; i++){\n        // Gain A[i] during minutes [0, sz - 1]\n        int sz = i - L[i];\n        psm[0] += A[i];\n        psm[sz] -= A[i];\n\n        // Lose A[i] during minutes [R[i] - i, R[i] - i + sz - 1]\n        if (R[i] != -1){\n            psm[R[i] - i] -= A[i];\n            psm[R[i] - i + sz] += A[i];\n        }\n    }\n\n    for (int i = 1; i <= n; i++)\n        psm[i] += psm[i - 1];\n\n    for (int i = 1; i <= n; i++){\n        psm[i] += psm[i - 1];\n        cout<<psm[i]<<\"\\n\";\n    }\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1403_gold_quantum_moochanics": {"name": "Quantum Moochanics", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1403", "test_data_link": "http://www.usaco.org/current/data/prob3_gold_feb24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob3_gold_feb24.html", "contest_link": "http://www.usaco.org/index.php?page=feb24results", "inner_contest_link": null, "problem_level": "gold", "cp_id": "1403", "problem_id": "1403_gold_quantum_moochanics", "description": "\nIn her free time, Bessie likes to dabble in experimental physics. She has\nrecently discovered a pair of new subatomic particles, named mootrinos\nand antimootrinos. Like standard\n matter-antimatter pairs,\nmootrinos and antimootrinos annihilate each other and disappear when they meet.\nBut what makes these particles unique is that they switch their direction of\nmotion (while maintaining the same speed) whenever Bessie looks at them.\n\nFor her latest experiment, Bessie has placed an even number $N$\n($2 \\leq N \\leq 2 \\cdot 10^5$)\nof these particles in a line. The line starts with a mootrino on the left and\nthen alternates between the two types of particles, with the $i$-th particle\nlocated at position $p_i$ ($0 \\leq p_1 < \\cdots < p_N \\leq 10^{18}$). Mootrinos\ninitially move right while antimootrinos initially move left, and\nthe $i$-th particle moves with a constant speed of $s_i$ units per second\n($1 \\leq s_i \\leq 10^9$).\n\nBessie makes observations at the following times:\nFirst, $1$ second after the start of the experiment.Then $2$\nseconds after the first observation.Then $3$ seconds after the second\nobservation....Then $n + 1$ seconds after the $n$-th observation.\nDuring each observation, Bessie notes down which particles have disappeared.\n\nThis experiment may take an extremely long time to complete, so Bessie would\nlike to first simulate its results. Given the experiment setup, help Bessie\ndetermine when (i.e., the observation number) she will observe each\nparticle disappear! It may be shown that all particles will eventually\ndisappear.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nEach input contains $T$ ($1\\le T\\le 10$) independent test cases.\n\nEach test case consists of three lines. The first line contains $N$, the second\nline contains $p_1,\\dots,p_N$, and the third line contains $s_1\\dots,s_N$.\n\nIt is guaranteed that the sum of all $N$ does not exceed $2\\cdot 10^5$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor each test case, output the observation number for each particle's\ndisappearance, separated by spaces.\n\nSAMPLE INPUT:\n4\n2\n1 11\n1 1\n2\n1 12\n1 1\n2\n1 11\n4 6\n2\n1 11\n4 5\nSAMPLE OUTPUT: \n9 9\n11 11\n1 1\n3 3\n\nFor the first test, Bessie observes the following during the first $8$\nobservations:\nThe mootrino (initially moving right) appears at positions\n$2 \\rightarrow 0 \\rightarrow 3 \\rightarrow -1 \\rightarrow 4 \\rightarrow -2 \\rightarrow 5 \\rightarrow -3$.The antimootrino (initially moving left) appears at positions\n$10 \\rightarrow 12 \\rightarrow 9 \\rightarrow 13 \\rightarrow 8 \\rightarrow 14 \\rightarrow 7 \\rightarrow 15$.\nThen right at observation $9$, the two particles meet at position $6$ and\nannihilate each other.\n\nFor the second test, the antimootrino starts $1$ additional unit to the right,\nso the two particles meet at position $6.5$ half a second before observation\n$11$.\n\nNote that we only care about observation numbers, not times or positions.\n\nSAMPLE INPUT:\n2\n4\n1 3 5 8\n1 1 1 1\n4\n1 4 5 8\n1 1 1 1\nSAMPLE OUTPUT: \n1 1 3 3\n7 2 2 7\n\nFor the first test:\nThe two leftmost particles meet at position $2$ right at observation\n$1$.The two rightmost particles meet at position $6.5$ half a second\nbefore observation $3$.\nSCORING:\nInput 3 satisfies $N = 2$.Input 4 satisfies $N \\leq 2000$ and $p_i \\leq 10^4$ for all cows.Inputs 5-7 satisfy $N \\leq 2000$.Inputs 8-12 satisfy no additional constraints.\n\n\nProblem credits: Aryansh Shrivastava, Benjamin Qi\n", "num_tests": 12, "solution": "\n(Analysis by Andi Qu)\nAlthough the problem does not state what happens when two particles of the same\ntype meet, this event will never occur in Bessie's experiment setup. This is due\nto three reasons:\nParticles meet in pairs.And two particles cannot meet each other\nuntil all particles between them are gone.But particles of the same\ntype start with an odd number of particles between them.\nSo meetings will only ever occur between mootrinos and antimootrinos.\nSubtask 1: $O(1)$ for a single pair of particles\nThe two particles meet only when they are moving toward each other. Because the\nparticles start off moving toward each other, Bessie must observe their\ndisappearance on an odd observation.\nOn the $k$-th odd observation, the mootrino will be $k \\cdot s_1$ units to the\nright of its initial position. Likewise, the antimootrino will be $k \\cdot s_2$\nunits to the left of its initial position. Therefore, Bessie will observe their\ndisappearance on the $\\left\\lceil\\frac{p_2 - p_1}{s_1 + s_2}\\right\\rceil$-th odd\nobservation.\nWe can generalize this solution somewhat by considering what happens if the\nleftmost particle is an antimootrino instead. In this case, Bessie will observe\nthe particles' disappearance on the\n$\\left\\lceil\\frac{p_2 - p_1}{s_1 + s_2}\\right\\rceil$-th\neven observation.\nPutting it together, we get the following function:\n\nlong long compute_meeting_time(int a, int b) {\n    long long dist = p[b] - p[a];\n    long long speed_sum = s[a] + s[b];\n    return 2 * ((dist + speed_sum - 1) / speed_sum) - (a % 2 == 0);\n}\n\nwhich we will use in the subsequent subtasks.\nSubtask 2: $O(N \\cdot \\max\\{p_i\\})$\nSimulating the movement of the particles is sufficient for this subtask.\nSubtask 3: $O(N^2)$\nThe problem with brute-force simulation is that there may be long stretches of\nobservations where nothing happens. (For example, if the particles are all\nspaced very far apart but all have very low speeds.)\nA more efficient algorithm works as follows:\nIterate through all pairs of adjacent particles and compute when they meet\nusing the function from Subtask 1.Choose the pair that meets earliest,\nbreaking ties arbitrarily.Store the answer for that pair and remove\nthem from the line of particles.Repeat until all particles have been\nremoved.\nThis algorithm runs in $O(N^2)$ because we repeat the steps $\\frac{N}{2}$ times,\nand each step takes $O(N)$ time to execute.\nFull credit: $O(N \\log N)$\nWe can improve this algorithm further by noticing that the list of particle\npairs to consider only changes by at most $4$ pairs each iteration. Suppose\nparticles $o_1$, $o_2$, $o_3$, and $o_4$ are next to each other (in that order).\nWhen we remove the pair $(o_2, o_3)$ from the line:\nWe no longer need to consider the three pairs $(o_1, o_2)$, $(o_2, o_3)$,\nand $(o_3, o_4)$.But we now need to consider the pair\n$(o_1, o_4)$.\nWith this in mind, we can use a priority queue to store the list of\nadjacent pairs, sorted by meeting time.\nWe can also use a linked list to help determine which new pairs to add\nto the priority queue. For each still-existing particle, this linked list would\nstore the indices of the still-existing particle(s) directly adjacent to it.\nThese improvements bring the time complexity down to $O(N \\log N)$ because each\nstep now modifies the priority queue $O(1)$ times, and each modification takes\n$O(\\log N)$ time.\nC++ code implementing this solution:\n\n#include <iostream>\n#include <queue>\n#include <utility>\ntypedef long long ll;\nusing namespace std;\n \nll p[200000], s[200000], ans[200000];\npair<int, int> adj[200000];\n \nll compute_meeting_time(int a, int b) {\n    ll dist = p[b] - p[a], speed_sum = s[a] + s[b];\n    return 2 * ((dist + speed_sum - 1) / speed_sum) - (a % 2 == 0);\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        for (int i = 0; i < n; i++)\n            cin >> p[i];\n        for (int i = 0; i < n; i++)\n            cin >> s[i];\n \n        for (int i = 0; i < n; i++) {\n            adj[i] = {i - 1, i + 1};\n            ans[i] = 0;\n        }\n        priority_queue<pair<ll, pair<int, int>>> pq;\n        for (int i = 1; i < n; i++)\n            pq.push({-compute_meeting_time(i - 1, i), {i - 1, i}});\n \n        while (pq.size()) {\n            pair<ll, pair<int, int>> next_meeting = pq.top();\n            pq.pop();\n            ll meeting_time = next_meeting.first;\n            pair<int, int> cows = next_meeting.second;\n            if (ans[cows.first] || ans[cows.second])\n                continue;\n            ans[cows.first] = ans[cows.second] = -meeting_time;\n            if (cows.first != 0 && cows.second != n - 1) {\n                int prv = adj[cows.first].first, nxt = adj[cows.second].second;\n                adj[prv].second = nxt;\n                adj[nxt].first = prv;\n                pq.push({-compute_meeting_time(prv, nxt), {prv, nxt}});\n            }\n        }\n \n        for (int i = 0; i < n; i++)\n            cout << ans[i] << \" \\n\"[i == n - 1];\n    }\n    return 0;\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1398_silver_target_practice_ii": {"name": "Target Practice II", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1398", "test_data_link": "http://www.usaco.org/current/data/prob1_silver_feb24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob1_silver_feb24.html", "contest_link": "http://www.usaco.org/index.php?page=feb24results", "inner_contest_link": null, "problem_level": "silver", "cp_id": "1398", "problem_id": "1398_silver_target_practice_ii", "description": "\nNote: The time limit for this problem is 2.5s, 1.25 times the default.\nNote: The large size of integers involved in this problem may require the use\nof 64-bit integer data types (e.g., a \"long long\" in C/C++).\nThe Paris Moolympics are coming up and Farmer John is training his team of cows\nin archery! He has set up the following exercise on the 2D coordinate plane.\n\nThere are $N (1 \\leq N \\leq 4 \\cdot 10^4)$ axis-aligned rectangular targets and\n$4N$ cows. Every cow must be assigned to a different target vertex. At moment\n$i$, for\n$1 \\leq i \\leq N$:\n Target $i$ appears. The $4$ cows assigned to its vertices shoot\nat them. If a cow's shot passes through the interior of the target\nbefore it hits the assigned vertex or misses, the cows fail the\nexercise. The target disappears to make space for the next one.\nEach cow is located on the $y$-axis $(x = 0)$, and each target is a rectangle\nwhere target $i$ has its lower left coordinate at $(X_1, y_1^{(i)})$ and its\nupper right coordinate at $(x_2^{(i)}, y_2^{(i)})$. The coordinates also satisfy\n$1 \\leq X_1 < x_2^{(i)}\\leq 10^9$ and $1 \\leq y_1^{(i)} <  y_2^{(i)} \\leq 10^9$\n(Note: $X_1$ is the same for every target).\n\nIn addition, each cow has a \"focus\" angle they are working on. Therefore, they\nwill turn at a specific angle when shooting. Given that their shot travels in a\nstraight line from their position towards their assigned vertex, the trajectory\nof cow $i$'s arrow can be described by $s_i$ $(0 < |s_i| < 10^9)$, the slope of\nthe trajectory.\n\nSo that he can carefully examine the cows' technique, Farmer John wants to\nminimize the distance between the furthest cows. If Farmer John were to\noptimally assign each cow to a target vertex and place them on the $y$-axis, can\nyou help him determine what the minimum distance between the furthest cows would\nbe or if the cows will always fail the exercise?\n\nEach input contains $T$ ($1 \\leq T \\leq 10$) independent test cases. The sum of\n$N$ across all test cases is guaranteed to not exceed $4\\cdot 10^4$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $T$ ($1 \\leq T \\leq 10$), the number of independent test\ncases. Each test case is described as follows:\n\nThe first line of each test case contains two integers, $N$ and $X_1$, the\nnumber of targets and the left-most $x$-coordinate of the targets respectively.\n\nThis is followed by $N$ lines with the $i$-th line consisting of three integers,\n$y_1^{(i)}$, $y_2^{(i)}$, and $x_2^{(i)}$, the lower $y$-coordinate, the upper\n$y$-coordinate, and the right $x$-coordinate of the $i$-th target respectively.\n\nThe last line consists of $4N$ integers, $s_1, s_2, \\dots, s_{4N}$ where $s_i$\ndenotes the slope of cow $i$'s shot trajectory.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe minimum possible distance between the furthest cows or $-1$ if the cows will\nalways fail the exercise.\n\nSAMPLE INPUT:\n3\n2 1\n1 3 6\n4 6 3\n1 -1 2 -2 3 -3 4 -4\n2 1\n1 3 6\n4 6 3\n1 1 2 2 3 3 4 4\n2 1\n1 3 3\n4 6 3\n1 -1 2 -2 3 -3 4 -4\nSAMPLE OUTPUT: \n17\n-1\n11\n\nOne optimal assignment for test case 1 is the following target vertices for cows\n1-8 respectively:\n$$(6, 1), (6,3), (3,4), (3,6), (1,4), (1,3), (1,6), (1,1)$$\nThis gives the following $y$ locations for cows 1-8 respectively:\n$$-5, 9, -2, 12, 1, 6, 2, 5$$\nThis gives a minimum distance of $12-(-5) = 17$.\n\nOne reason the second test case is impossible is because it is impossible to\nshoot the vertex at $(6, 3)$ (the top right vertex of target 1) without the shot\npassing through the interior of target 1.\n\nSCORING:\nInput 2: $|S_i|$ is the same for all $1 \\leq i \\leq 4N$.Input 3-9:\nThe sum of $N$ across all testcases is at most $1000$.Inputs 10-15: No\nadditional constraints.\n\nProblem credits: Suhas Nagar\n", "num_tests": 15, "solution": "\n(Analysis by Anand John)\nSubtask 1:\nThe first observation we can make is that the upper right vertex of any target \ncan only be shot by an arrow with a negative slope, and the lower right vertex\ncan only be shot by an arrow with a positive slope. Otherwise, the arrow would\ngo through the target. Therefore, there needs to be at  least $N$ arrows of both\npositive and negative slopes. We can see that there are no such  restrictions\nfor the vertices on the left side of the target. Thus, the cows will  always\nfail if and only if there are less than $N$ positive or negative slopes.\nFor this subtask, since the magnitude of all the slopes are the same, it doesn't\nmatter whether a vertex on the left side of the target is shot by an arrow with\nnegative or positive slope since the $y$-intercepts of the trajectories are\nwithin the $y$-intercepts of the trajectories of the arrows that shoot the\nvertices on the right side of the target. Therefore, we can now just calculate\nwhat the distance is between the furthest cows in this scenario based on\nassigning the positive and negative slopes as we described above. This runs in\n$O(N)$.\nBrandon Wang's Python Implementation:\n\nT = int(input())\n \nfor _ in range(T):\n    N, X = (int(x) for x in input().split())\n    y1s = []\n    y2s = []\n    x2s = []\n    for _ in range(N):\n        y1, y2, x2 = (int(x) for x in input().split())\n        y1s.append(y1)\n        y2s.append(y2)\n        x2s.append(x2)\n    S = [int(x) for x in input().split()]\n    nn = sum([x < 0 for x in S])\n    s = abs(S[0])\n    if nn < N or nn > 3*N:\n        print(-1)\n        continue\n    print(max([y2+x2*s for x2, y2 in zip(x2s, y2s)]) - min([y1-x2*s for x2, y1 in zip(x2s, y1s)]))\n\nSubtask 2:\nNow, let's look at the vertices on the left side of each\ntarget. Let's say we have two vertices with the same $x$-coordinate, and the\nlower one (lower $y$-coordinate) is targeted by an arrow with a positive slope,\nand the upper one is targeted by an arrow with a negative slope. In this case,\nwe can see that the cow who shoots the arrow with the positive slope is below\n(lower $y$-coordinate) the cow with the negative slope. Now if we swap the\nvertices the cows are shooting at, we find that the cow with the negative slope\nrelocates farther down the y-axis and the cow with the positive slope will\nrelocate farther up the y-axis. This makes the cows closer together. Since our\ngoal is to have all the cows as close together as possible, this means that if\nwe have two vertices in such a situation, it's always beneficial to swap the\ncows' target vertices if we can since it may decrease the distance between the\nfurthest cows. Since the leftmost vertices of each target share the same\n$x$-value, we can assign the leftmost vertices with the lowest overall\n$y$-values negative slopes and the rest positive slopes.\nSummarizing, the slope we should have on each vertex of a target is:\n Upper Right: negative  Lower Right: positive  Leftmost\nvertices: Sort these from smallest to largest based on $y$-value, and assign the\nlowest points negative slopes and the rest positive slopes \nWe now know for each vertex whether it will be targeted by a positive slope or\nby a negative slope. Now, let's think of each cow as the $y$-intercept of a line\nand each trajectory that an arrow follows as a line. We can see that our goal is\nto minimize the maximum $y$-intercept of a line with a negative slope and\nmaximize the minimum $y$-intercept of a line with a positive slope as this\nminimizes the range of cow positions. So, let's split this problem into a\nnegative slope case and a positive slope case. Note that these two cases are\nsymmetric, so we can deal with them in the same way. For the rest of the\neditorial, we will describe only the solution to the positive slope case.\nWe can notice that for any given point, the smaller the slope of the line that\ntargets it, the higher the corresponding $y$-intercept of the line. This means\nthat if we have two points and the $y$-intercept of the line with larger slope\nwould be higher if it targeted the other point, it would always be better to\nswitch which points the slopes are targeting so that it targets that point. This\nmotivates the following greedy solution: Go through the positive slopes from\ngreatest to least. For each slope, target the point that results in the highest\ncorresponding $y$-intercept out of all the points that have not been targeted so\nfar. This runs in $O(N^2)$ and passes the subtask.\nBen Qi's Python Implementation:\n\ndef solve_min(needs_pos, pos): # positive slope case\n    pos.sort(reverse=True)\n    ans = float('inf')\n    for s in pos:\n        best_y = (-float('inf'), -1)\n        for i, (x, y) in enumerate(needs_pos):\n            best_y = max(best_y, (y - x * s, i))\n        ans = min(ans, best_y[0])\n        # Remove chosen point from further consideration\n        needs_pos = needs_pos[:best_y[1]] + needs_pos[best_y[1]+1:]\n    return ans\n \ndef solve_max(needs_neg, neg): # negative slope case\n    return -solve_min([(x, -y) for x, y in needs_neg], [-s for s in neg])\n \ndef solve():\n    N, x1 = map(int, input().split())\n    with_x1 = []\n    needs_pos = []\n    needs_neg = []\n    for _ in range(N):\n        y1, y2, x2 = map(int, input().split())\n        with_x1.append(y1)\n        with_x1.append(y2)\n        needs_pos.append((x2, y1))\n        needs_neg.append((x2, y2))\n    slopes = list(map(int, input().split()))\n    assert len(slopes) == 4*N\n    neg, pos = [], []\n    for s in slopes:\n        if s < 0:\n            neg.append(s)\n        else:\n            pos.append(s)\n    if len(neg) < N or len(pos) < N:\n        print(-1)\n        return\n    with_x1.sort()\n    for y in with_x1: # split leftmost vertices into negative and positive slopes\n        if len(needs_neg) < len(neg):\n            needs_neg.append((x1, y))\n        else:\n            needs_pos.append((x1, y))\n    assert len(needs_neg) == len(neg)\n    assert len(needs_pos) == len(pos)\n    # solve for upper and lower bounds of range\n    y_min = solve_min(needs_pos, pos)\n    y_max = solve_max(needs_neg, neg)\n    print(y_max - y_min)\n \nT = int(input())\nfor _ in range(T): solve()\n\nSubtask 3:\nThe key observation is that we can binary search on the space of $y$-intercepts\nto find the maximum minimum $y$-intercept. We can see that the maximum possible\n$y$-intercept is $\\max{y}$ and the minimum possible $y$-intercept is\n$-\\max{x}\\cdot \\max{s_i}$. By the constraints of the problem, this is an integer\nbounded between $10^9$ and $-10^{18}$ so it's possible to binary search over to\nfind our value for a maximum minimum $y$-intercept. To check if a given minimum\n$y$-intercept is possible, we start by finding, for each vertex, the maximum\npossible slope of a line that can target it without its intersection with the\ny-axis going below the minimum $y$-intercept. For a single vertex, this can be\ndone in $O(1)$ by rearranging the equation of the line: $y = mx+b$. Once we find\nthis, we then sort these slopes from greatest to least and denote the $i$-th\nlargest as $m_i$. Then, a given minimum $y$-intercept is only feasible if\n$m_i \\geq p_i$ for all $i$ where $p_i$ is the $i$-th largest positive slope.\nOtherwise, we would have to target a vertex with a slope that would result in a\n$y$-intercept less than our current assumption.\nIn total, this algorithm runs in\n$O(N\\log{N}\\log{(\\max{|Y|}+ \\max{x} \\cdot \\max{|s_i|})})$.  The $N\\log{N}$ comes\nfrom the sorting needed to check the feasibility of a value in  the binary\nsearch and the second term comes from the bound on the possible minimum\n$y$-intercepts  for the binary search.\nBen Qi's Python Implementation:\n\ndef solve_min(needs_pos, pos): #positive slope case\n    pos.sort()\n \n    def ok(min_y):\n        max_slope = []\n        for x, y in needs_pos:\n            max_slope.append((y - min_y) // x) # calculate what the max slope can be for each vertex\n        max_slope.sort()\n        return all(a <= b for a, b in zip(pos, max_slope)) # check if these slopes are possible\n \n    min_y = min(y for x, y in needs_pos)\n    hi = min_y\n    lo = min_y - pos[-1] * max(x for x, y in needs_pos)\n    assert ok(lo)\n    while lo < hi: # binary search over minimum y-intercept\n        mid = (lo + hi + 1) // 2\n        if ok(mid):\n            lo = mid\n        else:\n            hi = mid - 1\n    return lo\n \ndef solve_max(needs_neg, neg): # negative slope case\n    return -solve_min([(x, -y) for x, y in needs_neg], [-s for s in neg]) # convert this to a positive slope case\n \ndef solve():\n    N, x1 = map(int, input().split())\n    with_x1 = []\n    needs_pos = []\n    needs_neg = []\n    for _ in range(N):\n        y1, y2, x2 = map(int, input().split())\n        with_x1.append(y1)\n        with_x1.append(y2)\n        needs_pos.append((x2, y1))\n        needs_neg.append((x2, y2))\n    slopes = list(map(int, input().split()))\n    assert len(slopes) == 4*N\n    neg, pos = [], []\n    for s in slopes:\n        if s < 0:\n            neg.append(s)\n        else:\n            pos.append(s)\n    if len(neg) < N or len(pos) < N:\n        print(-1)\n        return\n    with_x1.sort()\n    for y in with_x1: # split leftmost vertices into negative and positive slopes\n        if len(needs_neg) < len(neg):\n            needs_neg.append((x1, y))\n        else:\n            needs_pos.append((x1, y))\n    assert len(needs_neg) == len(neg)\n    assert len(needs_pos) == len(pos)\n    # solve for upper and lower bounds of range\n    y_min = solve_min(needs_pos, pos)\n    y_max = solve_max(needs_neg, neg)\n    print(y_max - y_min)\n \nT = int(input())\nfor _ in range(T): solve()\n\n", "runtime_limit_sentences": ["\nNote: The time limit for this problem is 2."], "memory_limit_sentences": [], "memory_limit": 256, "runtime_limit": 2}, "1399_silver_test_tubes": {"name": "Test Tubes", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1399", "test_data_link": "http://www.usaco.org/current/data/prob2_silver_feb24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob2_silver_feb24.html", "contest_link": "http://www.usaco.org/index.php?page=feb24results", "inner_contest_link": null, "problem_level": "silver", "cp_id": "1399", "problem_id": "1399_silver_test_tubes", "description": "\nBessie has recently gotten into chemistry. At the moment, she has two different\ncolors $1$ and $2$ of various liquids that don't mix well with one another. She\nhas two test tubes of infinite capacity filled with $N$ $(1 \\leq N \\leq 10^5)$\nunits each of some mixture of liquids of these two colors. Because the liquids\ndon\u00e2\u20ac\u2122t mix,  once they settled, they divided into layers of separate colors.\nBecause of this, the two tubes can be viewed as strings $f_1f_2\\ldots f_N$ and\n$s_1s_2\\ldots s_N$  where $f_i$ represents the color of the liquid that is $i$\nunits from the bottom of the first tube, and $s_i$ represents the color of the\nliquid that is $i$ units from the bottom of the second tube. It is guaranteed\nthat there is at least one unit of each color of liquid.\n\nBessie wants to separate these liquids so that each test tube contains all units\nof one color of liquid. She has a third empty beaker of infinite capacity to\nhelp her in this task. When Bessie makes a \"pour\", she moves all liquid of color\n$i$ at the top of one test tube or beaker into another.\n\nDetermine the minimum number of pours to separate all the liquid into the two\ntest tubes, and the series of moves needed to do so. It does not matter which\ntest tube ends up with which color, but the beaker must be empty..\n\nThere will be $T$ ($1 \\leq T \\leq 10$) test cases, with a parameter $P$ for each\ntest case.\n\nSuppose the minimum number of pours to separate the liquids into the original\ntubes is $M$.\n\nIf $P=1$, you will receive credit if you print only $M$.If $P=2$, you will receive credit if you print an integer $A$ such that\n$M \\leq A \\leq M+5$, followed by $A$ lines that construct a solution with that\nnumber of moves. Each line should contain the source and the destination tube\n($1$, $2$, or $3$ for the beaker). The source tube must be nonempty before the\nmove and a tube may not be poured into itself.If $P=3$, you will receive credit if you print $M$, followed by a valid\nconstruction using that number of moves.\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $T$, the. number of test cases. For each test case, the\nnext line contains $N$ and $P$ representing the amount each test tube is\ninitially filled to, and the query type. The following line contains\n$f_1f_2f_3\\ldots f_N$ representing  the first test tube. $f_i \\in \\{ 1,2 \\}$ and\n$f_1$ represents the bottom of the test tube. The subsequent line contains\n$s_1s_2s_3\\ldots s_N$ representing the second test tube. $s_i \\in \\{ 1,2 \\}$ and\n$s_1$ represents the bottom of the test tube.\n\nIt is guaranteed that there will be at least one $1$ and one $2$ across both\ninput strings.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor each test case, you will print a single number representing the minimum\npours to separate the liquid in the test tubes. Depending on the query type, you\nmay also need to provide a valid construction.\n\nSAMPLE INPUT:\n6\n4 1\n1221\n2211\n4 2\n1221\n2211\n4 3\n1221\n2211\n6 3\n222222\n111112\n4 3\n1121\n1222\n4 2\n1121\n1222\nSAMPLE OUTPUT: \n4\n4\n1 2\n1 3\n2 1\n3 2\n4\n1 2\n1 3\n2 1\n3 2\n1\n2 1\n5\n2 3\n1 2\n1 3\n1 2\n3 1\n6\n2 3\n1 2\n1 3\n1 2\n2 1\n3 2\n\nIn the first three test cases, the minimum number of pours to separate the tubes\nis $4$. We can see how the following moves separate the test tubes:\n\nInitial state:\n\n1: 1221\n2: 2211\n3: \n\nAfter the move \"1 2\":\n\n1: 122\n2: 22111\n3: \n\nAfter the move \"1 3\":\n\n1: 1\n2: 22111\n3: 22\n\nAfter the move \"2 1\":\n\n1: 1111\n2: 22\n3: 22\n\nAfter the move \"3 2\":\n\n1: 1111\n2: 2222\n3:\n\nIn the last test case, the minimum amount of pours is $5$. However, since $P=2$,\nthe given construction with $6$ moves is valid since it is within $5$ pours from\nthe optimal answer.\nSCORING:\nInputs 2-6: $P = 1$Inputs 7-11: $P=2$Inputs 12-21: No additional constraints.\nAdditionally, it is guaranteed that $T=10$ for all inputs besides the sample.\n\n\nProblem credits: Suhas Nagar\n", "num_tests": 21, "solution": "\n(Analysis by Benjamin Qi)\nSubtask 1: $P=1$\nLet's start by computing the following quantity $Q$: the minimum number of moves\nto move all of liquid $1$ to tube $1$ and all of liquid $2$ to tube $2$. Once we\nknow how to compute this quantity, we can compute $Q'$, the minimum number of\nmoves to move all of liquid $1$ to tube $2$ and all of liquid $2$ to tube $1$,\nin a similar way. The answer for this subtask will then be $\\min(Q,Q')$.\nThe current state of liquid in the tubes and beakers can be represented by three\nbinary strings $f$, $s$, and $b$, with $f$ and $s$ defined the same way as the\nproblem statement, and $b$ denoting the state of the beaker from bottom to top.\nFirst, observe that $Q$ does not change if we make the following\nsimplifications:\nCompress runs of equal characters in all three strings. For example, 1221\nbecomes 121 and 2211 becomes 21.Remove the first character of $f$ if it is $1$, since this liquid never\nneeds to leave tube $1$Similarly, remove the first character of $s$ if it is $2$.\nNext, observe that $Q$ must be at least the number of characters after\nsimplifying, because after performing any move and simplifying again, the number\nof characters will have stayed the same or gone down by one. The final state\ncorresponds to all of $f$, $s$, and $b$ simplifying to empty strings.\nIs $Q$ exactly equal to the number of characters after simplifying? It is when\nwe don't need to utilize the beaker. For example, consider the following input:\n\nf = \"111112\"\ns = \"222222\"\n\nAfter simplifying,\n\nf = \"2\"\ns = \"\"\n\nSo the number of characters after simplifying is one, and $Q=1$ because we only\nneed one pour to separate the liquid (tube 1 into tube 2). However, when the\nnumber of characters after simplifying is greater than one, we need to utilize\nthe beaker, and when we first pour liquid into the beaker the number of\ncharacters after simplifying does not change. In such cases, $Q$ is at least the\nnumber of characters after simplifying plus one. For example, the first test\ncase of the sample input after simplifying becomes:\n\nf = \"21\"\ns = \"1\"\n\nThere are three characters after simplifying, and $Q=4$.\nIs it true that $Q$ is always at most the number of characters after simplifying\nplus one? Assuming this allows you to solve the first subtask.   At this point,\nit's not obvious why this assumption is correct, but we will prove that it works\nlater by providing a construction using exactly this number of moves.\nImplementation (which computes $\\min(Q,Q')$ directly rather than $Q$ and $Q'$ separately):\n\ndef to_reduced_list(s):\n    \"\"\"Compress runs of equal chars in a string s\n    >>> to_reduced_list('2211')\n    ['2', '1']\n    \"\"\"\n    l = []\n    for c in s:\n        if len(l) > 0 and l[-1] == c:\n            continue\n        l.append(c)\n    return l\n\n\ndef solve():\n    N, P = map(int, input().split())\n    assert P == 1\n    tubes = [to_reduced_list(input()) for _ in range(2)]\n    tubes.append([])\n    ans = len(tubes[0]) + len(tubes[1]) - 2\n    # ^ num chars after simplifying, if tubes[0] and tubes[1] start with different chars and we choose the better of Q and Q'\n    if tubes[0][0] == tubes[1][0]:\n        ans += 1\n    if ans > 1:  # require extra pour into beaker\n        ans += 1\n    print(ans)\n\n\nT = int(input())\nfor _ in range(T):\n    solve()\n\nSubtask 2: $P=2$\nHere we provide a construction that moves all of liquid $i$ into tube $i$ and \nachieves a number of moves at most the number of characters after compressing\nruns plus two. From the previous subtask, we know that the answer must be at\nleast the number of characters after compressing runs minus two. Therefore, our\nsolution is at most four away from optimal.\nWhile tube $2$ is nonempty, pour it into tube $1$ if tube $2$ has liquid $2$\non top, or to the beaker otherwise.While tube $1$ is nonempty, pour it into tube $2$ if tube $1$ has liquid $2$\non top, or to the beaker otherwise.Now, tube $2$ contains all of liquid $2$ and the beaker contains all of\nliquid $1$. The final step is to pour from the beaker into tube\n$1$.\nImplementation of the strategy described above (using 0- instead of 1-indexing):\n\ndef to_reduced_list(s):\n    \"\"\"Compress runs of equal chars in a string s\n    >>> to_reduced_list('2211')\n    ['2', '1']\n    \"\"\"\n    l = []\n    for c in s:\n        if len(l) > 0 and l[-1] == c:\n            continue\n        l.append(c)\n    return l\n\n\ndef solve():\n    N, P = map(int, input().split())\n    assert P == 2\n    tubes = [to_reduced_list(input()) for _ in range(2)]\n    tubes.append([])\n\n    moves = []\n\n    def move(src, dst):\n        moves.append((src, dst))\n        if len(tubes[dst]) == 0 or tubes[dst][-1] != tubes[src][-1]:\n            tubes[dst].append(tubes[src][-1])\n        tubes[src].pop()\n\n    while len(tubes[1]) > 0:\n        if tubes[1][-1] == \"2\":\n            move(1, 0)\n        else:\n            move(1, 2)\n    while len(tubes[0]) > 0:\n        if tubes[0][-1] == \"2\":\n            move(0, 1)\n        else:\n            move(0, 2)\n    move(2, 0)\n\n    print(len(moves))\n    for a, b in moves:\n        print(1 + a, 1 + b)\n\n\nT = int(input())\nfor _ in range(T):\n    solve()\n\nSubtask 3: $P=3$\nOur construction achieving the optimal number of moves is similar to the one for\nthe previous subtask in the sense that we first empty out most of one tube, then\nmost of the other, and finally the beaker.\nBefore describing the strategy we use the following trick to ensure that we\nnever need to deal with a tube being empty, which makes the implementation\nsimpler. Suppose we choose to move all of liquid $1$ to tube $1$ and liquid $2$ \nto tube $2$; then let's insert an extra $1$ in front of $f$ and an extra $2$ in\nfront of $s$ before compressing runs (or the other way around if we choose to\nmove liquid $1$ to tube $2$ and liquid $2$ to tube $1$).\nOur strategy is as follows. We assume that before every move we perform step $1$\nonly of the simplification process described in subtask 1 (compressing runs of\nequal characters).\nIf the last characters of $f$ and $s$ are equal, choose any tube with a\nstring of length greater than one and pour it into the other tube.If both $f$ and $s$ now have length one, we're done. Otherwise, we're in a\ncase where the beaker must be used. Choose any tube with a string of length\ngreater than one and pour it into the beaker. The last characters of both tube\nstrings are now equal.Suppose the beaker now contains liquid $i$. Choose the tube whose string has\nfirst character not equal to $i$, and repeatedly pour from it until its\nstring has length equal to one. We should pour it into either the beaker or the\nother tube depending on which pour reduces the number of characters after\ncompressing by one.Next, pour from the other tube until its string has length one.Finally, pour from the beaker into one of the tubes.\nExample:\n\nInitial:\nf = 12121\ns = 2121\n\nAfter step 1:\nf = 1212\ns = 2121\n\nAfter step 2:\nf = 1212\ns = 212\nb = 1\n\nAfter step 3:\nf = 1212\ns = 2\nb = 1\n\nAfter step 4:\nf = 1\ns = 2\nb = 1\n\nAfter step 5:\nf = 1\ns = 2\n\nEvery move besides the first move into the beaker reduces the number of\ncharacters after compressing by one, so this construction matches the lower\nbound we described in subtask 1.\nImplementation:\n\ndef to_reduced_list(s):\n    \"\"\"Compress runs of equal chars in a string s, and converts to int\n    >>> to_reduced_list('2211')\n    [2, 1]\n    \"\"\"\n    l = []\n    for c in s:\n        c = int(c)\n        if len(l) > 0 and l[-1] == c:\n            continue\n        l.append(c)\n    return l\n\n\ndef solve():\n    N, P = map(int, input().split())\n    tubes = [to_reduced_list(input()) for _ in range(2)]\n    tubes.append([])\n    if tubes[0][0] == tubes[1][0]:  # ensure f and s start with different chars\n        tubes[0].insert(0, tubes[0][0] ^ 3)\n\n    ans = len(tubes[0]) + len(tubes[1]) - 2\n    if ans > 1:\n        ans += 1\n\n    print(ans)\n    if P == 1:\n        return\n\n    moves = []\n\n    def move(src, dst):\n        moves.append((src, dst))\n        if len(tubes[dst]) == 0 or tubes[dst][-1] != tubes[src][-1]:\n            tubes[dst].append(tubes[src][-1])\n        tubes[src].pop()\n\n    if tubes[0][-1] == tubes[1][-1]:  # step 1: if equal last chars\n        if len(tubes[0]) > len(tubes[1]):\n            move(0, 1)\n        else:\n            move(1, 0)\n\n    for i in range(2):\n        if len(tubes[i]) > 1:\n            move(i, 2)  # step 2: move from any tube with string length > 1 to beaker\n            idx_to_empty = 0  # step 3: choose a tube to (almost) empty first\n            if tubes[idx_to_empty][0] == tubes[2][0]:\n                idx_to_empty ^= 1\n            while len(tubes[idx_to_empty]) > 1:\n                if tubes[idx_to_empty][-1] == tubes[2][0]:\n                    move(idx_to_empty, 2)\n                else:\n                    move(idx_to_empty, idx_to_empty ^ 1)\n            idx_to_empty ^= 1  # step 4: next, (almost) empty the other tube\n            while len(tubes[idx_to_empty]) > 1:\n                if tubes[idx_to_empty][-1] == tubes[2][0]:\n                    move(idx_to_empty, 2)\n                else:\n                    move(idx_to_empty, idx_to_empty ^ 1)\n            move(2, idx_to_empty)  # step 5: finish\n            break\n\n    assert len(moves) == ans\n    for a, b in moves:\n        print(1 + a, 1 + b)\n\n\nT = int(input())\nfor _ in range(T):\n    solve()\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1400_silver_moorbles": {"name": "Moorbles", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1400", "test_data_link": "http://www.usaco.org/current/data/prob3_silver_feb24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob3_silver_feb24.html", "contest_link": "http://www.usaco.org/index.php?page=feb24results", "inner_contest_link": null, "problem_level": "silver", "cp_id": "1400", "problem_id": "1400_silver_moorbles", "description": "\nBessie and Elsie are playing a game of Moorbles. The game works as follows:\nBessie and Elsie each start out with some amount of marbles. Bessie holds out\n$A$ of her marbles in her hoof and Elsie guesses if $A$ is Even or Odd. If Elsie\nis correct, she wins the $A$ marbles from Bessie and if she guesses incorrectly,\nshe loses $A$ of her marbles to Bessie (if Elsie has less than $A$ marbles, she\nloses all her marbles). A player loses when they lose all of their marbles.\n\nAfter some amount of turns in the game, Elsie has $N$ $(1 \\leq N \\leq 10^9)$\nmarbles. She thinks it is hard to win, but she is playing to not lose. After\nbeing around Bessie enough, Elsie has a good read on Bessie's habits and\nrecognizes that on turn $i$, there are only $K$ $(1 \\leq K \\leq 4)$ different\namounts of marbles that Bessie may put out. There are only $M$\n$(1 \\leq M \\leq 3 \\cdot 10^5)$ turns before Bessie gets bored and stops playing.\nCan you identify a lexicographically minimum turn sequence such that Elsie will\nnot lose, regardless of how Bessie plays?\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains a single integer $T$ ($1 \\leq T \\leq 10$) representing\nthe number of test cases. Each test case is described as follows:\n First, one line containing three integers $N$, $M$, and $K$, representing\nthe number of marbles Elsie has, the number of turns, and the number of\npotential moves Bessie can make respectively.Then, $M$ lines where\nline $i$ contains $K$ distinct space separated integers\n$a_{i,1} \\; a_{i,2} \\ldots a_{i,K}$ ($1 \\leq a_{i, j} \\leq 10^3$) representing\nthe possible amounts of marbles that Bessie might play on turn $i$.\nIt is guaranteed that the sum of $M$ over all test cases is at most\n$3 \\cdot 10^5$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor each test case, output the lexicographically minimum move sequence for Elsie\nto guarantee not losing, or $-1$ if she will lose. The move sequence should be\non a single line and consist of $M$ space-separated tokens each equal to either\n\"Even\" or \"Odd\".\n\nNote: \"Even\" is lexicographically smaller than \"Odd\".\n\nSAMPLE INPUT:\n2\n10 3 2\n2 5\n1 3\n1 3\n10 3 3\n2 7 5\n8 3 4\n2 5 6\nSAMPLE OUTPUT: \nEven Even Odd\n-1\n\nIn the first case, the only lexicographically smaller sequence of moves is \"Even\nEven Even\", but Bessie can make Elsie lose in that case by first playing $5$,\nwhich reduces Elsie's number of marbles from $10$ to $5$, then playing $3$, which\nreduces Elsie's number of marbles from $5$ to $2$, then playing $3$, which wipes out\nall of her marbles.\n\nIf Elsie instead plays the correct move sequence \"Even Even Odd\", then if Bessie\nplays the same way, at the end when she plays $3$, Elsie will gain those $3$\nmarbles, increasing her number of marbles to $5$. It can further be shown that\nBessie cannot play in a different way to take all of Elsie's marbles given that\nElsie plays \"Even Even Odd\".\n\nIn the second case, it can be shown that for any move sequence that Elsie could\nchoose, Bessie can play in a way to take all of Elsie's marbles.\n\nSAMPLE INPUT:\n1\n20 8 2\n3 5\n3 5\n3 5\n3 5\n3 5\n3 5\n3 5\n3 5\nSAMPLE OUTPUT: \nEven Even Even Odd Even Odd Even Odd\n\nSCORING:\nInput 3: $M \\leq 16$.Inputs 4-6: $M \\leq 1000$.Inputs\n7-12: No further constraints.\n\n\nProblem credits: Suhas Nagar\n", "num_tests": 12, "solution": "\n(Analysis by Benjamin Qi)\nSubtask 1: $M \\leq 16$:\nFor this subtask, it suffices to iterate through all of Elsie's $2^M$ candidate\nturn sequences in lexicographical order. If with Elsie's current candidate turn\nsequence, she is guaranteed to not lose, output the current sequence, and exit. \nIt remains to describe how to check whether Elsie is guaranteed to not lose with\na given candidate turn sequence. Given Elsie's guess $p$ for a turn $t$, the\nbest response for Bessie is the one that causes Elsie to lose the most marbles\non that turn (or gain the least marbles if none of Bessie's responses can cause\nElsie to lose marbles on that turn). Define $\\texttt{changes}[t][p]$ to be the\namount $N$ will change on turn $t$ if Elsie guesses parity $p$ and Bessie moves\noptimally. After precomputing all entries of $\\texttt{changes}$ in $O(MK)$ time,\nwe can check whether a given turn  sequence causes Elsie to not lose in $O(M)$\ntime. \nThe overall time complexity is\n$O(MK+M\\cdot 2^M)$.\nImplementation (Python):\n\ndef solve():\n    N, M, K = map(int, input().split())\n\n    # changes[t][p] = how many marbles Elsie will gain on turn t,\n    # if Elsie guesses parity p and Bessie responds optimally\n    changes = []\n    for _ in range(M):\n        change_for_turn = [float(\"inf\")] * 2\n        for a in map(int, input().split()):\n            parity = a & 1\n            change_for_turn[parity] = min(change_for_turn[parity], a)\n            change_for_turn[parity ^ 1] = min(change_for_turn[parity ^ 1], -a)\n        changes.append(change_for_turn)\n    ans = None\n\n    def elsie_does_not_lose(seq):\n        state = N\n        for turn in range(M):\n            state += changes[turn][seq[turn]]\n            if state <= 0:\n                return False\n        return True\n\n    def find_best_move_seq_starting_with(seq):\n        nonlocal ans\n        if ans is not None:\n            return\n        if len(seq) == M:\n            if elsie_does_not_lose(seq):\n                ans = seq\n            return\n        for parity in range(2):\n            find_best_move_seq_starting_with(seq + [parity])\n\n    find_best_move_seq_starting_with([])\n    if ans is None:\n        print(-1)\n        return\n    print(\" \".join([[\"Even\", \"Odd\"][p] for p in ans]))\n\n\nT = int(input())\nfor _ in range(T):\n    solve()\n\nSubtask 2: $M\\le 1000$\nTo remove the $O(M\\cdot 2^M)$ from the time complexity, we can make the\nfollowing optimization to the function\n$\\texttt{find_best_move_seq_starting_with}(seq)$ from the above solution code:\nif there is no sequence of moves starting with $seq$ that allows Elsie to not\nlose, then immediately return. To check whether such a sequence exists or not,\nwe assume that for every turn after $|seq|$, Elsie guesses the parity that\ncauses her to gain the most marbles, assuming Bessie responds optimally.  If\nthis allows Elsie to not lose, then a sequence exists. Otherwise, no sequence\nexists, since Elsie lost despite always making the best move after $seq$. This\ncan be checked in $O(M)$ time.\nAfter adding the optimization, the function\n$\\texttt{find_best_move_seq_starting_with}$  is called $O(M)$ times rather than\n$O(2^M)$ times, because if $\\texttt{find_best_move_seq_starting_with}(seq)$ does\nnot immediately return, then\nIf there is a move sequence starting with $seq + [0]$, then the answer will\nbe found after calling\n$\\texttt{find_best_move_seq_starting_with}(seq + [0])$.Otherwise, $\\texttt{find_best_move_seq_starting_with}(seq + [0])$\nimmediately returns and the answer will be found after calling\n$\\texttt{find_best_move_seq_starting_with}(seq + [1])$.\nThe overall time complexity is $O(MK+M^2)$.\nImplementation with recursion:\n\nimport sys\n\n\ndef solve():\n    N, M, K = map(int, input().split())\n    sys.setrecursionlimit(M + 5)\n\n    changes = []\n    for _ in range(M):\n        change_for_turn = [float(\"inf\")] * 2\n        for a in map(int, input().split()):\n            parity = a & 1\n            change_for_turn[parity] = min(change_for_turn[parity], a)\n            change_for_turn[parity ^ 1] = min(change_for_turn[parity ^ 1], -a)\n        changes.append(change_for_turn)\n    ans = None\n\n    def cannot_start_with(seq):\n        state = N\n        for turn in range(M):\n            if turn < len(seq):\n                state += changes[turn][seq[turn]]\n            else:\n                state += max(changes[turn])\n            if state <= 0:\n                return True\n        return False\n\n    def find_best_move_seq_starting_with(seq):\n        nonlocal ans\n        if ans is not None:\n            return\n        if cannot_start_with(seq):\n            return\n        if len(seq) == M:\n            ans = seq\n            return\n        for parity in range(2):\n            find_best_move_seq_starting_with(seq + [parity])\n\n    find_best_move_seq_starting_with([])\n    if ans is None:\n        print(-1)\n        return\n    print(\" \".join([[\"Even\", \"Odd\"][p] for p in ans]))\n\n\nT = int(input())\nfor _ in range(T):\n    solve()\n\nImplementation without recursion:\n\ndef solve():\n    N, M, K = map(int, input().split())\n\n    changes = []\n    for _ in range(M):\n        change_for_turn = [float(\"inf\")] * 2\n        for a in map(int, input().split()):\n            parity = a & 1\n            change_for_turn[parity] = min(change_for_turn[parity], a)\n            change_for_turn[parity ^ 1] = min(change_for_turn[parity ^ 1], -a)\n        changes.append(change_for_turn)\n    ans = None\n\n    def cannot_start_with(seq):\n        state = N\n        for turn in range(M):\n            if turn < len(seq):\n                state += changes[turn][seq[turn]]\n            else:\n                state += max(changes[turn])\n            if state <= 0:\n                return True\n        return False\n\n    if cannot_start_with([]):\n        print(-1)\n        return\n    ans = []\n    for _ in range(M):\n        ans.append(1 if cannot_start_with(ans + [0]) else 0)\n    print(\" \".join([[\"Even\", \"Odd\"][p] for p in ans]))\n\n\nT = int(input())\nfor _ in range(T):\n    solve()\n\nFull solution:\nTo reduce $O(M^2)$ to $O(M)$ time, we need to speed up the function\n$\\texttt{cannot_start_with}(seq)$ from the above solution code. This function\nchecks the following two conditions:\n$N+\\sum_{t=0}^{l-1}\\texttt{changes}[t][seq[t]]>0$ for all $l < |seq|$.$N+\\sum_{t=0}^{|seq|-1}\\texttt{changes}[t][seq[t]] + \\sum_{t=|seq|}^{l-1}\\max(\\texttt{changes}[t][0], \\texttt{changes}[t][1])>0$\nfor all $|seq|\\le l\\le M$.\nSuppose that the first condition already holds; then the second condition holds\nif and only if the minimum prefix sum (including the empty prefix) of the array \n\n[max(changes[t]) for t in range(len(seq), M)]\n\nis greater than some threshold. Let $\\texttt{min_psum}[t]$ denote the minimum\nprefix sum when $|seq| = t$; then we have\n$\\texttt{min_psum}[t]=\\min(0, \\max(\\texttt{changes}[t]) + \\texttt{min_psum}[t+1])$\nfor $t<M$. So $\\texttt{min_psum}[t]$ can be computed for all $t$ in reverse\norder in $O(M)$ time.\nThe full solution is now clear; it is the same as the non-recursive solution to\nthe previous subtask but replacing the call to $\\texttt{cannot_start_with}(seq)$\nwith a comparison involving the current value of $N$ and\n$\\texttt{min_psum}$.\nThe overall time complexity is $O(MK)$.\nMy Implementation:\n\ndef solve():\n    N, M, K = map(int, input().split())\n\n    changes = []\n    for _ in range(M):\n        change_for_turn = [float(\"inf\")] * 2\n        for a in map(int, input().split()):\n            parity = a & 1\n            change_for_turn[parity] = min(change_for_turn[parity], a)\n            change_for_turn[parity ^ 1] = min(change_for_turn[parity ^ 1], -a)\n        changes.append(change_for_turn)\n    min_psum = [0] * (M + 1)\n    for t in reversed(range(M)):\n        min_psum[t] = min(0, max(changes[t]) + min_psum[t + 1])\n    if N + min_psum[0] <= 0:\n        print(-1)\n        return\n    ans = []\n    for t in range(M):\n        p = 1 if (N + changes[t][0] + min_psum[t + 1] <= 0) else 0\n        ans.append(p)\n        N += changes[t][p]\n    print(\" \".join([[\"Even\", \"Odd\"][p] for p in ans]))\n\n\nT = int(input())\nfor _ in range(T):\n    solve()\n\nDanny Mittal's Implementation (Java):\n\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n \npublic class Moorbles {\n \n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        for (int t = in.nextInt(); t > 0; t--) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int k = in.nextInt();\n            int[][] deltas = new int[m][2];\n            for (int j = 0; j < m; j++) {\n                Arrays.fill(deltas[j], 10000);\n                for (int u = k; u > 0; u--) {\n                    int x = in.nextInt();\n                    deltas[j][x % 2] = Math.min(deltas[j][x % 2], x);\n                    deltas[j][(x + 1) % 2] = Math.min(deltas[j][(x + 1) % 2], -x);\n                }\n            }\n            int[] bounds = new int[m + 1];\n            for (int j = m - 1; j >= 0; j--) {\n                bounds[j] = Math.max(0, bounds[j + 1] - Math.max(deltas[j][0], deltas[j][1]));\n            }\n            if (n <= bounds[0]) {\n                System.out.println(-1);\n            } else {\n                StringJoiner joiner = new StringJoiner(\" \");\n                for (int j = 0; j < m; j++) {\n                    if (n + deltas[j][0] > bounds[j + 1]) {\n                        n += deltas[j][0];\n                        joiner.add(\"Even\");\n                    } else {\n                        n += deltas[j][1];\n                        joiner.add(\"Odd\");\n                    }\n                }\n                System.out.println(joiner);\n            }\n        }\n    }\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1395_bronze_palindrome_game": {"name": "Palindrome Game", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1395", "test_data_link": "http://www.usaco.org/current/data/prob1_bronze_feb24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob1_bronze_feb24.html", "contest_link": "http://www.usaco.org/index.php?page=feb24results", "inner_contest_link": null, "problem_level": "bronze", "cp_id": "1395", "problem_id": "1395_bronze_palindrome_game", "description": "\nBessie and Elsie are playing a game with a pile of stones that initially\ncontains $S$ stones ($1\\le S<10^{10^5}$). The two cows alternate turns,  with\nBessie going first. When it is a cow's turn, she must remove $x$ stones from the\npile, where $x$ is any positive integer palindrome of the cow's choosing. If the\npile is empty when a cow's turn starts, that cow loses.\n\nDefinition: A positive integer is a palindrome if it reads the same\nforward and backward; examples of palindromes include 1, 121, and 9009. Leading\nzeros are not allowed; e.g., 990 is *not* a palindrome.\n\nThere are $T$ ($1\\le T\\le 10$) independent test cases. For each test case, \nprint who wins the game if both cows play optimally.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $T$, the number of test cases. The next $T$ lines\ndescribe the test cases, one line per test case.\n\nEach test case is specified by a single integer $S$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor each test case, output B if Bessie wins the game under optimal play starting\nwith a pile of stones of size $S$, or E otherwise, on a new line.\n\nSAMPLE INPUT:\n3\n8\n10\n12\nSAMPLE OUTPUT: \nB\nE\nB\n\nFor the first test case, Bessie can remove all the stones on her first move,\nsince $8$ is a palindrome, guaranteeing her win.\n\nFor the second test case, $10$ is not a palindrome, so Bessie cannot remove all\nthe stones on her first move. Regardless of how many stones  Bessie removes on\nher first move, Elsie can always remove all remaining stones on her second move,\nguaranteeing her win.\n\nFor the third test case, it can be proven that Bessie wins under optimal play.\n\nSCORING:\nInputs 2-4: $S<100$Inputs 5-7: $S<10^6$Inputs 8-10: $S<10^9$Inputs 11-13: No additional constraints.\n\n\nProblem credits: Nick Wu\n", "num_tests": 13, "solution": "\n(Analysis by Nick Wu)\nWe start by defining a winning position and a losing position. If the current\nplayer wins given optimal play on both sides, the position is a winning\nposition, otherwise the position is a losing position.\nFor positions that are not immediately winning or losing positions, we can make\nthe following two observations:\n If one can make a move to a position that is a losing position, then the\ncurrent position is a winning position.  If one can only make moves to\npositions that are winning positions, then the current position is a losing\nposition. \nIn the context of this problem, the pile having zero stones is a losing\nposition, the pile having $1, 2, \\dots, 9$ stones is a winning position, and the\npile having ten stones is a losing position.\nSubtask 1: $S < 100$.\nWe can naively check this process and compute for all $S$ in increasing order if\nthey are winning positions or losing positions.\n\nT = int(input())\n \ndef is_pal(j):\n\ts = str(j)\n\treturn s == \"\".join(reversed(s))\n \nfor _ in range(T):\n\tS = int(input())\n\twin = [False] * (S+1)\n\tfor i in range(S+1):\n\t\tfor j in range(1, i+1):\n\t\t\tif is_pal(j) and not win[i-j]:\n\t\t\t\twin[i] = True\n\tprint(\"B\" if win[S] else \"E\")\n\nSubtask 2: $S < 10^6$.\nThis subtask rewarded people for experimenting with moves and only trying moves\nthat involved taking at most $9$ stones.\n\nT = int(input())\n\nS = 10**6\nwin = [False] * (S+1)\nfor i in range(S+1):\n\tfor j in range(1, min(i+1, 10)):\n\t\tif not win[i-j]:\n\t\t\twin[i] = True\n \nfor _ in range(T):\n\tS = int(input())\n\tprint(\"B\" if win[S] else \"E\")\n\nSubtask 3: $S < 10^9$.\nIf we look at the winning position and losing positions, we can see that a\nposition is winning if and only if $S$ is not divisible by $10$. The proof of\nthis follows directly from observing that taking anywhere from $1$ to $9$ stones\nis possible, but it is never possible to remove a multiple of ten. Therefore, we\njust naively check if the integer is divisible by $10$.\nFull Credit:\nTo check if a very large integer is a multiple of $10$, it suffices to check if\nthe last digit of the number is $0$.\nBenjamin Qi's code:\n\nT = int(input())\nfor _ in range(T):\n\tstart = input()\n\tprint('E' if start[-1] == '0' else 'B')\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1396_bronze_milk_exchange": {"name": "Milk Exchange", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1396", "test_data_link": "http://www.usaco.org/current/data/prob2_bronze_feb24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob2_bronze_feb24.html", "contest_link": "http://www.usaco.org/index.php?page=feb24results", "inner_contest_link": null, "problem_level": "bronze", "cp_id": "1396", "problem_id": "1396_bronze_milk_exchange", "description": "\nFarmer John's $N$ $(1 \\leq N \\leq 2 \\cdot 10^5)$ cows are lined up in a circle\nsuch that for each $i$ in $1,2,\\dots,N-1$, the cow to the right of cow $i$ is\ncow $i+1$, and the cow to the right of cow $N$ is cow $1$. The $i$th cow has a\nbucket with integer capacity $a_i$ $(1 \\leq a_i \\leq 10^9)$ liters. All buckets\nare initially full.\n\nEvery minute, the cows exchange milk according to a string $s_1s_2\\dots s_N$ \nconsisting solely of the characters $\\text{\u2018L\u2019}$ and $\\text{\u2018R\u2019}$.  if\nthe $i$th cow has at least $1$ liter of milk, she will pass $1$ liter of milk to\nthe cow to her left if $s_i=\\text{\u2018L\u2019}$, or to the right if\n$s_i=\\text{\u2018R\u2019}$.  All exchanges happen simultaneously (i.e., if a cow has a\nfull bucket but gives away a liter of milk but also receives a liter, her milk\nis preserved). If a cow's total milk ever ends up exceeding $a_i$, then the\nexcess milk will be lost.\n\nFJ wants to know: after $M$ minutes $(1 \\leq M \\leq 10^9$), what is the total\namount of milk left among all cows?\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$ and $M$.\n\nThe second line contains a string $s_1s_2\\dots s_N$ consisting solely of the\ncharacters $\\text{\u2018L\u2019}$ or $\\text{\u2018R\u2019}$, denoting the direction each cow\nwill pass their milk in.\n\nThe third line contains integers $a_1, a_2, \\dots, a_N$, the capacities of each\nbucket.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput an integer, the sum of milk among all cows after $M$ minutes.\n\nNote that the large size of integers involved in this problem may require the\nuse of 64-bit integer data types (e.g., a \"long long\" in C/C++).\n\nSAMPLE INPUT:\n3 1\nRRL\n1 1 1\nSAMPLE OUTPUT: \n2\n\nCows $2$ and $3$ pass each other one liter of milk, so their milk is preserved.\nWhen cow $1$ passes their milk to cow $2$, cow $2$'s bucket overflows, and one\nliter of milk is lost after one minute.\n\nSAMPLE INPUT:\n5 20\nLLLLL\n3 3 2 3 3\nSAMPLE OUTPUT: \n14\n\nEach cow is passing a liter of milk to the cow on the left and gaining a liter\nof milk from the cow on the right, so all of the milk is preserved regardless of\nhow much time passes.\n\nSAMPLE INPUT:\n9 5\nRRRLRRLLR\n5 8 4 9 3 4 9 5 4\nSAMPLE OUTPUT: \n38\n\nInitially, there are a total of 51 liters of milk. After 5 minutes, cows $3$, $6$, and $7$ will lose 5, 3, and 5 liters of milk respectively. Therefore, a total of 38 liters of milk remain.\n\nSCORING:\nInputs 4-8: $N,M \\le 1000$Inputs 9-16: No additional\nconstraints.\n\n\nProblem credits: Chongtian Ma, Alex Liang\n", "num_tests": 16, "solution": "\n(Analysis by Chongtian Ma and Alex Liang)\nSubtask 1: $N, M \\le 1000$.\nWe can directly simulate the process according to the problem statement. We can\nkeep track of the amount of milk that each cow has and update in\n$\\mathcal{O}(N)$ each minute leading to an $\\mathcal{O}(NM)$ solution.\nChongtian Ma's C++ Code:\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main(){\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    vector<ll> a(N);\n    for (ll& i : a) cin >> i;\n    vector<ll> cap = a;\n\n    for (int t = 0; t < M; t++){\n        vector<ll> new_a = a;\n        for (int i = 0; i < N; i++){\n            if (a[i] >= 1){\n                new_a[i]--;\n                if (S[i] == 'L'){\n                    new_a[(i - 1 + N) % N]++;\n                } \n                else{\n                    new_a[(i + 1) % N]++;\n                }\n            }\n        }\n        for (int i = 0; i < N; i++){\n            new_a[i] = min(new_a[i], cap[i]);\n        }\n        a = new_a;\n    }\n    \n    cout << accumulate(a.begin(), a.end(), 0LL) << endl;\n}\n\nAlex Liang's Python Code:\n\nN, M = map(int, input().split())\nS = list(input())\ncap = [int(x) for x in input().split()]\ncur = [i for i in cap]\n \nfor t in range(M):\n    for i in range(N):\n        if cur[i] > 0:\n            cur[i] -= 1\n            cur[(i + (1 if S[i] == 'R' else -1) + N) % N] += 1\n    for i in range(N):\n        cur[i] = min(cur[i], cap[i])\n \nprint(sum(cur))\n\nFull Credit:\nNote that we can only lose milk if we have a cow that is pointed at in both\ndirections since it is outputting one unit but gaining two units of milk. Call\nthis kind of cow the \"deficit cow\". Two deficit cows occur in the middle when we\nhave substrings of $\\text{\u201cRRR}\\dots \\text{RL} \\dots \\text{LLL\u201d}$. \nThe circle can be broken by these adjacent pairs of deficit cows. For a deficit\ncow to stop losing milk, only milk supply from one side needs to stop. Since the\ntwo deficit cows will infinitely loop each other, milk supply will never stop in the\nside they meet each other, which is why deficit cows always have a full bucket of milk. The only way for the milk source to stop is wait for the other side to end. Below is an example with the deficit cows drawn in\nred.\n\nThe non-cycle side must be a chain (consecutive sequence of cows facing the direction of the corresponding deficit cow) that supplies the milk. In\nthe chain, milk is always being preserved since milk is always flowing in one\ndirection. So, the number of units of milk lost by the deficit cow is the sum of\n$a_i$ of the chain, excluding the deficit cow. For example, for the left deficit\ncow in the adjacent pair (let's say, at index $i$) and $j$ be the leftmost cow\nsuch that $s_j, s_{j+1} \\dots s_i = \\text{\u2018R\u2019}$, then the amount of milk\nthat can be lost is $\\sum_{k=j}^{i-1} a_k$. Note that since only one unit is\nlost per minute, the sum is also capped by $M$. \nSo, we can compute the sum of $a_i$ for the non cycle sides for the pairs of\ndeficit cows. If $S$ is the chain sum, the amount of milk that the cow causes us\nto lose in $M$ minutes is $\\min(S, M)$. This leads to an $\\mathcal{O}(N)$\nsolution.\nChongtian Ma's C++ Code:\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n \nint main(){\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    vector<ll> a(N);\n    for(ll& i: a) cin >> i;\n\t\n    vector<bool> bad_L(N), bad_R(N);\n    for(int i = 0; i < N; i++){\n        if(S[i] == 'R' && S[(i + 1) % N] == 'L'){\n            bad_L[i] = true;\n            bad_R[(i + 1) % N] = true;\n        }\n    }\n        \n    ll ans = accumulate(a.begin(), a.end(), 0LL);\n    for(int i = 0; i < N; i++){\n        ll sum = 0;\n        if(bad_L[i]){\n            int j = (i - 1 + N) % N;\n            while(S[j] == 'R'){\n                sum += a[j--];\n                if(j < 0) j += N;\n            }\n        }\n        if(bad_R[i]){\n            int j = (i + 1) % N;\n            while(S[j] == 'L'){\n                sum += a[j++];\n                if(j >= N) j -= N;\n            }\n        }\n        ans -= min(sum, (ll) M);\n    }\n    cout << ans << endl;\n}\n\nAlex Liang's Python Code:\n\nN, M = map(int, input().split())\nS = list(input())\nA = [int(x) for x in input().split()]\n \nans = sum(A)\n \nfor i in range(N):\n    if (S[i] == 'R' and S[(i + 1) % N] == 'L'):\n        j = (i - 1 + N) % N \n        total = 0\n \n        while S[j] == 'R':\n            total += A[j]\n            j = (j - 1 + N) % N \n \n        ans -= min(total, M)\n    \n    if (S[i] == 'L' and S[(i - 1 + N) % N] == 'R'):\n        j = (i + 1) % N \n        total = 0\n \n        while S[j] == 'L':\n            total += A[j]\n            j = (j + 1) % N \n \n        ans -= min(total, M)\n \nprint(ans)\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1397_bronze_maximizing_productivity": {"name": "Maximizing Productivity", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1397", "test_data_link": "http://www.usaco.org/current/data/prob3_bronze_feb24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob3_bronze_feb24.html", "contest_link": "http://www.usaco.org/index.php?page=feb24results", "inner_contest_link": null, "problem_level": "bronze", "cp_id": "1397", "problem_id": "1397_bronze_maximizing_productivity", "description": "\nFarmer John has $N$ ($1 \\leq N \\leq 2 \\cdot 10^5$) farms, numbered from $1$ to\n$N$. It is known that FJ closes farm $i$ at time $c_i$. Bessie wakes up at time\n$S$, and wants to maximize the productivity of her day by visiting as many farms\nas possible before they close. She plans to visit farm $i$ on time $t_i + S$.\nBessie must arrive at a farm strictly before Farmer John closes it to actually visit it.\n\nBessie has $Q$ $(1 \\leq Q \\leq 2 \\cdot 10^5)$ queries. For each query, she gives\nyou two integers $S$ and $V$. For each query, output whether Bessie can visit at\nleast $V$ farms if she wakes up at time $S$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line consists of $N$ and $Q$.\n\nThe second line consists of $c_1, c_2, c_3 \\dots c_N$ ($1 \\leq c_i \\leq 10^6$).\n\nThe third line consists of $t_1, t_2, t_3 \\dots t_N$ ($1 \\leq t_i \\leq 10^6$).\n\nThe next $Q$ lines each consist of two integers $V$ ($1 \\leq V \\leq N$) and $S$\n($1 \\leq S \\leq 10^6$).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor each of the $Q$ queries, output YES or NO on a new line.\n\nSAMPLE INPUT:\n5 5\n3 5 7 9 12\n4 2 3 3 8\n1 5\n1 6\n3 3\n4 2\n5 1\nSAMPLE OUTPUT: \nYES\nNO\nYES\nYES\nNO\n\nFor the first query, Bessie will visit the farms at time $t = [9, 7, 8, 8, 13]$,\nso she will only get to visit farm $4$ on time before FJ closes the farm.\n\nFor the second query, Bessie will not be able to visit any of the farms on time.\n\nFor the third query, Bessie will visit farms $3, 4, 5$ on time.\n\nFor the fourth and fifth queries, Bessie will be able to visit all but the first\nfarm on time.\n\nSCORING:\nInputs 2-4: $N,Q\\le 10^3$Inputs 5-9: $c_i, t_i \\le 20$Inputs 10-17: No additional constraints.\n\n\nProblem credits: Chongtian Ma\n", "num_tests": 17, "solution": "\n(Analysis by Alex Fan)\nSubtask 1: $N, Q < 10^3$.\nWe can directly simulate the process according to the problem statement. For\neach query, we iterate through all the farms and see if we can visit it in time,\n$t_i + S < c_i$. Each query takes $\\mathcal{O}(N)$ operations, giving us\nan $\\mathcal{O}(NQ)$ solution.\nAlex Fan's C++ Code:\n\nusing namespace std;\n\n#include <iostream>\n\n#define MAXN 200005\n\nint N,Q,c[MAXN],t[MAXN];\n\nint main() {\n\tcin >> N >> Q;\n\tfor(int i = 0;i < N;++i) {\n\t\tcin >> c[i];\n\t}\n\tfor(int i = 0;i < N;++i) {\n\t\tcin >> t[i];\n\t}\n\n\tfor(int i = 0;i < Q;++i) {\n\t\tint v,s;\n\t\tcin >> v >> s;\n\t\tint uwu = 0;\n\t\tfor(int j = 0;j < N;++j) {\n\t\t\tif(s + t[j] < c[j]) {\n\t\t\t\tuwu++;\n\t\t\t}\n\t\t}\n\t\tcout << (uwu >= v ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}\n\nPython Code:\n\nN, Q = (int(x) for x in input().split())\nc = [int(x) for x in input().split()]\nt = [int(x) for x in input().split()]\nfor _ in range(Q):\n    V, S = (int(x) for x in input().split())\n    uwu = 0\n    for i in range(N):\n        if(S + t[i] < c[i]):\n            uwu += 1\n    print(\"YES\" if (uwu >= V) else \"NO\")\n\nSubtask 2: $c_i, t_i < 20$\nThe key observation is to notice that we can rearrange the formula\n$t_i + S < c_i$ as $c_i - t_i > S$. Therefore, for each farm, we can take\nadvantage of the fact that $c_i - t_i$ can only be between $-20$ to $20$.\nIf $c_i - t_i \\leq 0$, then we can get rid of it since we can never make it in\ntime. Otherwise, there are only $21$ possible values despite there being\n$2 \\cdot 10^5$ farms. We exploit this observation by grouping the same\n$c_i - t_i$ values together. This can be implemented with a map, or, since the\nvalues are between $0$ and $20$, an array of length $21$.\nFinally, to check if a query works, we iterate through the array and count the\nnumber of valid barns that satisfy the inequality. The valid range is always\nthe continuous interval to the right of $S$.\nEach query takes $\\mathcal{O}(MAXC)$ time where $MAXC \\leq 20$ is the maximum\nvalue of $c_i$, so the total complexity is $\\mathcal{O}(N + Q \\cdot MAXC)$\nAlex Fan's C++ Code:\n\nusing namespace std;\n\n#include <iostream>\n#include <map>\n\n#define MAXN 200005\n#define MAXA 1000005\n\nint N,Q,c[MAXN],t[MAXN],cnt[MAXA],max_element;\n\nint main() {\n\tcin >> N >> Q;\n\tfor(int i = 0;i < N;++i) {\n\t\tcin >> c[i];\n\t}\n\tfor(int i = 0;i < N;++i) {\n\t\tcin >> t[i];\n\t\tif(c[i] > t[i]) {\n\t\t\t// Maintain the count array of c[i] - t[i]\n\t\t\tcnt[c[i] - t[i]]++;\n\t\t}\n\t\t// We can also replace max_element as the constant 20\n\t\tmax_element = max(max_element,c[i] - t[i]);\n\t}\n\n\tfor(int i = 0;i < Q;++i) {\n\t\tint v,s;\n\t\tcin >> v >> s;\n\t\tint uwu = 0;\n\t\tif(N <= 1e3) {\n\t\t\t// Subtask 1\n\t\t\tfor(int i = 0;i < N;++i) {\n\t\t\t\tif(t[i] + s < c[i]) uwu++;\n\t\t\t}\n\t\t}else if(max_element <= 20) {\n\t\t\t// Subatsk 2\n\t\t\tfor(int i = s + 1;i <= max_element;++i) {\n\t\t\t\tuwu += cnt[i];\n\t\t\t}\n\t\t}\n\t\tcout << (uwu >= v ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}\n\nPython Code:\n\nN, Q = (int(x) for x in input().split())\nc = [int(x) for x in input().split()]\nt = [int(x) for x in input().split()]\n\ncnt = [0] * 25\n\nfor i in range(N):\n\tif(c[i] > t[i]):\n\t\tcnt[c[i] - t[i]] += 1\n\nfor _ in range(Q):\n    V, S = (int(x) for x in input().split())\n    uwu = 0\n    for i in range(S + 1,25,1):\n        uwu += cnt[i]\n    print(\"YES\" if (uwu >= V) else \"NO\")\n\n\nFull Credit:\nThe final step is to efficiently count the number of farms such that their\n$c_i - t_i$ is greater than some query value $S$. This is a standard setup that\ncan be solved by first sorting all the differences and applying binary search. This gives an $\\mathcal{O}(N\\log N + Q\\log N)$ solution.\nAlternatively, you can further observe that after we sort all the values of\n$c_i - t_i$, the query $(V, S)$ is \"YES\" if and only if the $V$-th largest value\nof $c_i - t_i$ is more than $S$, which can be done by checking the $i$-th\nelement of the sorted array. Reference Brandon Wang's Python Code for the\nimplementation. This also results in a $\\mathcal{O}(N\\log N + Q)$ solution.\nAlex Fan's C++ Code:\n\nusing namespace std;\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n\n#define MAXN 200005\n\nint N,Q,c[MAXN],t[MAXN];\n\nint main() {\n\tcin >> N >> Q;\n\tfor(int i = 0;i < N;++i) {\n\t\tcin >> c[i];\n\t}\n\tfor(int i = 0;i < N;++i) {\n\t\tcin >> t[i];\n\t\tc[i] -= t[i];\n\t}\n\n\tsort(c,c + N);\n\n\tfor(int i = 0;i < Q;++i) {\n\t\tint v,s;\n\t\tcin >> v >> s;\n\t\tint uwu = N - (lower_bound(c,c + N,s + 1) - c);\n\t\tcout << (uwu >= v ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}\n\nBrandon Wang's Python Code\n\nN, Q = (int(x) for x in input().split())\nc = [int(x) for x in input().split()]\nt = [int(x) for x in input().split()]\ndiffs = sorted([ci - ti for ci, ti in zip(c, t)], reverse=True)\nfor _ in range(Q):\n    V, S = (int(x) for x in input().split())\n    print(\"YES\" if (V <= N and (V <= 0 or diffs[V-1] > S)) else \"NO\")\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1380_platinum_island_vacation": {"name": "Island Vacation", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1380", "test_data_link": "http://www.usaco.org/current/data/prob1_platinum_jan24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob1_platinum_jan24.html", "contest_link": "http://www.usaco.org/index.php?page=jan24results", "inner_contest_link": null, "problem_level": "platinum", "cp_id": "1380", "problem_id": "1380_platinum_island_vacation", "description": "\nBessie is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform a connected simple graph (in particular, no two bridges connect the same\npair of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle that does not contain repeated islands.\n\nBessie starts at island $1$, and travels according to the following procedure.\nSupposing she is currently at island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$, she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor each island, output the probability that she ends her vacation at that\nisland, modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains the number of independent test cases $T$\n($1\\le T\\le 10$). Consecutive test cases are separated by an empty line.\n\nThe first line of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$ is the number of bridges. It is guaranteed that the sum of $N$\nover all test cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1, p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor each test case, output the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1 3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT: \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$ of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$. Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5 5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2 3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336 0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to 2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$ of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$ of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2 3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2 7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938 933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le 11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs 16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional constraints.\n\n\nProblem credits: Benjamin Qi\n", "num_tests": 23, "solution": "\n(Analysis by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected graph, such that each edge belongs to at most one\nsimple cycle. Such a graph is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise, if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise, choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse it.\nFor all vertices $i$, you want to find the probability that you end your walk at\n$i$. Let's call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$ if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the probability that you reach a state where you're at vertex\n$i$, and the set of untraversed edges is $E$.\nLet's see how to transition from $dp_{i, E}$ to other states.\nLet $E'$ be the set of edges in $E$ adjacent to $i$.\nIf $E'$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E} \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E'$ adjacent to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E'|}$ to\n$dp_{j, E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i, E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken for this DP is\n$O(2^M \\cdot M)$.\nRain's code:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 / 2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o] = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_, o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i] = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i, h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b], 0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m) - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i] = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long) x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_ = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] + x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? ' ' : '\\n');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K = 0$.\nThe graph is a tree. Let's root the tree at vertex $1$.\nNotice that you travel along a path from the root, and only move deeper and\ndeeper. Let $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$ is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$. We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain's code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i] = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i, j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1, 0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? ' ' : '\\n');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating all\nof Bessie's possible walks. The number of walks is bounded above by\n$N\\cdot 3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$\nbecause if we:\nFix Bessie's ending vertex (choices: $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie's walk is uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le 5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le 1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be represented as path from a vertex to one of its\ndescendants, plus the corresponding back edge. Let's call this highest vertex\nthe top vertex of the cycle.\nYou can see that the path generally moves downward, with occasional roundabouts\nalong cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled similar to Subtask 2.\nLet's see how to transition using cycle edges. Let $i$ be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the two probabilities of going from $i$ to\n$j$, by choosing one of two paths going from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices $u$ along that path.\nYou should also handle the special case of traversing the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this occurring is similar to the\nabove. After we traverse $C$, there are no more cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We process each cycle $C$ by going\nthrough it twice, once in each direction, taking $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain's code:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d) {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i, j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k] = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j] = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i] = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_ = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i] + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j] + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k, 1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j, 0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? ' ' : '\\n');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4, 5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree for quite a while,\nbut eventually retrace and traverse another path.\nLet's define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent. By the assumption that the graph is a cactus, $f$ must either be a\nbridge or is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\", we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$ the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is a bridge) or the top vertex of $pc_i$ (if $f$ isn't a bridge.)\nSymmetrically, $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet's observe what edges adjacent to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge. We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case, all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed, this edge is the only edge that can be used to escape\n$T_i$, and once we use it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$ -- the probability that, starting from $i$, we eventually use the\n\"escape edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse on $j$.\nFinally, let's compute $ans_i$. You end up at vertex $i$ if you visit vertex\n$i$, and you don't do either of the following:\n\nUse the \"escape edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$ and $qVisit$ is $O(M)$.\nLet's compute $pEscape$ and $qVisit$ in a bottom-up fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices $j \\in C$ excluding $i$. In other words, this is\nthe probability that you can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$ be the set of cycles that $i$ is the top vertex of.\nThere are two things we need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$ -- The probability of eventually choosing one of two edges adjacent\nto $i$ on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i, j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$, if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny corresponding path must eventually select one of two edges adjacent to $i$\non $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask 3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$ for $C \\in CC$ fast.\nLet's consider $pChoose_{bridge}$. Any corresponding path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ..., C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1} \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right) \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above term doesn't change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet's instead sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k} \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$ for $C \\in CC$ can be calculated in the same way, except that in the\nabove formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask 4 where $K \\le 5$.\nLet's make it faster. Note that the terms with the same $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1 - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$ for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions. Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x) [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$ for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This is enough to pass subtask 5, where $K \\le 50$.\nRain's code for Subtask 5:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d) {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i, j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k] = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j] = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y, y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j, 0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] % MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 % MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) % MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_ = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] = 1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? ' ' : '\\n');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit, we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice that the generating function we calculate for $pChoose_C$ is almost the\nsame as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial, we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$ divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities from the generating function, so in total we\nspend $O(K^2)$ time to compute $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d) {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i, j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k] = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j] = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j, 0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] % MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 % MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) % MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c] = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) % MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? ' ' : '\\n');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n \npublic class IslandVacationBufferedReader {\n    public static final long MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n \n    public static void main(String[] args) throws IOException {\n        long[] factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000] = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k] = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++) {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a] = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++) {\n                tokenizer = new StringTokenizer(in.readLine());\n                int a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[] children = new List[n + 1];\n            List<Integer>[] childrenCycles = new List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a] = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[] cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new List[(m / 3) + 1];\n            new Object() {\n                int[] seen = new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int dfs(int a, int from) {\n                    seen[a] = 1;\n                    int result = 0;\n                    for (int b : adj[a]) {\n                        if (b != from && seen[b] != 2) {\n                            //System.out.println(a + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen, making cycle\");\n                                parentIsCycle[a] = true;\n                                result = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result] = b;\n                                cycles[result].add(a);\n                            } else {\n                                int sub = dfs(b, a);\n                                if (sub == 0) {\n                                    children[a].add(b);\n                                } else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    } else {\n                                        parentIsCycle[a] = true;\n                                        result = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a] = 2;\n                    return result;\n                }\n            }.dfs(1, 0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[] leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts = new long[n + 1][];\n \n            new Object() {\n \n                void calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for (int b : children[a]) {\n                        calcNode(b);\n                    }\n \n                    int amtBridges = children[a].size() + (parentIsCycle[a] ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a] = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] = 1;\n                    int j = 0;\n                    for (int k : childrenCycles[a]) {\n                        j++;\n                        for (int l = j; l > 0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k] * subsetProducts[a][l - 1];\n                            subsetProducts[a][l] %= MOD;\n                        }\n                    }\n \n                    long base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base *= continueProbability[a];\n                        base %= MOD;\n                        base *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base %= MOD;\n                        if (x > 0) {\n                            base *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a] += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a] %= MOD;\n                        base *= 2L;\n                    }\n                }\n \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k] = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k] *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b] = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n \n                    int amtBridges = children[a].size() + (parentIsCycle[a] ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles; x++) {\n                            base *= continueProbability[a];\n                            base %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles - x))];\n                            base %= MOD;\n                            if (x > 0) {\n                                base *= (long) x;\n                                base %= MOD;\n                            }\n \n                            enterCycle[k] += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n \n                void calcCycle(int k) {\n                    long prob = (inv[2] * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a] += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k]) % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--) {\n                        int a = cycles[k].get(j);\n                        enterNode[a] += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob %= MOD;\n                    }\n \n                    for (int a : cycles[k]) {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n \n            long[] endInSubtreeNode = new long[n + 1];\n            long[] endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new long[n + 1];\n \n            new Object() {\n \n                void calcNode(int a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a] ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n \n                    answers[a] = endInSubtreeNode[a];\n                    for (int b : children[a]) {\n                        calcNode(b);\n                        answers[a] -= endInSubtreeNode[b];\n                    }\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a] -= endInSubtreeCycle[k];\n                    }\n                    answers[a] %= MOD;\n                    answers[a] += MOD;\n                    answers[a] %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k] = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k] %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(' ');\n            }\n            out.append('\\n');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus: Solve this problem in $O(N\\log^2N)$ time using FFT.", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1381_platinum_merging_cells": {"name": "Merging Cells", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1381", "test_data_link": "http://www.usaco.org/current/data/prob2_platinum_jan24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob2_platinum_jan24.html", "contest_link": "http://www.usaco.org/index.php?page=jan24results", "inner_contest_link": null, "problem_level": "platinum", "cp_id": "1381", "problem_id": "1381_platinum_merging_cells", "description": "\n**Note: The memory limit for this problem is 512MB, twice the default.**\nBessie is having fun playing a famous online game, where there are a bunch of\ncells of different labels and sizes. Cells get eaten by other cells until only\none winner remains.\n\nThere are $N$ ($2\\le N\\le 5000$) cells in a row labeled $1\\dots N$ from left to\nright, with initial sizes $s_1,s_2,\\dots,s_N$ ($1\\le s_i\\le 10^5$). While there\nis more than one cell, a pair of adjacent cells is selected uniformly at random\nand merged into a single new cell according to the following rule: \n\nIf a cell with label $a$ and current size $c_a$ is merged with a cell with label\n$b$ and current size $c_b$, the resulting cell has size $c_a+c_b$ and label\nequal to that of the larger cell, breaking ties by larger label. Formally, the\nlabel of the resulting cell is\n$\\begin{cases}\na & c_a > c_b \\\\\nb & c_a < c_b \\\\\n\\max(a,b) & c_a = c_b\n\\end{cases}.$\n\nFor each label $i$ in the range $1\\dots N$, the probability that the final cell\nhas label $i$ can be expressed in the form $\\frac{a_i}{b_i}$ where\n$b_i\\not\\equiv 0\\pmod{10^9+7}$. Output $a_ib_i^{-1}\\pmod{10^9+7}$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$.\n\nThe next line contains $s_1,s_2,\\dots, s_N$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe probability of the final cell having label $i$ modulo $10^9+7$ for each $i$ in $1\\dots N$ on\nseparate lines.\n\nSAMPLE INPUT:\n3\n1 1 1\nSAMPLE OUTPUT: \n0\n500000004\n500000004\n\nThere are two possibilities, where $(a,b)\\to c$ means that the cells with labels\n$a$ and $b$ merge into a new cell with label $c$.\n\n\n(1, 2) -> 2, (2, 3) -> 2\n(2, 3) -> 3, (1, 3) -> 3\n\nSo with probability $1/2$ the final cell has label 2 or 3.\n\nSAMPLE INPUT:\n4\n3 1 1 1\nSAMPLE OUTPUT: \n666666672\n0\n166666668\n166666668\n\nThe six possibilities are as follows:\n\n\n(1, 2) -> 1, (1, 3) -> 1, (1, 4) -> 1\n(1, 2) -> 1, (3, 4) -> 4, (1, 4) -> 1\n(2, 3) -> 3, (1, 3) -> 1, (1, 4) -> 1\n(2, 3) -> 3, (3, 4) -> 3, (1, 3) -> 3\n(3, 4) -> 4, (2, 4) -> 4, (1, 4) -> 4\n(3, 4) -> 4, (1, 2) -> 1, (1, 4) -> 1\n\nSo with probability $2/3$ the final cell has label 1, and with probability $1/6$\nthe final cell has label 3 or 4.\n\nSCORING:\nInput 3: $N\\le 8$Inputs 4-8: $N\\le 100$Inputs 9-14: $N\\le 500$Inputs 15-22: No additional constraints.\n\n\nProblem credits: Benjamin Qi\n", "num_tests": 22, "solution": "\n(Analysis by Bing-Dong Liu)\nNote: let $\\texttt{sum}(l, r)$ denote $s_l + s_{l+1} + \\dots + s_{r-1} + s_r$.\nSubtask 1 ($N\\leq 8$)\nIt suffices to brute force all $(N-1)!$ permutations of merges.\nSubtask 2 ($N\\leq 100$)\nLet's try to calculate the answer for a given cell $c$. At any step, $c$ must be\nthe label of a cell that represents the sum of a range $[l, r]$ in the original\narray. Let $\\texttt{dp}[l][r]$ represent the probability that $c$ becomes the\nfinal label if we only consider the cells in the range $[l, r]$. For\ntransitions, we can consider enumerating the last merge while making sure that\nthe $c$ remains as the label. Also, note that each of the $r-l$ possible merges\nhas an equal probability of being the last merge.\nThe base case is $\\texttt{dp}[c][c] = 1$. Otherwise, we have the following:\n$$\n\\texttt{dp}[l][r] =\n\\sum_{\\substack{m\\in (l, c] \\\\ \\texttt{sum}(l, m-1)\\leq \\texttt{sum}(m, r)}}{\\frac{1}{r-l}\\cdot\\texttt{dp}[m][r]} +\n\\sum_{\\substack{m\\in [c, r] \\\\ \\texttt{sum}(l, m) > \\texttt{sum}(m+1, r)}}{\\frac{1}{r-l}\\cdot\\texttt{dp}[l][m]}\n\n$$\nThis runs in $\\mathcal O(N^3)$ for a single cell $c$, resulting in a\n$\\mathcal O(N^4)$ solution.\nMy code:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N; cin >> N;\n    vector S(N + 1, 0);\n    for (int i = 0; i < N; i++) {\n        int x; cin >> x;\n        S[i + 1] = S[i] + x;\n    }\n    auto sum = [&](int l, int r) {\n        return S.at(r + 1) - S.at(l);\n    };\n    vector inv(N, 0);\n    inv[1] = 1;\n    for (int i = 2; i <= N; i++)\n        inv[i] = (long long) inv[MOD % i] * (MOD - MOD / i) % MOD;\n    for (int c = 0; c < N; c++) {\n        vector dp(N, vector(N, 0));\n        dp[c][c] = 1;\n        for (int l = c; l >= 0; l--) for (int r = c; r < N; r++) {\n            if (l == c && r == c) continue;\n            long long x = 0;\n            for (int m = l + 1; m <= c; m++) // last merge was leftwards\n                if (sum(m, r) >= sum(l, m - 1)) x += dp[m][r];\n            for (int m = c; m < r; m++) // last merge was rightwards\n                if (sum(l, m) > sum(m + 1, r)) x += dp[l][m]; \n            dp[l][r] = x % MOD * inv[r - l] % MOD; // probability of fixed last merge\n        }\n        cout << dp[0][N - 1] << '\\n';\n    }\n}\n\nSubtask 3 ($N\\leq 500$)\nIt is possible to optimize the solution from subtask 2 to $\\mathcal O(N^3)$\nusing prefix sums and two pointers (described more in detail in subtask 4's\nnotes).\nHowever, I will discuss another approach that is closer to the full solution.\nNotice that recalculating the DP for each $c$ can be suboptimal in many ways;\nfor example, regardless of which label a cell $(l, r)$ contains, it has the same\ncontribution to $\\texttt{dp}[1][N]$. Therefore, let's consider calculating the\nDP backwards.\nLet $\\texttt{dp}[l][r]$ represent the probability that the label of the cell\nrepresenting the range $[l, r]$ becomes the label of the final cell after all\nmerges. The base case is $\\texttt{dp}[1][N] = 1$. Otherwise, transitions are\nsimilar to the ones described in the subtask 2 solution:\n$$\n\\texttt{dp}[l][r] =\n\\sum_{\\substack{p\\in [1, l) \\\\ \\texttt{sum}(l, r)\\geq \\texttt{sum}(p, l-1)}}{\\frac{1}{r-p}\\cdot \\texttt{dp}[p][r]} +\n\\sum_{\\substack{p\\in (r, N] \\\\ \\texttt{sum}(l, r) > \\texttt{sum}(r+1, p)}}{\\frac{1}{p-l}\\cdot \\texttt{dp}[l][p]}\n\n$$\nThe answer for a cell $c$ is $\\texttt{dp}[c][c]$. This runs in\n$\\mathcal O(N^3)$.\nMy code:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N; cin >> N;\n    vector S(N + 1, 0);\n    for (int i = 0; i < N; i++) {\n        int x; cin >> x;\n        S[i + 1] = S[i] + x;\n    }\n    auto sum = [&](int l, int r) {\n        return S.at(r + 1) - S.at(l);\n    };\n    vector inv(N, 0);\n    inv[1] = 1;\n    for (int i = 2; i <= N; i++)\n        inv[i] = (long long) inv[MOD % i] * (MOD - MOD / i) % MOD;\n    vector dp(N, vector(N, 0));\n    dp[0][N - 1] = inv[N - 1];\n    for (int l = 0; l < N; l++) for (int r = N - 1; r >= l; r--) {\n        if (l == 0 && r == N - 1) continue;\n        long long x = 0;\n        for (int p = 0; p < l; p++) // last merge was leftwards\n            if (sum(l, r) >= sum(p, l - 1)) x += dp[p][r];\n        for (int p = r + 1; p < N; p++) // last merge was rightwards\n            if (sum(l, r) > sum(r + 1, p)) x += dp[l][p];\n        dp[l][r] = x % MOD;\n        if (l < r) // probability of fixed last merge\n            dp[l][r] = (long long) dp[l][r] * inv[r - l] % MOD;\n    }\n    for (int c = 0; c < N; c++) cout << dp[c][c] << '\\n';\n}\n\nSubtask 4 $(N\\leq 5000$)\nLet's try to accelerate the solution from subtask 3. For example, say the last\nmerge is leftwards. We query the sum of $\\frac{\\texttt{dp}[p][r]}{r-p}$ over a fixed $r$ and\na range of $p$. The range of $p$ is determined by the leftmost position such\nthat $\\texttt{sum}(l, r)\\geq \\texttt{sum}(p, l-1)$ holds. Let this bound be\ndenoted as $\\texttt{pL}[l][r]$. It can be proven that\n$\\texttt{pL}[l][r]\\leq \\texttt{pL}[l+1][r]$, which allows us to compute all\n$\\texttt{pL}[l][r]$ in $\\mathcal O(N^2)$ time using two pointers. Next, to\ncalculate the sum, we need a data-structure that can support adding\n$\\frac{\\texttt{dp}[l][r]}{r-l}$ and querying the sum over\n$p\\in [\\texttt{pL}[l][r], l)$. Since we enumerate ranges in decreasing order of\nsize, for a fixed $r$, $\\frac{\\texttt{dp}[l][r]}{r-l}$ is added in increasing order of $l$.\nThis allows us to maintain prefix sums and answer range sum queries in constant\ntime.\nThis runs in $\\mathcal O(N^2)$. My code:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define sz(v) int(std::size(v))\nconst int MOD = 1e9 + 7;\n\nint add(int a, int b) { return a + b >= MOD ? a + b - MOD : a + b; }\nint sub(int a, int b) { return add(a, MOD - b); }\nint mul(int a, int b) { return (long long) a * b % MOD; }\nvoid add_self(int &a, int b) { a = add(a, b); }\n\nstruct sumL { // fixed l => updates (r) in decreasing order\n    vector<int> t; sumL(int N) : t(N) {}\n    void set(int i, int x) { t.at(i) = add(x, i + 1 < sz(t) ? t.at(i + 1) : 0); }\n    int sum(int l, int r) { return l > r ? 0 : sub(t.at(l), r + 1 < sz(t) ? t.at(r + 1) : 0); }\n};\nstruct sumR { // fixed r => updates (l) in increasing order\n    vector<int> t; sumR(int N) : t(N) {}\n    void set(int i, int x) { t.at(i) = add(x, i ? t.at(i - 1) : 0); }\n    int sum(int l, int r) { return l > r ? 0 : sub(t.at(r), l ? t.at(l - 1) : 0); }\n};\n\nint main() {\n    int N; cin >> N;\n    vector<int> S(N + 1);\n    for (int i = 0; i < N; i++) {\n        int x; cin >> x;\n        S[i + 1] = S[i] + x;\n    }\n    auto sum = [&](int l, int r) {\n        return S.at(r + 1) - S.at(l);\n    };\n    vector<int> inv(N);\n    inv[1] = 1;\n    for (int i = 2; i < N; i++) inv[i] = mul(inv[MOD % i], MOD - MOD / i);\n    vector dp(N, vector<int>(N));\n    vector sL(N, sumL(N)); vector sR(N, sumR(N));\n    // pL[l][r] = farthest we can merge leftwards such that sum(l, r) >= sum(p, l-1)\n    // pR[l][r] = farthest we can merge rightwards such that sum(l, r) > sum(r+1, p)\n    vector pL(N, vector<int>(N)), pR(N, vector<int>(N));\n    for (int l = 0; l < N; l++) for (int r = l, p = l; r < N; r++) {\n        while (p > 0 && sum(l, r) >= sum(p - 1, l - 1)) p--;\n        pL[l][r] = p;\n    }\n    for (int r = 0; r < N; r++) for (int l = r, p = r; l >= 0; l--) {\n        while (p + 1 < N && sum(l, r) > sum(r + 1, p + 1)) p++;\n        pR[l][r] = p;\n    }\n    dp[0][N - 1] = inv.at(N - 1);\n    sL[0].set(N - 1, dp[0][N - 1]), sR[N - 1].set(0, dp[0][N - 1]);\n    for (int l = 0; l < N; l++) for (int r = N - 1; r >= l; r--) {\n        if (l == 0 && r == N - 1) continue;\n        add_self(dp[l][r], sR[r].sum(pL[l][r], l - 1)); // last merge was leftwards\n        add_self(dp[l][r], sL[l].sum(r + 1, pR[l][r])); // last merge was rightwards\n        if (l < r) dp[l][r] = mul(dp[l][r], inv.at(r - l)); // probability of fixed last merge\n        sL[l].set(r, dp[l][r]), sR[r].set(l, dp[l][r]);\n    }\n    for (int c = 0; c < N; c++) cout << dp[c][c] << '\\n';\n}\n\nThe code above uses around $5N^2$ memory. It's possible to optimize this to\n$N^2$ by just storing the DP array while maintaining $\\texttt{pL}[l][r]$,\n$\\texttt{pR}[l][r]$, and the range sums in 1D arrays. \nBenjamin Qi's code:\n\n#include <bits/stdc++.h>\nusing namespace std;\n \nconst int MOD = 1e9 + 7;\n \nint main() {\n    int N; cin >> N;\n    vector<int> S(N);\n    for (auto &x : S) cin >> x;\n    vector<int> cum_S{0};\n    for (auto t : S) cum_S.push_back(cum_S.back() + t);\n    vector win_prob(N + 1, vector<int>(N + 1));\n    vector<int> invs(N);\n    invs[1] = 1;\n    for (int i = 2; i < N; i++) invs[i] = (long long) invs[MOD % i] * (MOD - MOD / i) % MOD;\n    win_prob.at(0).at(N) = 1;\n    vector<int> l_sum(N + 1), r_sum(N + 1), l_ptr(N + 1), r_ptr(N + 1, N);\n    for (int l = 0; l <= N; l++) for (int r = N; r > l; r--) {\n        while (!(cum_S.at(l) - cum_S.at(l_ptr[r]) <= cum_S.at(r) - cum_S.at(l))) {\n            l_sum[r] -= win_prob.at(l_ptr[r]).at(r);\n            if (l_sum[r] < 0) l_sum[r] += MOD;\n            ++l_ptr[r];\n        }\n        while (!(cum_S.at(r) - cum_S.at(l) > cum_S.at(r_ptr[l]) - cum_S.at(r))) {\n            r_sum.at(l) -= win_prob.at(l).at(r_ptr[l]);\n            if (r_sum[l] < 0) r_sum[l] += MOD;\n            --r_ptr[l];\n        }\n        win_prob.at(l).at(r) += l_sum.at(r);\n        win_prob.at(l).at(r) += r_sum.at(l);\n        if (win_prob[l][r] >= MOD) win_prob[l][r] -= MOD;\n        if (r > l + 1) win_prob.at(l).at(r) = (long long) win_prob[l][r] * invs.at(r - l - 1) % MOD;\n        l_sum[r] += win_prob.at(l).at(r);\n        if (l_sum[r] >= MOD) l_sum[r] -= MOD;\n        r_sum[l] += win_prob.at(l).at(r);\n        if (r_sum[l] >= MOD) r_sum[l] -= MOD;\n    }\n    for (int i = 0; i < N; i++) cout << win_prob.at(i).at(i + 1) << '\\n';\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": ["\n**Note: The memory limit for this problem is 512MB, twice the default."], "runtime_limit": 2, "memory_limit": 512}, "1382_platinum_mooball_teams_iii": {"name": "Mooball Teams III", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1382", "test_data_link": "http://www.usaco.org/current/data/prob3_platinum_jan24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob3_platinum_jan24.html", "contest_link": "http://www.usaco.org/index.php?page=jan24results", "inner_contest_link": null, "problem_level": "platinum", "cp_id": "1382", "problem_id": "1382_platinum_mooball_teams_iii", "description": "\nFarmer John has $N$ cows on his farm ($2 \\leq N \\leq 2\\cdot 10^5$), conveniently\nnumbered $1 \\dots N$. Cow $i$ is located at integer coordinates $(x_i, y_i)$ \n($1\\le x_i,y_i\\le N$). Farmer John wants to pick two teams for a game of\nmooball!\n\nOne of the teams will be the \"red\" team; the other team will be the \"blue\" team.\nThere are only a few requirements for the teams. Neither team can be empty, and\neach of the $N$ cows must be on at most one team (possibly neither). The only\nother requirement is due to a unique feature of mooball: an infinitely long net,\nwhich must be placed as either a horizontal or vertical line in the plane at a\nnon-integer coordinate, such as $x = 0.5$. FJ must pick teams so that it is\npossible to separate the teams by a net. The cows are unwilling to move to make\nthis true.\n\nHelp a farmer out! Compute for Farmer John the number of ways to pick a red team\nand a blue team satisfying the above requirements, modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line of input contains a single integer $N.$\n\nThe next $N$ lines of input each contain two space-separated integers $x_i$ and\n$y_i$. It is guaranteed that the $x_i$ form a permutation of $1\\dots N$, and\nsame for the $y_i$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nA single integer denoting the number of ways to pick a red team and a blue team\nsatisfying the above requirements, modulo $10^9+7$.\n\nSAMPLE INPUT:\n2\n1 2\n2 1\nSAMPLE OUTPUT: \n2\n\nWe can either choose the red team to be cow 1 and the blue team to be cow 2, or\nthe other way around. In either case, we can separate the two teams by a net\n(for example, $x=1.5$).\n\nSAMPLE INPUT:\n3\n1 1\n2 2\n3 3\nSAMPLE OUTPUT: \n10\n\nHere are all ten possible ways to place the cows on teams; the $i$th character\ndenotes the team of the $i$th cow, or . if the $i$th cow is not on a team.\n\n\nRRB\nR.B\nRB.\nRBB\n.RB\n.BR\nBRR\nBR.\nB.R\nBBR\n\nSAMPLE INPUT:\n3\n1 1\n2 3\n3 2\nSAMPLE OUTPUT: \n12\n\nHere are all twelve possible ways to place the cows on teams:\n\n\nRRB\nR.B\nRBR\nRB.\nRBB\n.RB\n.BR\nBRR\nBR.\nBRB\nB.R\nBBR\n\nSAMPLE INPUT:\n40\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n8 8\n9 9\n10 10\n11 11\n12 12\n13 13\n14 14\n15 15\n16 16\n17 17\n18 18\n19 19\n20 20\n21 21\n22 22\n23 23\n24 24\n25 25\n26 26\n27 27\n28 28\n29 29\n30 30\n31 31\n32 32\n33 33\n34 34\n35 35\n36 36\n37 37\n38 38\n39 39\n40 40\nSAMPLE OUTPUT: \n441563023\n\nMake sure to output the answer modulo $10^9+7$.\n\nSCORING:\nInput 5: $N\\le 10$Inputs 6-9: $N\\le 200$Inputs 10-13: $N\\le 3000$Inputs 14-24: No additional constraints.\n\n\nProblem credits: Dhruv Rohatgi\n", "num_tests": 24, "solution": "\n(Analysis by  Dhruv Rohatgi )\nThe goal of this problem is to count the number of disjoint, non-empty subsets\nof cows $S, T \\subset [n]$ so that there exists a horizontal or vertical line\nseparating the cows in $S$ from the cows in $T$. By a brute force search, it's\nclear that we can enumerate such $S,T$ in time $O(n \\cdot 3^n)$, which solves\nthe first subtask. Of course, we would like to do better.\n To get $O(n^3)$:  Let's start by counting the number of ways to pick\nsets that admit a horizontal separation, where $S$ is to the left of $T$ (the\nmirror-image case is the same). We can sort the cows in lexicographical order\n(first by $x$-coordinate, then tie-break by $y$-coordinate). For each cow $i$,\nlet's count the number of ways to pick the sets so that $i$ is the\n(lexicographically) last cow in $S$. This is exactly $2^a (2^b-1)$, where $a$ is\nthe number of cows that come earlier in the lexicographical order, and $b$ is\nthe number of cows with strictly larger $x$-coordinate than $i$. After sorting,\nwe can easily compute these quantities for each cow in total time $O(n)$.\nThis gives us the number of ways to pick teams separated by a horizontal line,\nand we can of course do the same for teams separated by a vertical line. The\nissue (and the main difficulty of this problem) is in correcting for the\ndouble-counting: there are some pairs of teams $S, T$ that are separated by both\na horizontal and a vertical line.\nAs before, let's specialize the problem a little. We'll start by considering the\nnumber of pairs $S,T$ so that $S$ is above and to the left of $T$ (i.e. all cows\nin $S$ have smaller $x$-coordinate and larger $y$-coordinate than all cows in\n$T$). The other cases are similar, and there is crucially no over-counting\nbetween these cases, since $S,T$ are required to be both non-empty. Fix a cow\n$i$ at position $(x_i,y_i)$; we would like to count the number of sets $S,T$ so\nthat $i$ is the final cow in $S$ (by the lexicographical ordering), and all cows\nin $T$ have $x$-coordinate larger than $\\max_{j \\in S} x_j$ (which equals $x_i$)\nand $y$-coordinate smaller than $\\min_{j \\in S} y_j$ (which may be equal to\n$y_i$ or may be smaller).\nLet's define a function $F_i$ where $F_i(y)$ is the number of sets $S,T$ so that\n$i$ is the final cow in $S$, and $\\min_{j \\in T} x_j > x_i$, and\n$y = \\min_{j \\in S} y_j > \\max_{j \\in T} y_j$. Ultimately we would like to\ncompute $\\sum_i \\sum_y F_i(y)$.\nWhat is $F_i(y)$? If $y > y_i$, then of course $F_i(y) = 0$. If $y = y_i$, then\n$F_i(y) = 2^{a_i(y)} (2^{b_i(y)}-1)$, where $a_i(y)$ is the number of cows $j$\nthat precede $i$ in lexicographical order and also satisfy $y_j \\geq y$, and\n$b_i(y)$ is the number of cows $j$ with $x_j > x_i$ and $y_j < y$. And if\n$y < y_i$, then $F_i(y) = (2^{a_i(y)} - 2^{a_i(y+1)})(2^{b_i(y)}-1)$.\nFor any fixed $i$ and $y$, we can easily compute $a_i(y)$ and $b_i(y)$ in time\n$O(n)$ time. This lets us compute $\\sum_i \\sum_y F_i(y)$ in $O(n^3)$ time.\n To get $O(n^2)$:  We can improve the above algorithm to quadratic time\nby observing that for each $y$, we can compute $a_i(y)$ for all $i$ in a single\nsweep through the cows in lexicographical order (and similarly for $b_i(y)$).\n To get $O(n \\log n)$:  This is somewhat harder, since we no longer have\nenough time to explicitly compute $F_i(y)$ for each $(i,y)$. Instead, we'll\ncompute $\\sum_i \\sum_y F_i(y)$ by maintaining the function $F_i$ in a data\nstructure as we iterate $i$ through the cows in lexicographical order, and we'll\nmake sure that the data structure has a way of efficiently summing $F_i$ over\nall $y$.\nLet's define $G_i(y) = 2^{a_i(y) + b_i(y)}$, $H_i(y) = 2^{a_i(y)}$ and\n$I_i(y) = 2^{a_i(y+1) + b_i(y)}$, so that\n$F_i(y) = G_i(y) - H_i(y) + H_i(y+1) - I_i(y)$; we'll separately maintain $G_i$,\n$H_i$, and $I_i$. The goal is to maintain each function in a (lazy update)\nsegment tree that supports range sum queries and range ``multiply by $c$''\nupdates.\nIndeed, this is possible. As we increase $i$, how do $G_i$, $H_i$, and $I_i$\nchange? Going from $i$ to $i+1$, $a_i(y)$ increases by one for each\n$y \\leq y_i$. We can implement this with a range ``multiply by $2$'' update. If\n$x_i = x_{i+1}$, then $b_i$ remains unchanged. Otherwise, for each $j$ with\n$x_j = x_{i+1}$, $b_i(y)$ decreases by one for all $y > y_j$. We can implement\nthis with one range ``divide by $2$'' update for each such $j$ (note that during\nthe sweep, each $j$ causes such an update only once).\nThe total number of range updates is $O(n)$, and for each $i$, we can easily\ncompute $\\sum_y F_i(y)$ after performing a constant number of range sum queries\nfor $G_i$, $H_i$, and $I_i$ on appropriate ranges. With a standard lazy segment\ntree, the overall time complexity is $O(n \\log n)$.\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define MAXN 200005\n#define MOD 1000000007\n#define HALF (1000000008/2)\n#define SEG (1<<18)\n\nint x[MAXN];\nint y[MAXN];\nint cid[MAXN];\nint numx[MAXN];\nint numy[MAXN];\nlong long pow_array[MAXN];\nlong long zpow_array[2*MAXN+1];\n\nint cmp(int a,int b)\n{\n\tif(x[a]!=x[b]) return x[a]<x[b];\n\treturn y[a]>y[b];\n}\n\nlong long G[2*SEG], H[2*SEG], scaleG[2*SEG], scaleH[2*SEG]; //G = 2^{a(y) + b(y)}; H = 2^{a(y)}\nlong long I[2*SEG], scaleI[2*SEG]; //I = 2^{a(y+1) + b(y)}\nint l[2*SEG], r[2*SEG];\n\nvoid init()\n{\n\tfor(int i=SEG;i<2*SEG;i++)\n\t{\n\t\tG[i] = H[i] = I[i] = 1;\n\t\tscaleG[i] = scaleH[i] = scaleI[i] = 0;\n\t\tl[i] = r[i] = i-SEG;\n\t}\n\tfor(int i=SEG-1;i>0;i--)\n\t{\n\t\tG[i] = (G[2*i] + G[2*i+1])%MOD;\n\t\tH[i] = (H[2*i] + H[2*i+1])%MOD;\n\t\tI[i] = (I[2*i] + I[2*i+1])%MOD;\n\t\tscaleG[i] = scaleH[i] = scaleI[i] = 0;\n\t\tl[i] = l[2*i], r[i] = r[2*i+1];\n\t}\n}\n\nvoid push(long long *seg, long long *scale, int i)\n{\n\tif(scale[i] != 0)\n\t{\n\t\tseg[i] = (seg[i] * zpow_array[MAXN+scale[i]])%MOD;\n\t\tif(i<SEG)\n\t\t{\n\t\t\tscale[2*i] += scale[i];\n\t\t\tscale[2*i+1] += scale[i];\n\t\t}\n\t\tscale[i] = 0;\n\t}\n}\n\nint low,high,mult;\n\nvoid updateLeftFast(long long *seg, long long *scale)\n{\n\tint i = 1;\n\tif(r[i] <= high)\n\t{\n\t\tscale[i] += mult;\n\t\treturn;\n\t}\n\twhile(i < SEG)\n\t{\n\t\tpush(seg,scale,i);\n\t\tif(r[2*i] <= high)\n\t\t{\n\t\t\tscale[2*i] += mult;\n\t\t\tpush(seg,scale,2*i);\n\t\t\ti = 2*i+1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpush(seg,scale,2*i+1);\n\t\t\ti = 2*i;\n\t\t}\n\t}\n\tpush(seg,scale,i);\n\twhile(i>1)\n\t{\n\t\ti /= 2;\n\t\tseg[i] = (seg[2*i] + seg[2*i+1])%MOD;\n\t}\n}\n\nvoid updateRightFast(long long *seg, long long *scale)\n{\n\tint i = 1;\n\tif(l[i] >= low)\n\t{\n\t\tscale[i] += mult;\n\t\treturn;\n\t}\n\twhile(i < SEG)\n\t{\n\t\tpush(seg,scale,i);\n\t\tif(l[2*i+1] >= low)\n\t\t{\n\t\t\tscale[2*i+1] += mult;\n\t\t\tpush(seg,scale,2*i+1);\n\t\t\ti = 2*i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpush(seg,scale,2*i);\n\t\t\ti = 2*i+1;\n\t\t}\n\t}\n\tpush(seg,scale,i);\n\twhile(i>1)\n\t{\n\t\ti /= 2;\n\t\tseg[i] = (seg[2*i] + seg[2*i+1])%MOD;\n\t}\n}\n\nlong long getSumFast(long long *seg, long long *scale)\n{\n\tint i = 1;\n\tlong long sm = 0;\n\tif(r[i] <= high)\n\t{\n\t\tpush(seg,scale,1);\n\t\treturn seg[i];\n\t}\n\twhile(i < SEG)\n\t{\n\t\tif(r[2*i] <= high)\n\t\t{\n\t\t\tpush(seg,scale,2*i);\n\t\t\tpush(seg,scale,2*i+1);\n\t\t\tsm = (sm + seg[2*i])%MOD;\n\t\t\ti = 2*i+1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpush(seg,scale,2*i);\n\t\t\ti = 2*i;\n\t\t}\n\t}\n\treturn sm;\n}\n\nlong long ans;\nint N;\n\nvoid fix_double_counting()\n{\n\tinit();\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tG[y[i]+1+SEG] = (G[y[i]+1+SEG] * 2)%MOD;\n\t\tI[y[i]+1+SEG] = (I[y[i]+1+SEG] * 2)%MOD;\n\t}\n\tfor(int i=SEG+1;i<2*SEG;i++)\n\t{\n\t\tG[i] = (G[i] * G[i-1])%MOD;\n\t\tI[i] = (I[i] * I[i-1])%MOD;\n\t}\n\tfor(int i=SEG-1;i>0;i--)\n\t{\n\t\tG[i] = (G[2*i] + G[2*i+1])%MOD;\n\t\tI[i] = (I[2*i] + I[2*i+1])%MOD;\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(i == 0 || x[cid[i]] > x[cid[i-1]])\n\t\t{\n\t\t\tfor(int j=i;j<N;j++)\n\t\t\t{\n\t\t\t\tif(x[cid[j]]>x[cid[i]]) break;\n\t\t\t\tlow = y[cid[j]]+1, high = N;\n\t\t\t\tmult = -1;\n\t\t\t\tupdateRightFast(G, scaleG);\n\t\t\t\tupdateRightFast(I, scaleI);\n\t\t\t}\n\t\t}\n\t\tlow = 0, high = y[cid[i]];\n\t\tlong long sumF = getSumFast(G, scaleG);\n\t\tif(y[cid[i]] > 0)\n\t\t{\n\t\t\tlow = 0, high = y[cid[i]] - 1;\n\t\t\tsumF = (sumF + MOD - getSumFast(I, scaleI))%MOD;\n\t\t}\n\t\tlow = high = 0;\n\t\tsumF = (sumF + MOD - getSumFast(H, scaleH))%MOD;\n\t\tans = (ans + MOD - sumF)%MOD;\n\t\tlow = 0, high = y[cid[i]];\n\t\tmult = 1;\n\t\tupdateLeftFast(G, scaleG);\n\t\tupdateLeftFast(H, scaleH);\n\t\tif(y[cid[i]]>0)\n\t\t{\n\t\t\tlow = 0, high = y[cid[i]]-1;\n\t\t\tupdateLeftFast(I, scaleI);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\tx[i]--, y[i]--;\n\t\tnumx[x[i]]++, numy[y[i]]++;\n\t\tcid[i] = i;\n\t}\n\tpow_array[0] = 1;\n\tfor(int i=1;i<MAXN;i++)\n\t\tpow_array[i] = (2LL * pow_array[i-1])%MOD;\n\tzpow_array[MAXN] = 1;\n\tfor(int i=MAXN+1;i<=2*MAXN;i++) zpow_array[i] = (zpow_array[i-1] * 2)%MOD;\n\tfor(int i=MAXN-1;i>=0;i--) zpow_array[i] = (zpow_array[i+1] * HALF)%MOD;\n\tsort(cid,cid+N,cmp);\n\tfor(int i=0;i<N;i++) // Count horizontally separable teams\n\t\tans = (ans + pow_array[i] * (pow_array[N-i-numx[x[i]]] + MOD - 1))%MOD;\n\tfor(int i=0;i<N;i++) // Count vertically separable teams\n\t\tans = (ans + pow_array[i] * (pow_array[N-i-numy[y[i]]] + MOD - 1))%MOD;\n\tfix_double_counting(); // Fix double-counting where first team is left & above second team\n\tfor(int i=0;i<N;i++)\n\t\tx[i] = N-1-x[i];\n\tsort(cid,cid+N,cmp);\n\tfix_double_counting(); // Fix double-counting where first team is right & above second team\n\tans = (ans * 2)%MOD; // Account for red/blue symmetry\n\tprintf(\"%d\\n\",ans);\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1377_gold_walking_in_manhattan": {"name": "Walking in Manhattan", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1377", "test_data_link": "http://www.usaco.org/current/data/prob1_gold_jan24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob1_gold_jan24.html", "contest_link": "http://www.usaco.org/index.php?page=jan24results", "inner_contest_link": null, "problem_level": "gold", "cp_id": "1377", "problem_id": "1377_gold_walking_in_manhattan", "description": "\nFarmer John and his $Q$ ($1 \\leq Q \\leq 2 \\cdot 10^5$) cows are in Manhattan on\nvacation, but the cows have escaped and are now walking around freely in the\ncity! Manhattan is huge \u00e2\u20ac\u201c so huge that its $N$ ($1 \\le N \\le 2 \\cdot 10^5$)\nroads stretch infinitely in the $x$-$y$ plane, but conveniently, those roads all\nrun perfectly horizontally or vertically. Each horizontal and vertical road can\nbe modeled by an equation of the form $y = c_i$ or $x = c_i$, where $c_i$ is an\ninteger in the range $0$ to $10^9$ inclusive.\n\nFarmer John knows exactly where each cow started walking and how long ago they\nescaped. Cows are very predictable, so each of them walks according to the\nfollowing pattern:\nThey only walk north ($+y$) or east ($+x$) at one unit per second.If they are currently on a single road, they continue walking along the\nroad's direction.If they are at the intersection of two roads, they\nwalk north if they have been walking for an even number of seconds and east\notherwise.\nGiven the layout of Manhattan and the information for each cow, help Farmer John\ndetermine where his cows are now!\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$ and $Q$.\n\nThe next $N$ lines describe the roads. Each road is described by a direction (H\nor V) and a coordinate $c_i$. It is guaranteed that the roads are unique.\n\nThe next $Q$ lines describe the cows. Each cow is described by three integers\n$(x_i, y_i, d_i)$, meaning that they started walking from $(x_i, y_i)$ exactly\n$d_i$ seconds ago. It is guaranteed that $(x_i, y_i)$ lies on some road, and\n$0 \\le x_i, y_i, d_i \\le 10^9$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput $Q$ lines, where the $i$th line contains the current position of the\n$i$th cow.\n\nSAMPLE INPUT:\n4 5\nV 7\nH 4\nH 5\nV 6\n6 3 10\n6 4 10\n6 5 10\n6 6 10\n100 4 10\nSAMPLE OUTPUT: \n14 5\n7 13\n6 15\n6 16\n110 4\n\nThe first two cows took the following paths:\n\n\n(6, 3) -> (6, 4) -> (7, 4) -> (7, 5) -> (8, 5) -> ... -> (14, 5)\n(6, 4) -> (6, 5) -> (7, 5) -> (7, 6) -> ... -> (7, 13)\n\nSCORING:\nInputs 2-4 satisfy $N, Q, c_i, x_i, y_i, d_i \\leq 100$.Inputs 5-9 satisfy\n$N, Q\\le 3000$.Inputs 10-20 satisfy no additional constraints.\n\n\nProblem credits: Benjamin Qi\n", "num_tests": 20, "solution": "\n(Analysis by Danny Mittal)\nSubtask 1 (all numbers in input are at most $100$)\nWe can simply simulate the process. There are $Q \\leq 100$ queries to test, each\nof which involves walking at most $d_i \\leq 100$ units, and for each unit we\nwalk we can determine the direction we walk by keeping track of the time and\nchecking through all $N \\leq 100$ roads to see which ones we are on. This is\n$100^3 = 10^6$ checks which runs well in time.\nSubtask 2 ($N, Q \\leq 3000$)\nWe can simulate the process more efficiently. Instead of walking one unit at a\ntime, we can walk until we reach a new cross street.\nTo do this we will first create a sorted list of each type of road, then for\neach query determine our starting position among each sorted list. For each step\nwe look in the sorted list corresponding to the direction that we are not\ncurrently walking in and check the position of the following element, which\ntells us how far we walk before potentially changing our direction. We can then\nupdate our direction based on the time.\nAs there are at most $N$ roads, it takes $O(N\\lg N)$ time to create the sorted\nlists. For each query it then takes $O(N)$ time to find our initial position in\neach list and each subsequent step increases our position in one of the lists,\nmeaning that the number of steps is $O(N)$. The time complexity of this solution\nis therefore $O(N(\\lg N + Q))$ which is fast enough.\nFull solution\nBecause John walks one unit per second, the amount of time has been walking is\nequal to the distance that he has walked. This means that what direction he goes\nnext at an intersection depends on the parity of the distance he has walked thus\nfar. That distance in turn simply depends on his current position and his\nstarting position. Specifically, if he started at $(x, y)$ and is now at\n$(a, b)$, then he has walked $(a - x) + (b - y)$ units, meaning that what\ndirection he goes next depends on the parity of $(a - x) + (b - y)$.\nFor each query, $x + y$ is either even or odd. We can assume that it is even,\nand simply reproduce everything below analogously to handle the case where it is\nodd.\nIf $x + y$ is even, then the parity of $(a - x) + (b - y)$ is equal to the\nparity of $a + b$. This means that which direction we go at an intersection\ndepends only on the position of the intersection itself.\nConsider separating the vertical roads into those located at even and odd\n$x$-coordinates, and similarly separating the horizontal roads into those\nlocated at even and odd $y$-coordinates. If John is currently walking on a\nvertical road with even $x$-coordinate, and encounters a horizontal road with an\neven $y$-coordinate, then his current position will have even $a + b$, meaning\nthat he will always walk north in such a case. On the other hand, if he\nencounters a horizontal road with odd $y$-coordinate, he will switch to walking\neast from that intersection.\nThus, if Farmer John is currently walking on a vertical road with even\n$x$-coordinate, he will walk until the first horizontal road he finds with odd\n$y$-coordinate, then start walking on that road. Similarly, he will walk on that\nroad until the first vertical road with odd $x$-coordinate, and then walk\non that road until the first horizontal road with even\n$y$-coordinate, which he then walks on until the first vertical road with even\n$x$-coordinate.\nIn this way Farmer John cycles through the four types of roads. This structure\nhas two useful properties:\nJohn alternates between vertical and horizontal roadsIf John is\ncurrently on a vertical road, the next vertical road he walks on will have the\nopposite parity, and it will be the earliest such road (and same for horizontal\nroads)\nThis suggests that we create a list of each type of road that doesn't contain\nall such roads, but rather works as follows. The first road in each list is\nsimply the earliest (farthest southwest) road of each type, but every following\nroad is the first road after the current one that's of the opposite parity.\nGiven this, if John is currently at an intersection of two roads that are both\nin their respective lists, then he will always be on roads on the list because\nof the second property mentioned above. This means that if we assume that John\nends up walking a certain amount of total roads, we can use the first property\nto determine how many of each road he walks on and which direction he is walking\nin at the end, then use the list to lookup the last roads he walks on. The\ndifference in the positions of those roads and the roads he begins on tells us\nthe distance he travelled in each direction to get to that point.\nWe can then binary search the amount of roads he walks on, checking that he\ndoesn't travel too far to get to that last intersection and that the\nintersection of the following pair of roads is sufficiently far away. After\ncompleting that binary search, that last intersection, combined with the\ndirection he ends up in, will tell us the total distance he travels in each\ndirection.\nFinally, note that this requires Farmer John to start at the intersection of two\nroads in the lists; he doesn't necessarily start at an intersection or at a road\non the list, but because of the second property we know that the second time he\nwalks on a certain type of road it'll be in the list, so we can use the strategy\nof subtask 2 to walk him through four roads, at which point he'll be at such an\nintersection.\nThis solution requires $O(N\\lg N)$ precomputation to create both the lists for\nsubtask 2 and the lists used in the binary search, then requires an $O(\\lg N)$\nbinary search for each query, making the runtime complexity $O((N + Q)\\lg N)$\nwhich is fast enough.\nMy Java code:\n\nimport java.util.*;\n \npublic class WalkingInManhattan {\n \n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int q = in.nextInt();\n        TreeSet<Integer> verticalRoads = new TreeSet<>();\n        TreeSet<Integer> horizontalRoads = new TreeSet<>();\n        for (; n > 0; n--) {\n            if (in.next().equals(\"V\")) {\n                verticalRoads.add(in.nextInt());\n            } else {\n                horizontalRoads.add(in.nextInt());\n            }\n        }\n \n        List<Integer> mainVerticalRoads = new ArrayList<>();\n        TreeMap<Integer, Integer> mainVerticalRoadsTreeSet = new TreeMap<>();\n        for (int x : verticalRoads) {\n            if (mainVerticalRoads.isEmpty() || mainVerticalRoads.get(mainVerticalRoads.size() - 1) % 2 != x % 2) {\n                mainVerticalRoadsTreeSet.put(x, mainVerticalRoadsTreeSet.size());\n                mainVerticalRoads.add(x);\n            }\n        }\n        List<Integer> mainHorizontalRoads = new ArrayList<>();\n        TreeMap<Integer, Integer> mainHorizontalRoadsTreeSet = new TreeMap<>();\n        for (int y : horizontalRoads) {\n            if (mainHorizontalRoads.isEmpty() || mainHorizontalRoads.get(mainHorizontalRoads.size() - 1) % 2 != y % 2) {\n                mainHorizontalRoadsTreeSet.put(y, mainHorizontalRoadsTreeSet.size());\n                mainHorizontalRoads.add(y);\n            }\n        }\n \n        StringBuilder out = new StringBuilder();\n        for (; q > 0; q--) {\n            int x = in.nextInt();\n            int y = in.nextInt();\n            int d = in.nextInt();\n \n            int parity = (x + y) % 2;\n \n            boolean startsNorth = verticalRoads.contains(x);\n \n            if (!startsNorth) {\n                Integer initialVerticalRoad = verticalRoads.ceiling(x);\n                if (initialVerticalRoad != null && (initialVerticalRoad + y) % 2 != parity) {\n                    initialVerticalRoad = mainVerticalRoadsTreeSet.higherKey(initialVerticalRoad);\n                }\n                if (initialVerticalRoad == null || initialVerticalRoad - x > d) {\n                    answer(out, x + d, y);\n                    continue;\n                }\n                d -= initialVerticalRoad - x;\n                x = initialVerticalRoad;\n            }\n \n            Integer initialHorizontalRoad = horizontalRoads.ceiling(y);\n            if (initialHorizontalRoad != null && (initialHorizontalRoad + x) % 2 == parity) {\n                initialHorizontalRoad = mainHorizontalRoadsTreeSet.higherKey(initialHorizontalRoad);\n            }\n            if (initialHorizontalRoad == null || initialHorizontalRoad - y > d) {\n                answer(out, x, y + d);\n                continue;\n            }\n            d -= initialHorizontalRoad - y;\n            y = initialHorizontalRoad;\n \n            Map.Entry<Integer, Integer> firstVerticalRoad = mainVerticalRoadsTreeSet.higherEntry(x);\n            if (firstVerticalRoad == null || firstVerticalRoad.getKey() - x > d) {\n                answer(out, x + d, y);\n                continue;\n            }\n            d -= firstVerticalRoad.getKey() - x;\n            x = firstVerticalRoad.getKey();\n            \n            Map.Entry<Integer, Integer> firstHorizontalRoad = mainHorizontalRoadsTreeSet.higherEntry(y);\n            if (firstHorizontalRoad == null || firstHorizontalRoad.getKey() - y > d) {\n                answer(out, x, y + d);\n                continue;\n            }\n            d -= firstHorizontalRoad.getKey() - y;\n            y = firstHorizontalRoad.getKey();\n            \n \n            int verticalBaseline = firstVerticalRoad.getValue();\n            int horizontalBaseline = firstHorizontalRoad.getValue();\n \n            int upper = mainVerticalRoads.size() + mainHorizontalRoads.size();\n            int lower = 0;\n            while (upper > lower) {\n                int mid = (upper + lower + 1) / 2;\n \n                int verticalEnd = verticalBaseline + ((mid + 1) / 2);\n                int horizontalEnd = horizontalBaseline + (mid / 2);\n                if (verticalEnd >= mainVerticalRoads.size() || horizontalEnd >= mainHorizontalRoads.size()) {\n                    upper = mid - 1;\n                } else {\n                    int distance = (mainVerticalRoads.get(verticalEnd) - x) + (mainHorizontalRoads.get(horizontalEnd) - y);\n                    if (distance > d) {\n                        upper = mid - 1;\n                    } else {\n                        lower = mid;\n                    }\n                }\n            }\n \n            int verticalEnd = verticalBaseline + ((upper + 1) / 2);\n            int horizontalEnd = horizontalBaseline + (upper / 2);\n            int answerX = mainVerticalRoads.get(verticalEnd);\n            int answerY = mainHorizontalRoads.get(horizontalEnd);\n            int extra = d - (answerX - x) - (answerY - y);\n            if (upper % 2 == 0) {\n                answerX += extra;\n            } else {\n                answerY += extra;\n            }\n            answer(out, answerX, answerY);\n        }\n        System.out.print(out);\n    }\n \n    public static void answer(StringBuilder out, int x, int y) {\n        out.append(x).append(' ').append(y).append('\\n');\n    }\n}\n\nBrandon Wang's C++ code:\n\n#include <algorithm>\n#include <iostream>\n \nconst int MAXN = 200005;\nconst int MAXL = 18;\nconst int INFTY = 2e9+7;\n \nint N, Q;\nint H, V;\nint horiz[MAXN];\nint vert[MAXN];\nint hn[MAXN][MAXL];\nint vn[MAXN][MAXL];\n \nvoid input () {\n\tstd::cin >> N >> Q;\n\twhile (N--) {\n\t\tchar c; int x;\n\t\tstd::cin >> c >> x;\n\t\tif (c == 'H') {\n\t\t\thoriz[H] = x;\n\t\t\tH++;\n\t\t}\n\t\telse {\n\t\t\tvert[V] = x;\n\t\t\tV++;\n\t\t}\n\t}\n}\n \nvoid proc () {\n\tstd::sort(horiz, horiz+H);\n\tstd::sort(vert, vert+V);\n\thoriz[H] = INFTY;\n\tvert[V] = INFTY;\n\tfor (int i = 0; i < MAXL; i++) {\n\t\thn[H][i] = H;\n\t\tvn[V][i] = V;\n\t}\n \n\tfor (int i = H-1; i >= 0; i--) {\n\t\tif (horiz[i]%2 != horiz[i+1]%2) {\n\t\t\thn[i][0] = i+1;\n\t\t}\n\t\telse {\n\t\t\thn[i][0] = hn[i+1][0];\n\t\t}\n\t\tfor (int t = 1; t < MAXL; t++) {\n\t\t\thn[i][t] = hn[hn[i][t-1]][t-1];\n\t\t}\n\t}\n \n\tfor (int i = V-1; i >= 0; i--) {\n\t\tif (vert[i]%2 != vert[i+1]%2) {\n\t\t\tvn[i][0] = i+1;\n\t\t}\n\t\telse {\n\t\t\tvn[i][0] = vn[i+1][0];\n\t\t}\n\t\tfor (int t = 1; t < MAXL; t++) {\n\t\t\tvn[i][t] = vn[vn[i][t-1]][t-1];\n\t\t}\n\t}\t\n}\n \nstd::pair<int, int> query (int x, int y, int d) {\n\tint hlo = 0, hhi = H;\n\twhile (hlo < hhi) {\n\t\tint hmi = (hlo + hhi) / 2;\n\t\tif (horiz[hmi] >= y) {\n\t\t\thhi = hmi;\n\t\t}\n\t\telse {\n\t\t\thlo = hmi + 1;\n\t\t}\n\t}\n\tint vlo = 0, vhi = V;\n\twhile (vlo < vhi) {\n\t\tint vmi = (vlo + vhi) / 2;\n\t\tif (vert[vmi] >= x) {\n\t\t\tvhi = vmi;\n\t\t}\n\t\telse {\n\t\t\tvlo = vmi + 1;\n\t\t}\n\t}\n\tint t = 0;\n\tif (y < horiz[hlo]) {\n\t\tif (d + y <= horiz[hlo]) {\n\t\t\treturn {x, d+y};\n\t\t}\n\t\td -= (horiz[hlo] - y);\n\t\tt += horiz[hlo] - y;\n\t}\n\tif (x < vert[vlo]) {\n\t\tif (d + x <= vert[vlo]) {\n\t\t\treturn {d+x, y};\n\t\t}\n\t\td -= (vert[vlo] - x);\n\t\tt += vert[vlo] - x;\n\t}\n\tfor (int k = MAXL-1; k >= 0; k--) {\n\t\tint h = hn[hlo][k], v = vn[vlo][k];\n\t\tif (horiz[h] - horiz[hlo] > d) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vert[v] - vert[vlo] > d) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ((vert[v] - vert[vlo]) + (horiz[h] - horiz[hlo]) > d) {\n\t\t\tcontinue;\n\t\t}\n\t\td -= (vert[v] - vert[vlo]) + (horiz[h] - horiz[hlo]);\n\t\tt += (vert[v] - vert[vlo]) + (horiz[h] - horiz[hlo]);\n\t\thlo = h;\n\t\tvlo = v;\n\t}\n\tif (t%2) {\n\t\tint v = vn[vlo][0];\n\t\tif (vert[v] - vert[vlo] >= d) {\n\t\t\treturn {vert[vlo] + d, horiz[hlo]};\n\t\t}\n\t\td -= (vert[v] - vert[vlo]);\n\t\treturn {vert[v], horiz[hlo]+d};\n\t}\n\tint h = hn[hlo][0];\n\tif (horiz[h] - horiz[hlo] >= d) {\n\t\treturn {vert[vlo], horiz[hlo]+d};\n\t}\n\td -= (horiz[h] - horiz[hlo]);\n\treturn {vert[vlo]+d, horiz[h]};\n}\n \nint main () {\n\tinput();\n\tproc();\n\twhile (Q--) {\n\t\tint x, y, d; std::cin >> x >> y >> d;\n\t\tstd::pair<int,int> pi = query(x, y, d);\n\t\tstd::cout << pi.first << \" \" << pi.second << \"\\n\";\n\t}\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1378_gold_cowmpetency": {"name": "Cowmpetency", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1378", "test_data_link": "http://www.usaco.org/current/data/prob2_gold_jan24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob2_gold_jan24.html", "contest_link": "http://www.usaco.org/index.php?page=jan24results", "inner_contest_link": null, "problem_level": "gold", "cp_id": "1378", "problem_id": "1378_gold_cowmpetency", "description": "\nFarmer John is hiring a new herd leader for his cows. To that end, he has\ninterviewed $N$ ($2 \\leq N \\leq 10^9$) cows for the position. After each\ninterview, he assigned an integer \"cowmpetency\" score to the candidate ranging from $1$\nto $C$ ($1 \\leq C \\leq 10^4$) that is correlated with their leadership\nabilities.\n\nBecause he has interviewed so many cows, Farmer John has forgotten all of their\ncowmpetency scores. However, he does remembers $Q$\n($1 \\leq Q \\leq \\min(N - 1, 100)$) pairs of numbers $(a_i, h_i)$ where cow $h_i$\nwas the first cow with a strictly greater cowmpetency score than cows $1$\nthrough $a_i$ (so\n$1 \\leq a_i < h_i \\leq N$).\n\nFarmer John now tells you the $Q$ pairs of $(a_i, h_i)$. Help him count how many\nsequences of cowmpetency scores are consistent with this information! It is\nguaranteed that there is at least one such sequence. Because this number may be\nvery large, output its value modulo $10^9 + 7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$, $Q$, and $C$.\n\nThe next $Q$ lines each contain a pair $(a_i, h_i)$. It is guaranteed that all\n$a_j$ are distinct.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe number of sequences of cowmpetency scores consistent with what Farmer John\nremembers, modulo $10^9+7$.\n\nSAMPLE INPUT:\n6 2 3\n2 3\n4 5\nSAMPLE OUTPUT: \n6\n\nThe following six sequences are the only ones consistent with what Farmer John\nremembers:\n\n\n1 1 2 1 3 1\n1 1 2 1 3 2\n1 1 2 1 3 3\n1 1 2 2 3 1\n1 1 2 2 3 2\n1 1 2 2 3 3\n\nSAMPLE INPUT:\n10 1 20\n1 3\nSAMPLE OUTPUT: \n399988086\n\nMake sure to output the answer modulo $10^9+7$.\n\nSCORING:\nInputs 3-4 satisfy $N \\leq 10$ and $Q, C \\leq 4$.Inputs 5-7\nsatisfy $N, C \\leq 100$.Inputs 8-10 satisfy $N \\leq 2000$ and\n$C \\leq 200$.Inputs 11-15 satisfy $N, C \\leq 2000$.Inputs\n16-20 satisfy no additional constraints.\n\n\nProblem credits: Suhas Nagar\n", "num_tests": 20, "solution": "\n(Analysis by Suhas Nagar and Andi Qu)\nLet $c_i$ be the $i$-th cowmpetency value in the sequence. We can think of each\n$c_i$ as a free variable (i.e., we can adjust its value as we see fit) and each\npair $(a_i, h_i)$ as a constraint on the free variables. Specifically, each\nconstraint dictates that:\n$$\n\\max_{a_i < k < h_i}(c_k) \\le \\max_{k \\le a_i}(c_k) < c_{h_i}\n$$\nSubtask 1: $O(NQC^N)$\nFor this subtask, it works to iterate over all $C^N$ sequences and check each\none against the list of constraints.\nSubtasks 2 and 3: $O(NC^2)$\nLike many other problems involving counting something modulo a large number,\nthis problem's full solution involves dynamic programming (DP). Let $dp[i][j]$\nbe the number of ways to satisfy the constraints when you only consider the\nfirst $i$ cows and have\n$\\max_{k \\le i}(c_k) = j$.\nThere are two different contributions to $dp[i][j]$:\n\nCase 1: $c_i \\le \\max_{k < i}(c_k) \\implies c_i \\le j$. This case is only\npossible if no constraint has $h_k = i$. If so, there are $j$ options for $c_i$\nin this case, so this case contributes $j \\cdot dp[i - 1][j]$.\n\nCase 2: $c_i > \\max_{k < i}(c_k) \\implies c_i = j$. This case is only\npossible if no constraint has $a_k \\le i < h_k$. If so, there is $1$ option for\n$c_i$ in this case, so this case contributes $\\sum_{k = 1}^{j - 1} dp[i - 1][k]$.\n\nComputing these two contributions naively takes $O(C)$ time for each $dp[i][j]$,\nso this approach runs in $O(NC^2)$ time overall. Slower solutions that run in\n$O(NC(C + Q))$ time may also pass both subtasks, but more likely pass only\nSubtask 2.\nPython code:\n\nMOD = int(1e9 + 7)\nn, q, c = map(int, input().split())\n\ni_start = [False for i in range(n + 1)]\ni_end = [False for i in range(n + 1)]\nfor i in range(q):\n    a, h = map(int, input().split())\n    i_start[a] = True\n    i_end[h] = True\n\ndp = [[0 for j in range(c + 1)] for i in range(n + 1)]\ndp[0][0] = 1\nrestrict = False\nfor i in range(1, n + 1):\n    if i_end[i]:\n        restrict = False\n    for j in range(1, c + 1):\n        if not i_end[i]:\n            dp[i][j] = j * dp[i - 1][j] % MOD\n        if not restrict:\n            for k in range(j):\n                dp[i][j] += dp[i - 1][k]\n                if dp[i][j] >= MOD:\n                    dp[i][j] -= MOD\n    if i_start[i]:\n        restrict = True\n\nprint(sum(dp[n]) % MOD)\n\nSubtask 4: $O(NC)$\nWe can speed up the above solution by using a prefix sum array to compute Case\n2. This optimization improves the time complexity by a factor of\n$C$.\nPython code:\n\nMOD = int(1e9 + 7)\nn, q, c = map(int, input().split())\n\ni_start = [False for i in range(n + 1)]\ni_end = [False for i in range(n + 1)]\nfor i in range(q):\n    a, h = map(int, input().split())\n    i_start[a] = True\n    i_end[h] = True\n\ndp = [[0 for j in range(c + 1)] for i in range(n + 1)]\npref = [[0 for j in range(c + 1)] for i in range(n + 1)]\ndp[0][0] = 1\npref[0] = [1 for j in range(c + 1)]\nrestrict = False\nfor i in range(1, n + 1):\n    if i_end[i]:\n        restrict = False\n    for j in range(1, c + 1):\n        if not i_end[i]:\n            dp[i][j] = j * dp[i - 1][j] % MOD\n        if not restrict:\n            dp[i][j] += pref[i - 1][j - 1]\n            if dp[i][j] >= MOD:\n                dp[i][j] -= MOD\n    pref[i][0] = dp[i][0]\n    for j in range(1, c + 1):\n        pref[i][j] = pref[i][j - 1] + dp[i][j]\n        if pref[i][j] >= MOD:\n            pref[i][j] -= MOD\n    if i_start[i]:\n        restrict = True\n\nprint(pref[n][c])\n\nFull Credit: $O(QC \\log N)$\nConsider each constraint $(a_i, h_i)$ as a range $[a_i, h_i - 1]$ on a number\nline. Because the problem guarantees that the number of valid sequences is not\n$0$, two of these ranges (say $i$ and $j$) can intersect only if $h_i = h_j$.\nFor any two such intersecting ranges, only the one with the smaller $a$ value\naffects the answer.\nFrom this observation, the list of constraints splits the sequence into $Q$\ndisjoint ranges. Because each free variable in a given range is essentially\nidentical, we can compute the answer more efficiently by iterating over\nconstraints (after sorting them) instead of cows.\nNow, let $dp[i][j]$ be the number of ways to satisfy up to the first $i$\nconstraints and have $c_{h_i} = j$. Additionally, let $w_i$ be the number of\nfree variables in constraint $i$'s range, and $u_i$ be the number of free\nvariables between constraint $i$'s range and constraint $i - 1$'s range.\nThere are three different contributions to $dp[i][j]$:\nCase 1: Any sequence counted in $dp[i][j-1]$ can also count toward\n$dp[i][j]$ by changing $c_{h_i}$ from $j-1$ to $j$. \n\nCase 2: Any sequence counted in $dp[i-1][j-1]$ can also count toward\n$dp[i][j]$ if all $w_i + u_i$ free variables under consideration are assigned\nvalues between $1$ to $j-1$.\n\nCase 3: Any sequence counted in $dp[i-1][k]$ where $k < j-1$ can also\ncount toward $dp[i][j]$ if at least one of the $w_i$ free variables in\nconstraint $i$'s range is equal to $j - 1$ and the rest are no more than\n$j - 1$. There are $((j-1)^{w_i} - (j-2)^{w_i}) \\cdot j^{u_i}$ ways to do this\nassignment.\n\nPutting it all together, our DP recurrence is:\n$$dp[i][j] = dp[i][j-1]+dp[i-1][j-1] \\cdot (j-1)^{w_i+u_i}+\\sum_{k = 0}^{j-2} dp[i-1][k] \\cdot ((j-1)^{w_i}-(j-2)^{w_i}) \\cdot j^{u_i}$$\nWe can compute each term in $O(\\log N)$ time using a running sum and\n binary\nexponentiation.\nPython code:\n\nMOD = int(1e9 + 7)\n\n\ndef expo(base, pow):\n    if pow == 0:\n        return 1\n    x = expo(base * base % MOD, pow // 2)\n    return base * x % MOD if pow % 2 == 1 else x\n\n\nn, q, c = map(int, input().split())\n\npairs_dict = {0: 0}\nfor i in range(q):\n    a, h = map(int, input().split())\n    pairs_dict[h] = min(a, pairs_dict.get(h, h))\npairs = sorted((a, h) for h, a in pairs_dict.items())\nq = len(pairs_dict) - 1\n\ndp = [[0 for j in range(c + 1)] for i in range(q + 1)]\ndp[0][0] = 1\nfor i in range(1, q + 1):\n    gap1 = pairs[i][0] - pairs[i - 1][1]\n    gap2 = pairs[i][1] - pairs[i][0] - 1\n    pref_sum = 0\n    for j in range(1, c + 1):\n        dp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 1] * expo(j - 1, gap1 + gap2) +\n                    pref_sum * (expo(j - 1, gap1) - expo(j - 2, gap1)) * expo(j - 1, gap2)) % MOD\n        pref_sum = (pref_sum + dp[i - 1][j - 1]) % MOD\n\nprint(sum(dp[q]) * expo(c, n - pairs[q][1]) % MOD)\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1379_gold_nap_sort": {"name": "Nap Sort", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1379", "test_data_link": "http://www.usaco.org/current/data/prob3_gold_jan24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob3_gold_jan24.html", "contest_link": "http://www.usaco.org/index.php?page=jan24results", "inner_contest_link": null, "problem_level": "gold", "cp_id": "1379", "problem_id": "1379_gold_nap_sort", "description": "\nBessie is trying to sort an array of integers using her own sorting algorithm.\nShe has a pile of $N$ $(1 \\leq N \\leq 2\\cdot 10^5)$ integers $a_1,a_2,\\dots,a_N$\n$(1 \\leq a_i \\leq 10^{11})$ that she will put in a separate array in sorted\norder. She repeatedly finds the minimum integer in her pile, removes it, and\nadds it to the end of the array. It takes Bessie $p$ seconds to find the minimum\ninteger in a pile of $p$ integers.\n\nFarmer John instructed some of the other cows in the farm to help Bessie with\nher task, but they are quite lazy, so Bessie uses that to her advantage. She\ndivides the integers into two piles: Bessie pile and Helper pile. For every\ninteger in Bessie's pile, she performs her algorithm as normal. For every\ninteger in the helper pile, she assigns it to a different helper cow. Farmer\nJohn has a large farm, so Bessie can get as many helper cows as she wants. If a\nhelper receives the integer $a_i$, Bessie instructs that cow to nap for $a_i$\nseconds, and add their integer to the end of the array immediately when they\nwake up. If Bessie and a helper add an integer to the array at the same time,\nBessie's integer will get added first since she is the leader. If more than one\nhelper gets assigned the same integer, they will add copies of that integer to\nthe array at the same time.\n\nHelp Bessie divide her integers so that the final array is sorted and the time\nit takes to sort the array is minimized.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $T$, the number of independent test cases\n($1\\le T\\le 10$). \n\nEach test case is formatted as follows:\n\nThe first line of each test case contains the number of integers $N$ in Bessie's\narray.\n\nThe next line of each test case contains $a_1, a_2, \\dots, a_N$, the integers\nthat Bessie is sorting. The same integer may appear multiple times.\n\nIt is guaranteed that the sum of $N$ over all tests does not exceed\n$2\\cdot 10^5$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor each test case, output the minimum time to sort the array on a new line, if\nBessie divides her integers optimally.\n\nSAMPLE INPUT:\n4\n5\n1 2 4 5 100000000000\n5\n17 53 4 33 44\n4\n3 5 5 5\n6\n2 5 100 1 4 5\nSAMPLE OUTPUT: \n6\n15\n5\n6\n\nIn the first example, Bessie can assign $1,2$ to helpers and leave $4,5,10^{11}$\nfor herself. \n\n\nTime | Event\n-----+----------------------\n1    | Helper adds 1\n2    | Helper adds 2\n3    | Bessie adds 4\n5    | Bessie adds 5\n6    | Bessie adds 10^{11}\n\nIn the second example, the best Bessie can do is sort everything by herself. One\ndivision that does *not* work is for Bessie to assign $4$ to a helper and the\nrest to herself because Bessie will end up adding $17$ to the array before the\nhelper adds $4$ to the array.\n\nIn the third example, Bessie can assign all the integers to helpers.\n\nIn the fourth example, Bessie can assign $1,4,5$ to helpers and leave $2,5,100$\nto herself.\n\n\nTime | Event\n-----+------------------\n1    | Helper adds 1\n3    | Bessie adds 2\n4    | Helper adds 4\n5    | Bessie adds 5\n5    | Helper adds 5\n6    | Bessie adds 100\n\nSCORING:\nInput 2: $N\\le 16$Inputs 3-5: $N\\le 150$Inputs 6-8: $\\sum N\\le 5000$Inputs 9-11: No additional constraints.\n\n\nProblem credits: Suhas Nagar\n", "num_tests": 11, "solution": "\n(Analysis by Benjamin Qi)\nSubtask 1: $O(2^N\\cdot N\\log N)$\nIterate over all $2^N$ ways to split into piles, and check each of them in\n$O(N\\log N)$ time.\nSubtask 2: $O(N^3)$\nFirst, sort the $a_i$ in increasing order ($a_1\\le a_2\\le a_3\\le \\dots\\le a_N$).\nLet $B$ be the size of Bessie's pile. The answer must be at most $a_N$ since we\ncan take $B=0$. If the answer is less than $a_N$, then $a_N$ must be added to\nthe array by Bessie at time $B(B+1)/2$.  Our goal is to find the minimum $B$\nsuch this is possible, and output $\\min(B(B+1)/2, a_N)$ as the answer.\nFor convenience, let's assume that the indices in the Bessie pile are in\nincreasing order ($1\\le b_1 < b_2 < \\dots < b_B\\le N$) and similarly for the\nHelper pile ($1\\le h_1 < h_2 < \\dots < h_{N-B}\\le N$). Then the final array is\ndefined by the following pseudocode.\n\ni_b = 0, i_h = 0\nindex_seq = []\nrepeat(N) {\n  if (i_h == N - B or (i_b < B and sum(B - i_b, B) <= a_{h_{i_h + 1}})) {\n    i_b += 1\n    index_seq.append(b_{i_b})\n  } else {\n    i_h += 1\n    index_seq.append(h_{i_h})\n  }\n}\nfinal_array = [a_i for i in index_seq]\n\nNote that if $\\texttt{index_seq}=[1,2,\\dots,N]$, then the final array is sorted.\nThe converse holds if all $a_i$ are distinct, but not necessarily if there are\nduplicate $a_i$s. However, if we have a division producing a sorted final array\nbut $\\texttt{index_seq}\\neq [1,2,\\dots,N]$, there is always a way to modify the\ndivision such that the time to sort the array remains the same and\n$\\texttt{index_seq}= [1,2,\\dots,N]$. This is true because we can freely take any\ntwo indices $b_i$ and $h_j$ with $a_{b_i}=a_{h_j}$ and exchange them, leaving\nthe final array unchanged but potentially changing  $\\texttt{index_seq}$. The\ndetails are left as an exercise to the reader.\nFor this subtask, we provide an $O(N^2)$ to check whether a given $B$ is\npossible. Given such a checking algorithm, we can iterate from $B=1$ to $B=N$ in\nincreasing order and stop once we find $B$ such that $B$ is possible.\nChecking whether a given $B$ is possible can be done with dynamic programming. \nIterate over each index $i$ in $1\\dots N$ and decide whether to add it to the \nBessie or the Helper pile. The only state we need to keep track of about the\nprevious indices are how many of them are in the Bessie pile, and whether index\n$i-1$ was added to the  Bessie or the Helper pile. Each state has up to two\ntransitions out of it: either add $i$ to the Bessie pile or the Helper pile, as\nlong as $i$ is added to $\\texttt{index_seq}$ after $i-1$.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T> using V = vector<T>;\n#define all(x) begin(x), end(x)\n#define mp make_pair\n\n// sum(l ... r)\nint64_t arith(int64_t l, int64_t r) { return (l + r) * (r - l + 1) / 2; }\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T;\n    cin >> T;\n    while (T--) {\n        int N;\n        cin >> N;\n        vector<int64_t> A(N);\n        for (auto &a : A) cin >> a;\n        sort(all(A));\n        auto possible = [&](int B) {\n            const int H = N - B;\n            vector<vector<array<bool, 2>>> dp(\n                B + 1, vector<array<bool, 2>>(H + 1, {0, 0}));\n            // size of Bessie pile, Helper pile so far\n            // p: {0 -> last was in Bessie pile, 1 -> last was in Helper pile}\n            dp[0][0][0] = 1;\n            for (int b = 0; b <= B; ++b)\n                for (int h = 0; h <= H; ++h)\n                    for (int p : {0, 1})\n                        if (dp[b][h][p]) {\n                            // i = b + h + 1\n                            auto get_last = [&]() {\n                                // time when i-1 was added to array\n                                // (tiebreaking by pile)\n                                return p == 0 ? mp(arith(B + 1 - b, B), 0)\n                                              : mp(A.at(b + h - 1), 1);\n                            };\n                            auto get_next_0 = [&]() {\n                                // time when i will be added to array if in\n                                // Bessie pile\n                                return mp(arith(B - b, B), 0);\n                            };\n                            auto get_next_1 = [&]() {\n                                // time when i will be added to array if in\n                                // Helper pile\n                                return mp(A.at(b + h), 1);\n                            };\n                            if (b < B && get_last() <= get_next_0())\n                                dp[b + 1][h][0] = 1;\n                            if (h < H && get_last() <= get_next_1())\n                                dp[b][h + 1][1] = 1;\n                        }\n            return dp.at(B).at(N - B).at(0);\n            // 0 -> last element must be in Bessie pile\n        };\n        int B = 1;\n        while (!possible(B)) ++B;\n        cout << min(arith(1, B), A.back()) << \"\\n\";\n    }\n}\n\nSubtask 3: $O(N^2)$\nWe provide an $O(N)$ time algorithm to check whether a given $B$ is possible.\n$B=N$ is always possible, so let's restrict consideration to the case $B<N$ (the\nHelper pile is nonempty). Note that for each index $i$, if we choose to place it\nin the Helper pile, then its position is uniquely determined regardless of what\nother indices we place in the Helper pile. Specifically, its position in the\nHelper pile must be \n$$pos_i=i-(\\text{the number of integers in Bessie's pile that would be added before }a_i\\text{ is added by a Helper})$$\nin order for $i$ to be the $i$th index added to $\\texttt{index_seq}$. Then $B$\nis possible iff there exist indices $1\\le h_1<h_2<\\dots < h_{N-B} < N$ such that\n$pos_{h_1}=1, pos_{h_2}=2, \\dots, pos_{h_{N-B}}=N-B$. We can compute $pos_i$ in\nincreasing order of $i$ in $O(N)$ with two pointers.\nAdditional observations: $pos_1\\le 1$ and $pos_{i+1}\\le pos_i+1$. So actually\nthere exist such indices if and only if there exists some $1\\le i<N$ with\n$pos_i=N-B$.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T> using V = vector<T>;\n#define all(x) begin(x), end(x)\n#define mp make_pair\n\n// sum(l ... r)\nint64_t arith(int64_t l, int64_t r) { return (l + r) * (r - l + 1) / 2; }\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T;\n    cin >> T;\n    while (T--) {\n        int N;\n        cin >> N;\n        vector<int64_t> A(N);\n        for (auto &a : A) cin >> a;\n        sort(all(A));\n        auto possible = [&](int B) {\n            if (B == N) return true;\n            int num_before = 0;\n            for (int i = 0; i + 1 < N; ++i) {\n                while (num_before < B && arith(B - num_before, B) <= A[i])\n                    ++num_before;\n                if (i + 1 - num_before == N - B)\n                    return true;  // found potential last element of Helper pile\n            }\n            return false;\n        };\n        int B = 1;\n        while (!possible(B)) ++B;\n        cout << min(arith(1, B), A.back()) << \"\\n\";\n    }\n}\n\nFull Credit: $O(N\\log N)$\nWe claim that if $B<N$ and $B$ is possible, then $B+1$ is also possible. \nThis holds when $B=N-1$, since $B=N$ is always possible.Otherwise, from subtask 3 we have that $B$ is possible if and only if there\nexists some $1\\le i<N$ with $pos_i\\ge N-B$ (such $i$ immediately implies the\nexistence of $j$ such that $pos_j=N-B$). If $B$ is possible, take any index\n$i\\in [1,N)$ such that the inequality $pos_i\\ge N-B$ is satisfied. Then if $B$\nincreases by one, the right-hand side decreases, the left-hand side of this\ninequality stays the same or increases,  which means that this inequality will\nstill be satisfied.  Thus, $B+1$ is also possible.\nNote: To see this fact about the left-hand side, let $n_i\\in [0,B)$ be the value\nof the subtrahend in $pos_i$ for $B$. Then the $n_i+1$-st index in Bessie's pile\nmust be added after time $a_i$. If $B$ increases by one, then the $n_i+1$-st\nindex in Bessie's pile must still be added after time $a_i$, since the time it\nis added increases.\n\nSo we can binary search to find the first possible $B$, reducing the number of\n$B$ we need to check to $O(\\log N)$.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T> using V = vector<T>;\n#define all(x) begin(x), end(x)\n#define mp make_pair\n\n// sum(l ... r)\nint64_t arith(int64_t l, int64_t r) { return (l + r) * (r - l + 1) / 2; }\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T;\n    cin >> T;\n    while (T--) {\n        int N;\n        cin >> N;\n        vector<int64_t> A(N);\n        for (auto &a : A) cin >> a;\n        sort(all(A));\n        auto possible = [&](int B) {\n            if (B == N) return true;\n            int num_before = 0;\n            for (int i = 0; i + 1 < N; ++i) {\n                while (num_before < B && arith(B - num_before, B) <= A[i])\n                    ++num_before;\n                if (i + 1 - num_before == N - B)\n                    // found potential last element of Helper pile\n                    return true;\n            }\n            return false;\n        };\n        int lo = 1, hi = N;\n        while (lo < hi) {\n            int mid = (lo + hi) / 2;\n            if (possible(mid)) hi = mid;\n            else lo = mid + 1;\n        }\n        cout << min(arith(1, lo), A.back()) << \"\\n\";\n    }\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1374_silver_cowmpetency": {"name": "Cowmpetency", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1374", "test_data_link": "http://www.usaco.org/current/data/prob1_silver_jan24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob1_silver_jan24.html", "contest_link": "http://www.usaco.org/index.php?page=jan24results", "inner_contest_link": null, "problem_level": "silver", "cp_id": "1374", "problem_id": "1374_silver_cowmpetency", "description": "\nFarmer John is hiring a new herd leader for his cows. To that end, he has\ninterviewed $N$ ($2 \\leq N \\leq 10^5$) cows for the position. After interviewing\nthe $i$th candidate, he assigned the candidate an integer \"cowmpetency\" score\n$c_i$ ranging from $1$ to $C$ inclusive ($1 \\leq C \\leq 10^9$) that is\ncorrelated with their leadership abilities.\n\nBecause he has interviewed so many cows, Farmer John does not remember all of\ntheir cowmpetency scores. However, he does remembers $Q$ ($1 \\leq Q < N$) pairs\nof numbers $(a_j, h_j)$ where cow $h_j$ was the first cow with a strictly\ngreater cowmpetency score than cows $1$ through $a_j$ (so\n$1 \\leq a_j < h_j \\leq N$).\n\nFarmer John now tells you the sequence $c_1, \\dots, c_N$ (where $c_i = 0$ means\nthat he has forgotten cow $i$'s cowmpetency score) and the $Q$ pairs of\n$(a_j, h_j)$. Help him determine the lexicographically smallest sequence\nof cowmpetency scores consistent with this information, or that no such sequence\nexists! A sequence of scores is lexicographically smaller than another sequence\nof scores if it assigns a smaller score to the first cow at which the two\nsequences differ.\n\nEach input contains $T$ $(1 \\leq T \\leq 20)$ independent test cases. The sum of\n$N$ across all test cases is guaranteed to not exceed  $3 \\cdot 10^5$. \n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $T$, the number of independent test cases.  Each test\ncase is described as follows:\nFirst, a line containing $N$, $Q$, and $C$.Next, a line containing\nthe sequence $c_1, \\dots, c_N$ $(0 \\leq c_i \\leq C)$.Finally, $Q$\nlines each containing a pair $(a_j, h_j)$. It is guaranteed that all $a_j$\nwithin a test case are distinct.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor each test case, output a single line containing the lexicographically\nsmallest sequence of cowmpetency scores consistent with what Farmer John remembers, or $-1$ if such a sequence does not\nexist.\n\nSAMPLE INPUT:\n1\n7 3 5\n1 0 2 3 0 4 0\n1 2\n3 4\n4 5\nSAMPLE OUTPUT: \n1 2 2 3 4 4 1\n\nWe can see that the given output satisfies all of Farmer John's remembered\npairs.\n\n$\\max(c_1) = 1$, $c_2 = 2$ and $1<2$ so the first pair is satisfied$\\max(c_1,c_2,c_3) = 2$, $c_4 = 3$ and $2<3$ so the second pair is\nsatisfied$\\max(c_1,c_2,c_3,c_4) = 3$, $c_5 = 4$ and $3<4$ so the third\npair is satisfied\nThere are several other sequences consistent with Farmer John's memory, such as\n\n1 2 2 3 5 4 1\n1 2 2 3 4 4 5\n\nHowever, none of these are lexicographically smaller than the given output.\n\nSAMPLE INPUT:\n5\n7 6 10\n0 0 0 0 0 0 0\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n8 4 9\n0 0 0 0 1 6 0 6\n1 3\n6 7\n4 7\n2 3\n2 1 1\n0 0\n1 2\n10 4 10\n1 2 0 2 1 5 8 6 0 3\n4 7\n1 2\n5 7\n3 7\n10 2 8\n1 0 0 0 0 5 7 0 0 0\n4 6\n6 9\nSAMPLE OUTPUT: \n1 2 3 4 5 6 7\n1 1 2 6 1 6 7 6\n-1\n1 2 5 2 1 5 8 6 1 3\n-1\n\nIn test case 3, since $C=1$, the only potential sequence is\n\n1 1\n\nHowever, in this case, cow 2 does not have a greater score than cow 1, so we\ncannot satisfy the condition.\n\nIn test case 5, $a_1$ and $h_1$ tell us that cow 6 is the first cow to have a\nstrictly greater score than cows 1 through 4. Therefore, the largest score for\ncows 1 through 6 is that of cow 6:  5. Since cow 7 has a score of 7, cow 7 is\nthe first cow to have a greater score than cows 1 through 6. So, the second\nstatement that cow 9 is the first cow to have a greater score than cows 1\nthrough 6 cannot be true.\n\nSCORING:\nInput 3 satisfies $N \\leq 10$ and $Q, C \\leq 4$.Inputs 4-8 satisfy\n$N \\leq 1000$.Inputs 9-12 satisfy no additional constraints.\n\n\nProblem credits: Suhas Nagar\n", "num_tests": 12, "solution": "\n(Analysis by Suhas Nagar and Anand John)\nFor the interested reader, this problem draws inspiration from the\nSecretary Problem. In\nterms of this problem, each one of Farmer's John's memories can be viewed as the\nfollowing: If Farmer John were to uniformly reject the first $a_i$ cows, and\nthen choose the first cow he saw that was better than any cow he had seen\nbefore, he would choose the $h_i$-th cow.\n Subtask 1: \nWe can solve this with brute force. Simply iterate through all possible\nsequences of cowmpetency scores and return the first one that satisfies Farmer\nJohn's memories.\nCode:\n\ndef genarray(i, N, C, curscores):\n    if curscores[i] != 0:\n        if i == N: yield curscores\n        else: yield from genarray(i + 1, N, C, curscores)\n    else:\n        for score in range(1, C + 1):\n            curscores[i] = score\n            if i == N: yield curscores\n            else: yield from genarray(i + 1, N, C, curscores)\n        curscores[i] = 0\n\nt = int(input())\n\nfor test in range(t):\n    N, Q, C = map(int, input().strip().split())\n    c = [0] + [*map(int, input().strip().split())]\n    constraints = [[*map(int, input().strip().split())] for _ in range(Q)]\n    for curscores in genarray(1, N, C, c):\n        for [a, h] in constraints:\n            if max(curscores[: a + 1]) != max(curscores[:h]) or \\\n                curscores[h] <= max(curscores[: a + 1]):\n                break\n        else:\n            print(*curscores[1:])\n            break\n    else:\n        print(-1)\n\nSubtask 2:\nLet us now define $B(k)$ to be the index of the first cow with a strictly larger\nscore than the first $k$ cows. This is useful because each of Farmer John's\nmemories can be fully described by the statement: $B(a_i) = h_i$.\nBased on this and the above brute force, we realize that possible sequences only\nsatisfy Farmer John's constraints if, for every $1 \\leq i \\leq N$:\n$\\max\\limits_{1 \\leq j \\leq i}{c_j} = \\max\\limits_{1 \\leq j < B(i)}{c_j}$\n\n$c_{B(i)} > \\max\\limits_{1 \\leq j \\leq i} c_j$\n\nThis leads us to the following observation: For all $1 \\leq i < j < B(i)$:\n$B(i) = B(j)$. Therefore, if there exists $i,j$ such that $a_i < a_j < B(a_i)$\nand $B(a_i) \\neq B(a_j)$ then there does not exist a sequence in accordance with\nFarmer John's memory. Combining these observation, with the given $(a_i, h_i)$\npairs,  we can derive the value $B(j)$ for any $j$ that satisfies the inequality\n$a_i \\leq j < h_i$ for some $i$. For all the other values of $j$ we will call\n$B(j)$ unknown\nThis is enough information to come up with a greedy solution. We will iterate\nthrough $i$  from $1$ to $N$. At each point, we will store the minimum possible\nvalues $c_1 \\dots c_n$ that satisfy the constraints related to\n$B(1) \\dots B(i)$. This means that all values of $c_i$ that were not given are\ninitially set to $1$ since this is the minimum possible.\nAt a certain $i$, if $B(i)$ is unknown then no change will be made to the array\nsince there are no associated constraints with $B(i)$. Otherwise, there are two\ncases:\n$\\max\\limits_{1 \\leq j \\leq i}{c_j} = \\max\\limits_{1 \\leq j < B(i)}{c_j}$:\nWe can see that this applies no additional constraint to $c_i$ so we do not have\nto change it. There is an associated change with $c_{B(i)}$ which we'll discuss\nafter the next case.\nOtherwise we have:\n$\\max\\limits_{1 \\leq j \\leq i}{c_j} < \\max\\limits_{1 \\leq j < B(i)}{c_j}$. In\nthis case we need to find a $j \\leq i$ and set $c_j$ to\n$\\max\\limits_{1 \\leq \\ell < B(i)}{c_\\ell}$.  $j$ needs to be as large as\npossible such that $c_j$ was not given in the problem and there exists no $k$\nsuch that $k \\leq j$ and $B(k) < B(i)$. The reasoning behind the first part is\nsimple, we're trying to find the lexographically minimum sequence. So if we have\nto increase some $c_j$, we want to pick as large of a $j$ as possible. The\nreason for the second part is the following: if we were to change $c_j$ and such\na $k$ existed, we would have to satisfy\n$\\max\\limits_{1 \\leq \\ell < B(i)}{c_\\ell} = c_j < c_{B(k)} \\leq  \\max\\limits_{1 \\leq \\ell < B(i)}{c_\\ell}$.\nThis is clearly not possible. Therefore, if no such $j$ exists,  a sequence is\nimpossible to construct.\nFor both of these cases, we also need to ensure that\n$c_{B(i)} > \\max\\limits_{1 \\leq j \\leq i} c_j$. If $c_{B(i)}$ is not given, then\nwe can set $c_{B(i)} = \\max\\limits_{1 \\leq j \\leq i} c_j + 1$. This is the\nsmallest possible value. If $c_{B(i)}$ was given, we need to make sure that it\nis at least this value, otherwise, no sequence is possible.\nThe reason this algorithm works is that each additional constraint that is added\ncan only result in an equivalent or larger lexicographic sequence. Therefore, by\nmaking changes as far back in the array as possible, the resulting sequence is\nthe lexicographically minimum one.\nTo finish, it's now simple to iterate through the sequence and ensure that all\nthe values are at most $C$ to check if the last constraint in the problem is\nsatisfied.\n\nt = int(input())\n\ndef solve():\n    N, Q, C = map(int, input().strip().split())\n    B = [0] * (N + 1)\n    c = [0] + [*map(int, input().strip().split())]\n    assigned = [*map(bool, c)]\n\n    # Initially choose 1 for every non-fixed element\n    c = [score if score else 1 for score in c]\n\n    for _ in range(Q):\n        ai, hi = map(int, input().strip().split())\n        B[ai] = hi\n\n    # Ensure constraints for B\n    for i in range(1, N + 1):\n        # Ensure that every j such that i < j < B[i] has B[j] = B[i]\n        for j in range(i, B[i]):\n            if B[j] != 0 and B[j] != B[i]:\n                return print(-1)\n            B[j] = B[i]\n\n    for i in range(1, N + 1):\n        if B[i] == 0:\n            continue\n        # calculate max before and max after\n        mx_before = max(c[: i + 1])\n        mx_after = max(c[: B[i]])\n\n        # change max before such that mx_before = mx_after\n        if mx_after > mx_before:\n            for j in range(i, 0, -1):\n                if B[j] != 0 and B[j] < B[i]:\n                    return print(-1)\n                if assigned[j]:\n                    continue\n                c[j] = mx_after\n                break\n            else:\n                return print(-1)\n            mx_before = mx_after\n\n        if not assigned[B[i]]:\n            c[B[i]] = mx_before + 1\n        # check to make sure B[i] > mx_before\n        if c[B[i]] <= mx_before:\n            return print(-1)\n\n    # Check that each element in the minimum sequence is at most C\n    for i in range(1, N + 1):\n        if c[i] > C:\n            return print(-1)\n\n    return print(*c[1:])\n\n\nfor _ in range(t):\n    solve()\n\nSubtask 3 In this case, we have to optimize the two $O(n^2)$ parts of our\nsolution. The first part, filling in known values of $B$ can be solved using two\npointers. To optimize the greedy algorithm we can notice that all values $j$\nwhere $i \\leq j < B(i)$ satisfy $B(i) = B(j)$. Therefore, once you satisfy the\nconstraint associated with $B(i)$, the ones associated with\n$B(i+1) \\dots B(B(i)-1)$ are redundant so we can skip them. Putting this\ntogether, we get an algorithm that runs in $O(n)$.\nCode:\n\nt = int(input())\n\ndef solve():\n    N, Q, C = map(int, input().strip().split())\n    B = [0] * (N + 1)\n    c = [0] + [*map(int, input().strip().split())]\n    assigned = [*map(bool, c)]\n\n    # Initially choose 1 for every non-fixed element\n    c = [score if score else 1 for score in c]\n\n    for _ in range(Q):\n        ai, hi = map(int, input().strip().split())\n        B[ai] = hi\n\n    # Ensure constraints for B\n    curind = 1\n    while curind <= N:\n        i = curind\n        # Ensure that every j such that i < j < B[i] has B[j] = B[i]\n        while curind < B[i]:\n            if B[curind] != 0 and B[curind] != B[i]:\n                return print(-1)\n            B[curind] = B[i]\n            curind += 1\n        curind = max(curind, i+1)\n\n    mx_before = 0\n    mx_after = 0\n    i = 1\n    while i <= N:\n        # calculate max before and max after\n        mx_before = max(mx_before, c[i])\n        mx_after = max(mx_after, c[i])\n        if B[i] == 0:\n            i += 1\n            continue\n        mx_after = max(mx_after, *c[i:B[i]])\n        \n        # change mx_before such that mx_before = mx_after\n        if mx_after > mx_before:\n            for j in range(i, 0, -1):\n                if B[j] != 0 and B[j] < B[i]:\n                    return print(-1)\n                if assigned[j]:\n                    continue\n                c[j] = mx_after\n                break\n            else:\n                return print(-1)\n            mx_before = mx_after\n\n        if not assigned[B[i]]:\n            c[B[i]] = mx_before + 1\n        # check to make sure B[i] > mx_before\n        if c[B[i]] <= mx_before:\n            return print(-1)\n\n        i = B[i]\n\n    # Check that each element in the minimum sequence is at most C\n    for i in range(1, N + 1):\n        if c[i] > C:\n            return print(-1)\n\n    return print(*c[1:])\n\nfor _ in range(t):\n    solve()\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1375_silver_potion_farming": {"name": "Potion Farming", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1375", "test_data_link": "http://www.usaco.org/current/data/prob2_silver_jan24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob2_silver_jan24.html", "contest_link": "http://www.usaco.org/index.php?page=jan24results", "inner_contest_link": null, "problem_level": "silver", "cp_id": "1375", "problem_id": "1375_silver_potion_farming", "description": "\nYou are playing your favorite mobile game and you are trying to farm potions so\nthat you  may have a chance at defeating the legendary cow boss. The game map is a\nseries of $N$ $(2 \\leq N \\leq 10^5)$ rooms labeled $1\\dots N$  connected by\n$N-1$ edges that form a tree. \n\nYou can explore the map by making a series of \"traversals\". A traversal is a\nsimple path from room $1$ to any other room in the tree. Once you finish one\ntraversal, you can start another traversal from room $1$. The map is complete\nonce every one of its rooms is visited by at least one traversal. Your main goal\nis to complete the map in the minimum number of traversals. \n\nYour secondary goal is to farm as many potions as possible. Before a traversal\nbegins, a potion will spawn at some room in the map. You can pick up the potion\nby visiting the room that the potion spawned at in the current traversal. If you\ndo not pick up the potion, then it will disappear once the current traversal\nends, so you cannot pick it up in future traversals.\n\nAs you are a smart programmer, after looking at the game files, you were able to\nfigure out where the potions will appear before your next $N$ traversals. If you\ncomplete the map in the minimum number of traversals, what is the maximum amount\nof potions that you can farm from the map?  \n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line of the input contains an integer $N$, denoting  the number of\nrooms in the map.\n\nThen follow $N$ space-separated integers $p_1 \\: p_2 \\: \\ldots \\: p_N$ where \n$1 \\leq p_i \\leq N$, where $p_i$ is the room that a potion will appear at before\nthe $i$th traversal.\n\nFinally, $N-1$ lines follow with two space-separated integers $a \\: b$\n$(1 \\leq a, b \\leq N)$  representing an edge between rooms $a$ and $b$. It is\nguaranteed that these edges form a tree.\n\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput one line containing a single integer, the maximum amount of potions  that\nyou can farm from the map in the minimum number of traversals. \n\nSAMPLE INPUT:\n5\n5 4 3 2 1\n1 2\n1 3\n3 4\n3 5\nSAMPLE OUTPUT: \n2\n\nIn this case, the minimum number of traversals required to complete the map is\n$3$.\n\nOne optimal plan that picks up two potions in three traversals is as follows:\nTraversal 1: $1 \\rightarrow 3 \\rightarrow 5$ (Pick up potion at 5)Traversal 2: $1 \\rightarrow 3 \\rightarrow 4$ (Pick up potion at 4)Traversal 3: $1 \\rightarrow 2$ (Forced to complete the map and ignore potion\nat 3)\nAlternatively, we could have also planned our traversals as follows:\nTraversal 1: $1 \\rightarrow 2$ (no potions)Traversal 2: $1 \\rightarrow 3 \\rightarrow 4$ (Pick up potion at 4)Traversal 3: $1 \\rightarrow 3 \\rightarrow 5$ (Pick up potion at 3)\nSCORING:\nInputs 2-7: $N\\le 1000$Inputs 8-15: No additional constraints.\n\n\nProblem credits: Suhas Nagar\n", "num_tests": 15, "solution": "\n(Analysis by Suhas Nagar)\nThe minimal number of traversals to visit every node must be the number of\nleaves of the tree. If the starting room $1$ is a leaf, we exclude it from this\ncount. Let this number of leaves excluding the starting room be $L$.\nObservation 1: The number of potions we can collect is bounded by the number of\nleaves of the tree. Since we have to explore a path (indicated by a new leaf)\neach iteration, the potions at $p_{L+1}, p_{L+2}, \\ldots, p_{N}$ will never\nspawn since we explore the tree by then so we can disregard them.\nObservation 2: We notice that the order of $p_1\\dots p_L$ does not matter since\nwe could just change the order that we make our traversals in.\nSubtask 1: $N \\leq 1000$:\nFor each leaf $l_i$, we can greedily pair it with the closest potion $p_i$ that\nis an ancestor of the leaf. \nSuppose this was not optimal. This means that $l_i$ should get paired with some\nother $p_j$ or not get paired at all. If $l_i$ gets paired with some $p_j$ and\nanother leaf $l_j$ pairs with $p_i$, this is equivalent to our greedy pairing\nsince $p_j$ must be an ancestor of $p_i$ and therefore be able to pair with\n$l_j$. If $l_i$ should not get paired and $l_j$ should pair with $p_i$, this\nwill still provide an equivalent answer to our construction. \nSince there are $O(N)$ leaves with each leaf having up to $O(N)$ nodes between\nit and the  nearest potion, this solution will run in $O(N^2)$.\nBrandon Wang's C++ code:\n\n#include <iostream>\n#include <vector>\n \nconst int MAXN = 200005;\n \nint N;\nstd::vector<int> adj[MAXN];\nint at[MAXN];\nint p[MAXN];\nint par[MAXN];\n \nvoid input () {\n\tstd::cin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tstd::cin >> p[i];\n\t}\n\tfor (int i = 1; i < N; i++) {\n\t\tint a, b; std::cin >> a >> b;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n}\n \nvoid dfs (int v) {\n\tfor (auto &u : adj[v]) {\n\t\tif (u != par[v]) {\n\t\t\tpar[u] = v;\n\t\t\tdfs(u);\n\t\t}\n\t}\n}\n \nvoid proc () {\n\tint L = 0;\n\tfor (int i = 2; i <= N; i++) {\n\t\tL += (int(adj[i].size()) == 1);\n\t}\n\tfor (int i = 0; i < L; i++) {\n\t\tat[p[i]]++;\n\t}\n}\n \nbool grab (int v) {\n\twhile (v > 0) {\n\t\tif (at[v] > 0) {\n\t\t\tat[v]--;\n\t\t\treturn 1;\n\t\t}\n\t\tv = par[v];\n\t}\t\n\treturn 0;\n}\n \nint solve () {\n\tint ans = 0;\n\tfor (int i = 2; i <= N; i++) {\n\t\tif (int(adj[i].size()) == 1) {\n\t\t\tans += grab(i);\n\t\t}\n\t}\n\treturn ans;\n}\n \nint main () {\n\tinput();\n\tproc();\n\tdfs(1);\n\tstd::cout << solve() << std::endl;\n}\n\nFull Credit:\nLet $C(i)$ be the number of leaves that node $i$ is an ancestor of. Let $P(i)$\nbe the number of potions collected by all the paths that go through node $i$.\nBuilding on observation $1$, we see that $P(i) \\leq C(i)$ across all nodes $i$.\nWe can apply this fact recursively across all nodes to create our solution.\nLet $pot[i]$ be the number of potions that spawn at node $i$. To compute the\nvalue of $P(i)$, we can determine the values of $P(c)$ for all children of $i$\nand sum them together: $P(i) = \\min(C(i),\\sum_c P(c)+pot[i])$. If we build this\nanswer from the leaves up to the root, which can be done after the recursive\nstep of a DFS iteration through the tree, we can compute our answer up to $P(1)$\nand print this as our answer.\nWe can apply a similar proof to subtask 1 to show why this works, because we are\nstill pairing leaves with the closest potion that is an ancestor. Since we build\nthis  answer recursively from the leaves up to the root, if\n$\\sum_c P(c) < C(i)$, this means that there are some unpaired leaves.\nConsequently, any potions found at node $i$ are the closest potions that are\nancestors of those unpaired leaves, so we can just pair them. On the other hand,\nif $\\sum_c P(c) = C(i)$, that means that every leaf in this subtree has  already\nencountered a potion that is closer than the node that we are currently\nprocessing, so there is no leaf to pair with it. Since we only use a single DFS\nto compute these values, this solution runs in $O(N)$.\nMy code:\n\nimport java.util.*;\nimport java.io.*;\n \npublic class PotionFarming {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(in.readLine());\n        int s = 0;\n        int[] pots = new int[n];\n        int i = 0;\n        for (String potion : in.readLine().split(\" \")) {\n            pots[i++] = Integer.parseInt(potion)-1;\n        }\n        ArrayList[] graph = new ArrayList[n];\n        for (i = 0; i < n; i++) {\n            graph[i] = new ArrayList();\n        }\n        for (i = 0; i < n - 1; i++) {\n            StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n            int a = Integer.parseInt(tokenizer.nextToken()) - 1;\n            int b = Integer.parseInt(tokenizer.nextToken()) - 1;\n            graph[a].add(b);\n            graph[b].add(a);\n        }\n        numleaves = new int[n];\n        int leaves = countleaves(s, -1, graph);\n        int[] modpots = new int[n];\n        for (i = 0; i < leaves; i++) {\n            modpots[pots[i]]++;\n        }\n        System.out.println(countPotions(s, -1, graph, modpots));\n    }\n    public static int countPotions(int cur, int par, ArrayList[] graph, int[] modpots){\n        int sum = 0;\n        for (Object a : graph[cur]){\n            if ((int)a == par){\n                continue;\n            }\n            sum += countPotions((int)a,cur,graph, modpots);\n        }\n        sum += modpots[cur];\n        return Math.min(sum,numleaves[cur]);\n    }\n    public static int[] numleaves;\n    public static int countleaves(int cur, int par, ArrayList[] graph){\n        if ((graph[cur].size() == 1 && (int)graph[cur].get(0) == par) || graph[cur].size() == 0){\n            numleaves[cur] = 1;\n            return 1;\n        }\n        int sum = 0;\n        for (Object a : graph[cur]){\n            if ((int)a == par){\n                continue;\n            }\n            sum += countleaves((int)a,cur,graph);\n        }\n        numleaves[cur] = sum;\n        return sum;\n    }\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1376_silver_cowlendar": {"name": "Cowlendar", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1376", "test_data_link": "http://www.usaco.org/current/data/prob3_silver_jan24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob3_silver_jan24.html", "contest_link": "http://www.usaco.org/index.php?page=jan24results", "inner_contest_link": null, "problem_level": "silver", "cp_id": "1376", "problem_id": "1376_silver_cowlendar", "description": "\nBessie has woken up on a strange planet.  In this planet, there are $N$\n($1\\le N\\le 10^4$) months, with $a_1, \\ldots, a_N$ days, respectively\n($1\\leq a_i \\leq 4 \\cdot 10^9$, all $a_i$ are integers). In addition, on the\nplanet, there are also weeks, where each week is $L$ days, with $L$ being a\npositive integer. Interestingly, Bessie knows the following:\n For the correct $L$, each month is at least $4$ weeks long.  For\nthe correct $L$,  there are at most $3$ distinct values of $a_i\\bmod L$.\nUnfortunately, Bessie has forgotten what $L$ is! Help her by printing the sum of\nall possible values of $L$.\n\nNote that the large size of integers involved in this problem may require the\nuse of 64-bit integer data types (e.g., a \"long long\" in C/C++).\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains a single integer $N$. The second line contains $N$\nspace-separated integers, $a_1, \\ldots, a_N$. \n\nOUTPUT FORMAT (print output to the terminal / stdout):\nA single integer, the sum of all possible values of $L$.\n\nSAMPLE INPUT:\n12\n31 28 31 30 31 30 31 31 30 31 30 31\nSAMPLE OUTPUT: \n28\n\nThe possible values of $L$ are 1, 2, 3, 4, 5, 6, and 7.  For example, $L=7$ is\nvalid because each month is at least length $4 \\cdot 7 = 28$ days long, and each\nmonth is either 0, 2, or 3 mod 7. \n\nSAMPLE INPUT:\n4\n31 35 28 29\nSAMPLE OUTPUT: \n23\n\nThe possible values of $L$ are 1, 2, 3, 4, 6, and 7. For example, $L=6$ is valid\nbecause each month is at least length $4 \\cdot 6 = 24$ days long, and each month\nis either 1, 4, or 5 mod 6. \n\nSCORING:\nInputs 3-4: $1 \\leq a_i \\leq 10^6$Inputs 5-14: No additional\nconstraints\n\n\nProblem credits: Brandon Wang\n", "num_tests": 14, "solution": "\n(Analysis by Brandon Wang)\nThe first thing we should do is remove duplicates of $a_i$.  After this, we'll\nassume all the $a_i$ are distinct, and let $N'$ denote the number of distinct\n$a_i$. Note that if $N' \\leq 3$, then any $L$ satisfies the second condition.\nSo, the answer is just $1 + 2 + \\cdots + (\\min a_i)/4$.\nSubtask 1 ($a_i\\leq 10^6$):\nFor this subtask, we first consider the following naive algorithm:  Let\n$U = (\\min a_i)/4$ be an upper bound on $L$.  For each $1\\leq L \\leq U$, we can\ncheck how many possible values of $a_i\\pmod L$ there are. It turns out that if\nwe break once we see 4 distinct values, then we will pass this subtask.\nHere is an implementation:\n\nN = input()\nS = list(set([int(x) for x in input().split()]))\n\nU = min(S) // 4\nif len(S) < 4:\n    print(U*(U+1)//2)\n    exit()\n\ndef test(L):\n    mods = set()\n    for a in S:\n        mods.add(a%L)\n        if len(mods) >= 4:\n            return False\n    return True\n\nprint(sum([L for L in range(1, U+1) if test(L)]))\n\nNow, why do we pass? A naive analysis says that this time should take $O(UN')$\ntime, where $U\\leq 2.5\\cdot 10^5$ and $N' \\leq 10^4$. So this should not\nactually be fast enough. \nLet's consider the test function again, which takes $O(N')$ time in the worst\ncase. However,  note that in order for the function to not return after 4\niterations (and so only take $O(1)$ time), among\n$a_1\\bmod L, a_2\\bmod L, a_3\\bmod L, a_4\\bmod L$, there are at most $3$ distinct\nvalues.\nThis implies that $L$ divides one of\n$(a_2 - a_1, a_3 - a_1, a_4 - a_1, a_3 - a_2, a_4 - a_2, a_4 - a_3)$. Now, if we\nlet $n(A)$ denote the maximum number of divisors that a number at most $A$ can\nhave, then we see that for all but at most $6n(10^6)$ values of $L$,  we break\nafter 4 loop iterations. So, we can bound the runtime of this step by\n$O(U + n(10^6)\\cdot N')$, where we run the loop $O(U)$ times, and only run past\n4 iterations $O(n(10^6))$ times. Since $n(10^6) \\leq 2\\cdot 10^3$ (here, note\nthat any positive integer $x$ has at most $2\\sqrt x$ divisors),  this will run\nin time.\nGeneral Case ($a_i \\leq 4\\cdot 10^9$):\nNow, $U$ can be up to $10^9$, so the preceding algorithm is too slow. On the\nother hand, $n(4\\cdot 10^9)$ is actually $2000$, so we just need to speed up the\n$O(U)$ step. To do this, instead of checking every possible value of $L$\nand seeing if it breaks after trying the first four $a_i$, we will instead\nexplicitly only consider $L$ that would not have broken. The only such values of\n$L$ are those that divide one of\n$(a_2 - a_1, a_3 - a_1, a_4 - a_1, a_3 - a_2, a_4 - a_2, a_4 - a_3)$. So, we can\njust compute these divisors.  We can compute the divisors of $A$ in $O(\\sqrt A)$\ntime, so the total runtime of this is\n$O(\\sqrt{\\max a_i} + n(4\\cdot 10^9) \\cdot N')$, which runs in time.\nHere is an implementation:\n\nN = input()\nS = list(set([int(x) for x in input().split()]))\n\nU = min(S) // 4\nif len(S) < 4:\n    print(U*(U+1)//2)\n    exit()\n\ndivs = set()\nfor i, s in enumerate(S[:4]):\n    for _, r in enumerate(S[i:4]):\n        diff = abs(s-r)\n        for t in range(1, int(diff**(0.5) + 1)):\n            if diff%t == 0:\n                divs.add(t)\n                divs.add(diff//t)\n\ndef test(L):\n    if L > U:\n        return False\n    mods = set()\n    for a in S:\n        mods.add(a%L)\n        if len(mods) >= 4:\n            return False\n    return True\n\nprint(sum([L for L in divs if test(L)]))\n\nDanny Mittal's implementation:\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n \npublic class Cowlendar {\n \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(in.readLine());\n        Set<Long> months = new HashSet<>();\n        StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n        long maxWeekLength = Integer.MAX_VALUE;\n        for (; n > 0; n--) {\n            long month = Long.parseLong(tokenizer.nextToken());\n            months.add(month);\n            maxWeekLength = Math.min(maxWeekLength, month / 4L);\n        }\n        if (months.size() <= 3) {\n            System.out.println((maxWeekLength * (maxWeekLength + 1L)) / 2L);\n        } else {\n            Set<Long> candidates = new HashSet<>();\n            Long[] distinctMonths = months.toArray(new Long[0]);\n            for (int j = 0; j < 4; j++) {\n                for (int k = 0; k < j; k++) {\n                    long diff = Math.abs(distinctMonths[k] - distinctMonths[j]);\n                    for (long x = 1; x <= 100000; x++) {\n                        if (diff % x == 0L) {\n                            candidates.add(x);\n                            candidates.add(diff / x);\n                        }\n                    }\n                }\n            }\n \n            long answer = 0;\n            for (long candidate : candidates) {\n                if (candidate <= maxWeekLength) {\n                    Set<Long> seen = new HashSet<>();\n                    for (long month : distinctMonths) {\n                        seen.add(month % candidate);\n                    }\n                    if (seen.size() <= 3) {\n                        answer += candidate;\n                    }\n                }\n            }\n            System.out.println(answer);\n        }\n    }\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1371_bronze_majority_opinion": {"name": "Majority Opinion", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1371", "test_data_link": "http://www.usaco.org/current/data/prob1_bronze_jan24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob1_bronze_jan24.html", "contest_link": "http://www.usaco.org/index.php?page=jan24results", "inner_contest_link": null, "problem_level": "bronze", "cp_id": "1371", "problem_id": "1371_bronze_majority_opinion", "description": "\nFarmer John has an important task - figuring out what type of hay to buy for his\ncows.\n\nFarmer John's $N$ cows ($2 \\le N \\le 10^5$) are numbered $1$ through $N$ and\neach cow likes exactly one type of hay $h_i$ ($1 \\le h_i \\le N$). He wants all\nhis cows to like the same type of hay.\n\nTo make this happen, Farmer John can host focus groups. A focus group consists\nof getting all cows in a contiguous range numbered $i$ to $j$, inclusive,\ntogether for a meeting. If there is a type of hay that more than half the cows\nin the group like, then after the focus group finishes meeting, all cows end up\nliking that type of hay. If no such type of hay exists, then no cows change the\ntype of hay they like.  For example, in focus group consisting of a range of 16\ncows, 9 or more of them would need to have the same hay preference to cause the\nremaining cows to switch their preference to match.\n\nFarmer John wants to know which types of hay can become liked by all cows\nsimultaneously. He can only host one focus group at a time, but he can run as\nmany focus groups as necessary to get all cows to like the same type of hay.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first will consist of an integer $T$, denoting the number of independent\ntest cases $(1 \\leq T \\leq 10)$.\n\nThe first line of each test case consists of $N$.\n\nThe second line consists of $N$ integers, the favorite types of hay $h_i$ for\nthe cows in order.\n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed\n$2\\cdot 10^5$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput $T$ lines, one line per test case.\n\nIf it possible to make all cows like the same type of hay simultaneously, output\nall possible such types of hay in increasing order. Otherwise, output $-1$. \nWhen printing a list of numbers on the same line, separate adjacent numbers with\na space, and be sure the line does not end with any extraneous spaces.\n\nSAMPLE INPUT:\n5\n5\n1 2 2 2 3\n6\n1 2 3 1 2 3\n6\n1 1 1 2 2 2\n3\n3 2 3\n2\n2 1\nSAMPLE OUTPUT: \n2\n-1\n1 2\n3\n-1\n\nIn the sample input, there are 5 test cases.\n\nIn the first test case, it is only possible to make all cows like type 2. FJ can\ndo this by running a single focus group with all cows.\n\nIn the second test case, we can show that no cows will change which type of hay\nthey like.\n\nIn the third test case, it is possible to make all cows like type 1 by running\nthree focus groups - first by having cows 1 through 4 in a focus group, then by\nhaving cows 1 through 5 in a focus group, then by having cows 1 through 6 in a\nfocus group. By similar logic, using cows 3 through 6, cows 2 through 6, then\ncows 1 through 6, we can make all cows like type 2.\n\nIn the fourth test case, it is possible to make all cows like type 3 by running\na single focus group with all cows.\n\nIn the fifth test case, we can show that no cows will change which type of hay\nthey like. \n\nSCORING:\nInput 2: $N = 2$.Inputs 3-4: $N \\le 50$.Inputs 5-6: $h_i \\le h_{i+1}$ for all $1 \\le i \\le N-1$.Inputs 7-15: No additional constraints.\n\n\nProblem credits: Nick Wu\n", "num_tests": 15, "solution": "\n(Analysis by Nick Wu)\nSubtask 1: $N \\le 2$.\nNote that focus groups of two cannot cause any cow to change their opinion.\nTherefore, the only way for all cows to like the same type of hay is if they\nstart out liking the same type of hay.\n\nt = int(input())\nfor _ in range(t):\n  input()\n  l = [int(x) for x in input().split()]\n  if l[0] == l[1]: print(l[0])\n  else: print(-1)\n\nSubtask 2: $N \\le 50$.\nFor each type of hay, we'll try to determine if it's possible to make every cow\nlike that type of hay by finding potential focus groups that will cause other\ncows to like our desired type of hay. Specifically, we are looking for focus\ngroups where a strict majority of cows like our desired type of hay, but there\nis at least one cow that does not like it, because then that focus group will\ncause the given cow to change the type of hay they like.\nNaively, there are $\\mathcal{O}(N^2)$ focus groups to check - checking each one\ntakes $\\mathcal{O}(N)$ time, and we only need to run $\\mathcal{O}(N)$ focus\ngroups to get all cows to switch to our desired type of hay. With\n$\\mathcal{O}(N)$ different types of hay, this algorithm runs in\n$\\mathcal{O}(N^5)$ with a low constant factor. There are ways to improve this\nstyle of solution, but they are not necessary to get credit for this subtask.\n\ndef canmake(l, x):\n  while l.count(x) != len(l):\n    upd = False\n    for j in range(1, len(l)+1):\n      for i in range(j):\n        match = l[i:j].count(x)\n        if match * 2 > len(l[i:j]) and match != len(l[i:j]):\n          l = l[:i] + [x] * (j-i) + l[j:]\n          upd = True\n          break\n    if not upd:\n      break\n  return l.count(x) == len(l)\n \nt = int(input())\nfor _ in range(t):\n  input()\n  l = [int(x) for x in input().split()]\n  valid = [i for i in range(1, len(l)+1) if canmake(l, i)]\n  if not valid: valid.append(-1)\n  print(\" \".join([str(x) for x in valid]))\n\nSubtask 3: $h_i \\le h_{i+1}$ for $1 \\le i < N$.\nThe key to this subtask is that, if two cows like the same type of hay, then\nthere must exist two cows $i$ and $i+1$ that both like the same type of hay. The\nintended solution to this subtask otherwise does not depend on the $h_i$ values\nactually being in sorted order.\nNote that if cows $i$ and $i+1$ like the same type of hay, then a focus group\nwith those two cows and exactly one other cow can cause the other cow to like\nthe same type of hay as cows $i$ and $i+1$. Therefore, for this subtask, we can\nprint out all types of hay that are liked by at least two cows.\n\nt = int(input())\nfor _ in range(t):\n  input()\n  l = [int(x) for x in input().split()]\n  valid = []\n  for i in range(1, len(l)):\n    if l[i] == l[i-1] and (i == 1 or l[i] != l[i-2]): valid.append(l[i])\n  if not valid: valid.append(-1)\n  print(\" \".join([str(x) for x in valid]))\n\nFull Credit:\nFrom the above subtask, we can also observe that if cows $i-1$ and $i+1$ like\nthe same type of hay, a focus group with cows $i-1$, $i$, and $i+1$ will end up\nhaving all three cows liking the same type of hay.\nNote furthermore that for any focus group of size greater than 3 with a majority\nof cows liking the same type of hay, we can find always find a smaller focus\ngroup of size 3 inside where two of the cows like the same type of hay as the\nmajority of cows in the larger focus group. We leave the proof of this fact as\nan exercise for the reader.\nTherefore, a type of hay is valid if and only if there exist cows $i$ and $i+1$\nthat both like it, or there exist cows $i$ and $i+2$ that both like it.\nClaire Zhang's C++ code:\n\n#include<bits/stdc++.h>\nusing namespace std;\n \nint main(){\n    int T, N;\n    cin >> T;\n    while(T--){\n        cin >> N;\n        int a[N];\n        bool good[N];\n        memset(good, 0, sizeof(good)); \n        \n        for(int i=0; i<N; i++){\n            cin >> a[i];\n            a[i]--;\n            if(i>0 and a[i]==a[i-1] or i>1 and a[i]==a[i-2]) good[a[i]]=1;\n        }\n \n        bool at_least_one = 0;\n        for(int i=0; i<N; i++){\n            if(good[i]){\n                at_least_one = 1;\n                cout << i+1 << \" \";\n            }\n        }\n        if(!at_least_one) cout << -1;\n        cout << '\\n';\n    }\n}\n\nMy Java code:\n\nimport java.io.*;\nimport java.util.*;\npublic class Solution {\n  public static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    int t = Integer.parseInt(br.readLine());\n    while(t-- > 0) {\n      int n = Integer.parseInt(br.readLine());\n      StringTokenizer st = new StringTokenizer(br.readLine());\n      int[] h = new int[n];\n      for(int i = 0; i < n; i++) h[i] = Integer.parseInt(st.nextToken());\n      boolean[] good = new boolean[n+1];\n      for(int i = 0; i + 1 < n; i++) {\n        if(h[i] == h[i+1]) good[h[i]] = true;\n        if(i+2 < n && h[i] == h[i+2]) good[h[i]] = true;\n      }\n      boolean printed = false;\n      for(int i = 1; i <= n; i++) {\n        if(good[i]) {\n          if(printed) pw.print(' ');\n          printed = true;\n          pw.print(i);\n        }\n      }\n      if(!printed) pw.print(-1);\n      pw.println();\n    }\n    pw.close();\n  }\n}\n\nClaire Zhang's Python code:\n\ndef solve(arr):\n    result = []\n    for i in range(len(arr) - 1):\n        if arr[i] == arr[i + 1] or (i < len(arr) - 2 and arr[i] == arr[i + 2]):\n            result.append(arr[i])\n    result = sorted(list(set(result)))\n    if len(result) == 0:\n        result = [-1]\n    return result\n \ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        arr = list(map(int, input().split()))\n        print(*solve(arr))\n \nif __name__ == \"__main__\":\n    main()\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1372_bronze_cannonball": {"name": "Cannonball", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1372", "test_data_link": "http://www.usaco.org/current/data/prob2_bronze_jan24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob2_bronze_jan24.html", "contest_link": "http://www.usaco.org/index.php?page=jan24results", "inner_contest_link": null, "problem_level": "bronze", "cp_id": "1372", "problem_id": "1372_bronze_cannonball", "description": "\nBessie has mastered the art of turning into a cannonball and bouncing along a\nnumber line of length $N$  $(1 \\leq N \\leq 10^5)$ with locations numbered\n$1,2,\\dots,N$ from left to right.  She starts at some integer location $S$\n$(1 \\leq S \\leq N)$ bouncing to the right with a starting power of $1$. If\nBessie has power $k$, her next bounce will be at a distance $k$ forward from her\ncurrent location.  \n\nEvery integer location from $1$ to $N$ is either a target or a jump pad. Each\ntarget and jump pad has an integer value in the range $0$ to $N$ inclusive. A\njump pad with a value of $v$ increases Bessie's power by $v$ and reverses her\ndirection.  A target with a value of $v$ will be broken if landed on with a\npower of at least $v$.  Landing on a target does not change Bessie's power or\ndirection.  A target that is broken will remain broken and Bessie can still\nbounce on it, also without changing power or direction.\n\nIf Bessie bounces for an infinite amount of time or until she leaves the number\nline, how many targets will she break?\n\nIf Bessie starts on a target that she can break, she will immediately do so.\nSimilarly, if Bessie starts on a jump pad, the pad's effects will be applied\nbefore her first jump.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line of the input contains $N$ and $S$, where $N$ is the length of the\nnumber line and $S$ is Bessie's starting location.\n\nThe next $N$ lines describe each of the locations. The $i$th of these lines\ncontains integers $q_i$ and $v_i$, where $q_i = 0$ if location $i$ is a jump pad\nand  $q_i = 1$ if location $i$ is a target, and where $v_i$ is the value of\nlocation $i$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput one number representing the number of targets that will be broken.\n\nSAMPLE INPUT:\n5 2\n0 1\n1 1\n1 2\n0 1\n1 1\nSAMPLE OUTPUT: \n1\n\nBessie starts at coordinate $2$, which is a target of value $1$, so she\nimmediately breaks it. She then bounces to coordinate $3$, which is a target of\nvalue $2$, so she can't break it. She continues to coordinate $4$, which\nswitches her direction and increases her power by $1$ to $2$. She bounces back\nto coordinate $2$, which is an already broken target, so she continues. At this\npoint, she bounces to coordinate $0$, so she stops. She breaks exactly one\ntarget at located at $2$.\n\nSAMPLE INPUT:\n6 4\n0 3\n1 1\n1 2\n1 1\n0 1\n1 1\nSAMPLE OUTPUT: \n3\n\nThe path Bessie takes is $4\\to 5\\to 3\\to 1\\to 6$, where the next bounce would\ntake her out of the number line ($11$). She breaks targets $4, 3, 6$ in that\norder.\n\nSCORING:\nInputs 3-5: $N \\le 100$ Inputs 6-10: $N \\le 1000$ Inputs\n11-20: No additional constraints. \n\n\nProblem credits: Suhas Nagar\n", "num_tests": 20, "solution": "\n(Analysis by Ben Chen)\nFirst consider the case where all jump pads have a positive $v$. We may directly\nsimulate Bessie's process. At a given power $p$, Bessie will jump at most\n$\\frac n p$ times before she exits the number line or she hits a jump pad, in which\nher power increases. Therefore the number of bounces is bounded by\n$\\sum_{i=1}^n \\frac n i = O(n\\lg(n))$.\nWhen there are jump pads with with value $0$, then there's a possibility Bessie\ncan get stuck in an infinite loop. This happens only when Bessie hits a jump pad\nof value $0$, switches direction, and after some bounces, the next jump pad she\nhits is also value $0$. It is possible to check for this infinite loop cycle,\nbut it's easier to implement just simulating Bessie's bounces for enough\niterations (about $O(n\\lg(n))$) since Bessie won't break additional targets\nwhile stuck in a loop.\nSample implementation:\n\n#include <bits/stdc++.h>\nusing namespace std;\n \nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n, x;\n\tcin >> n >> x;\n\tvector<pair<int, int>> pad(n + 1);\n\tvector<bool> vis(n + 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tcin >> pad[i].first >> pad[i].second;\n\tint dir = 1, power = 1, ans = 0;\n\tfor (int reps = 0; reps < 5000000 && 1 <= x && x <= n; ++reps) {\n\t\t// Bessie breaks a target she hasn't broken before\n\t\tif (pad[x].first == 1 && power >= pad[x].second && !vis[x]) {\n\t\t\tvis[x] = true;\n\t\t\t++ans;\n\t\t}\n\t\tif (pad[x].first == 0) { // jump pad\n\t\t\tdir *= -1;\n\t\t\tpower += pad[x].second;\n\t\t}\n\t\tx += dir * power;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1373_bronze_balancing_bacteria": {"name": "Balancing Bacteria", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1373", "test_data_link": "http://www.usaco.org/current/data/prob3_bronze_jan24.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob3_bronze_jan24.html", "contest_link": "http://www.usaco.org/index.php?page=jan24results", "inner_contest_link": null, "problem_level": "bronze", "cp_id": "1373", "problem_id": "1373_bronze_balancing_bacteria", "description": "\nFarmer John has $N$ ($1\\le N\\le 2\\cdot 10^5$) patches of grass in a line, where\npatch $i$ has a level of bacteria that differs by $a_i$ from that of healthy\ngrass ($-10^{15}\\le a_i \\le 10^{15}$).  For example, if $a_i = -3$, then patch\n$i$ has a level of bacteria 3 lower than normal, and would need exactly 3\nadditional units of bacteria added to raise it to the point where it is\nconsidered healthy.\n\nFarmer John wants to ensure every patch of grass is corrected to have a healthy\nlevel of bacteria.  Conveniently, he owns two brands of pesticide that he can\nspray on his field, one that adds bacteria and one that removes bacteria. When\nFarmer John sprays either type of pesticide, he stands in patch $N$ (the\nrightmost patch) and selects a power level $L$ for his sprayer ($1 \\leq L \\leq N$).  \n\nThe sprayer has the most impact on patches near Farmer John, with diminishing\neffect farther away.  If Farmer John chooses the pesticide that adds bacteria,\nthen $L$ units of bacteria will be added to patch $N$, $L-1$ units to patch\n$N-1$, $L-2$ units to patch $N-2$, and so on.  Patches $1 \\ldots N-L$ will\nreceive no bacteria, since the sprayer isn't set to a level powerful enough to\nreach them.   Similarly, if Farmer John chooses the pesticide that removes\nbacteria, then $L$ units of bacteria will be removed from patch $N$, $L-1$ units\nwill be removed from patch $N-1$, and so on.  Again, patches $1 \\ldots N-L$ will\nbe unaffected.\n\nFind the minimum number of times Farmer John has to apply his sprayer such that\nevery patch of grass has the recommended value of bacteria for healthy grass. It\nis guaranteed that the answer is at most $10^9$.\n\nNote that the large size of integers involved in this problem may require the\nuse of 64-bit integer data types (e.g., a \"long long\" in C/C++).\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$.\n\nThe second line contains $N$ integers $a_1\\dots a_N$, the initial bacteria\nlevels of each patch of grass.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe minimum number of applications necessary to make every patch of grass have\nthe recommended value of bacteria for healthy grass.\n\nSAMPLE INPUT:\n2\n-1 3\nSAMPLE OUTPUT: \n6\n\nUse the type of pesticide that removes bacteria, at a power level of 1, five\ntimes. Then use the type of pesticide that adds bacteria, with a power level of\n$2$, one time.\n\nSAMPLE INPUT:\n5\n1 3 -2 -7 5\nSAMPLE OUTPUT: \n26\n\nSCORING:\nInputs 3-5: $N \\le 10^3$, the answer is at most $10^3$ Inputs\n6-10: $N \\le 10^3$ Inputs 11-15: No additional constraints. \n\n\nProblem credits: Rohin Garg\n", "num_tests": 15, "solution": "\n(Analysis by Rohin Garg)\nThere are multiple solutions to this problem, each with different thought\nprocesses but the same end result. Two are presented below. An operation of type\n$1$ refers to a single walk with pesticide of type $1$, while an operation of\ntype $2$ refers to a single walk with pesticide of type $2$.\nSolution 1: Difference Arrays\nLet $\\text{diff}(a)$ be the difference array of $a$. In particular,\n$\\text{diff}(a) = [a_1, a_2 - a_1, \\ldots, a_n - a_{n-1}]$. Let's examine how\neach type of operation affects $\\text{diff}(a)$.\nAssume we do an operation of type 1. The value at indices less than $h$ remain\nunchanged, so the corresponding values of $\\text{diff}(a)$ stay the same as\nwell. Because $a_h$ increases by $1$ and $a_{h-1}$ remains unchanged,\n$\\text{diff}(a)_h$ is the first value that changes, and it increases by $1$.\nSimilarly, because $a_{h+1}$ increases by $2$ and $a_h$ increases by $1$,\n$\\text{diff}(a)_{h+1}$ increases by $1$. Extending this argument, an operation\nof type $1$ simply increments a suffix of $\\text{diff}(a)$, while and operation\nof type $2$ decrements a suffix.\nThis transformation can be done one more time. Let's examine how\n$\\text{diff}(\\text{diff}(a))$ changes after each operation. By doing a similar\nanalysis as before, we can see that the only index that changes is\n$\\text{diff}(\\text{diff}(a))_h$, and it either increases or decreases by $1$\ndepending on the operation type. Finding the minimum operations to make\n$\\text{diff}(\\text{diff}(a))$ all $0$'s is now straightforward, as it is equal\nto $\\sum_{i=1}^n\n|\\text{diff}(\\text{diff}(a))_i|$, because all of the indices\nare independent. \nRohin Garg's code:\n\n#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\n \nvector<ll> diff(vector<ll> a) {\n    vector<ll> b(a.size());\n    for (int i = 0; i < (int) b.size(); i++) {\n        b[i] = a[i];\n        if (i > 0)\n            b[i] -= a[i-1];\n    }\n    return b;\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n   \n    int n; cin >> n;\n    vector<ll> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    \n    a = diff(diff(a));\n    ll ans = 0;\n    for (int i = 0; i < n; i++)\n        ans += abs(a[i]);\n        \n    cout << ans << '\\n';\n}\n\nSolution 2: Optimized Simulation\nThe only way to alter the number of bacteria on patch $1$ would be for Farmer\nJohn to use $h = 1$. This motivates the idea of first calculating the operations\nthat must be done to make $a_1 = 0$, then $a_2 = 0$, and so on.\nNote that you'll never do both types of operations with the same $h$ value, as\nthey would just undo each other, and doing neither instead of both would get you\nthe same final configuration in a smaller number of operations. \nThis means that we know exactly what set of operations we'll do with $h = 1$: If\n$a_i$ is positive, we'll do $a_i$ operations of type $2$, otherwise we'll do\n$-a_i$ operations of type $1$. Then, we can ignore $a_1$, as it can no longer be\nchanged by any future operation, and continue this process (making sure to\nupdate all array elements when doing an operation). This immediately lends an\n$\\mathcal{O}(n^2)$ solution, as at each index you have to update\n$\\mathcal{O}(n)$ other indices. \nWhat remains is to optimize the simulation of each operation. Let's start by\nconsidering a simpler version of the problem, where an operation adds $1$ to the\nindices after it, instead of $1, 2, \\ldots$ In this version, notice that the\nvalue of an index is only changed by the operations that occurred at another\nindex before it, and all that matters is the difference between the number of\noperations of type $1$ and operations of type $2$. Because of this, instead of\ndirectly updating the values, you can just keep track of the number of\noperations that have occurred, and update the value when it is iterated over.\nIn this version, you can do something similar, except you have to keep track of\ntwo things: the difference between the number of operations of type $1$ and the\nnumber of operations of type $2$, as well as the total amount the operations\nadd. As an example, let's say that there were $3$ more operations of type $1$\nthan $2$ at indices $\\leq 5$, and those operations increased the value of $a_5$\nby $4$. Then, because the contribution of each operation of type $1$ increases\nby $1$, and the contribution of each element of type $2$ decreases by $1$, the\ncontribution of all of the operations increases by exactly $3$. Therefore, the\nvalue of $a_6$ will increase by exactly $4 + 3 = 7$ due to the operations. In\nthis way, we can calculate the contribution of the operations without having to\ndirectly simulate them, lending us an $\\mathcal{O}(n)$ solution.\nRohin Garg's code:\n\n#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\n \nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n   \n    int n; cin >> n;\n    vector<ll> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n   \n    ll ans = 0;\n    ll contribution = 0;\n    ll cnt_ops = 0;\n    for (int i = 0; i < n; i++) {\n        contribution += cnt_ops;\n        a[i] += contribution;\n        \n        ll cur_ops = -a[i];\n        ans += abs(cur_ops);\n        cnt_ops += cur_ops;\n        contribution += cur_ops;\n    }\n    \n    cout << ans << '\\n';\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1356_platinum_cowntact_tracing": {"name": "Cowntact Tracing", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1356", "test_data_link": "http://www.usaco.org/current/data/prob1_platinum_dec23.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob1_platinum_dec23.html", "contest_link": "http://www.usaco.org/index.php?page=dec23results", "inner_contest_link": null, "problem_level": "platinum", "cp_id": "1356", "problem_id": "1356_platinum_cowntact_tracing", "description": "\nFarmer John has $N$ ($2\\le N\\le 10^5$) cows labeled $1\\dots N$, where the \nconnections between cows are described by a tree. Unfortunately, there is a\nsickness spreading throughout. \n\nInitially, some cows start off infected. Every night, an infected cow spreads\nthe sickness to their neighbors. Once a cow is infected, she stays infected.\nAfter some amount of nights, Farmer John realizes that there is an issue so he\ntests his cows to determine who has the sickness.  \n\nYou are given $Q$ ($1\\le Q\\le 20$) different values for the number of nights, \neach an integer in the range $[0,N]$.  For each number of nights, determine the\nminimum number of cows that could have  started with the illness, or that the\nnumber of nights is inconsistent with the given information.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$.\n\nThe next line contains a bit string of length $N$, where the $i$th bit is 1  if\nthe $i$th cow is infected and 0 otherwise. At least one cow is infected.\n\nThe next $N-1$ lines contain the edges of the tree.\n\nThen $Q$, followed by the $Q$ values for the number of nights.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\n$Q$ lines, the answers for each number of nights, or $-1$ if impossible.\n\nSAMPLE INPUT:\n5\n11111\n1 2\n2 3\n3 4\n4 5\n6\n5\n4\n3\n2\n1\n0\nSAMPLE OUTPUT: \n1\n1\n1\n1\n2\n5\n\nFor the first four queries, one possibility is that just cow 3 started with the\nillness. For the fifth query (1 night), one possibility is that cows 2 and 4\nstarted with the illness. For the sixth query (0 nights), one possibility is\nthat all five cows started with the illness.\n\nSAMPLE INPUT:\n10\n1111111111\n1 2\n2 3\n2 4\n2 5\n2 6\n6 7\n7 8\n8 9\n9 10\n11\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nSAMPLE OUTPUT: \n10\n3\n2\n1\n1\n1\n1\n1\n1\n1\n1\n\nFor the first query (0 nights), one possibility is that all ten cows started\nwith the illness. For the second query (1 night), one possibility is that cows\n2, 7, and 9 started with the illness. For the third query (2 nights), one\npossibility is that cows 2 and 9 started with the illness. For the fourth to\neleventh queries, one possibility is that just cow 7 started with the illness.\n\nSAMPLE INPUT:\n5\n11100\n1 2\n2 3\n3 4\n4 5\n6\n0\n1\n2\n3\n4\n5\nSAMPLE OUTPUT: \n3\n1\n1\n-1\n-1\n-1\n\nFor the first query (0 nights), one possibility is that cows 1, 2, and 3 started\nwith the illness. For the second query (1 night), one possibility is that just\ncow 2 started with the illness. For the third query (2 nights), one possibility\nis that just cow 1 started with the illness. For the fourth through sixth\nqueries, there is no consistent possibility.\n\nSCORING:\nInputs 4-5: $N \\le 10$Inputs 6-8: All cows are infected.Inputs 9-11: $N \\le 400$Inputs 12-23: No additional restrictions.\n\n\nProblem credits: Suhas Nagar and Brandon Wang\n", "num_tests": 23, "solution": "\n(Analysis by Brandon Wang, Richard Qi, Benjamin Qi)\nIn all solutions, the overall time complexity will be $Q$ times the time\ncomplexity to answer a single query.\nFirst, let $I$ be the set of infected cows and let $T$ be the number of nights\nin a given query. We first analyze whether or not $I$ is even a valid\nconfiguration. Note that a cow $v$ can start out infected if and only if the set\n$B_T(v) = \\{u \\colon d(u, v) \\leq T\\}$ is  contained entirely in $I$. Let $S$ be\nthe set of cows that can start out infected. Then, $I$ is a valid configuration\nif and only if $I = \\bigcup_{v\\in S} B_T(v)$. Furthermore, when $I$ is a valid\nconfiguration, we want to find the smallest possible subset $S'\\subseteq S$ \nsuch that $\\bigcup_{v\\in S'} B_T(v) = I$.\nTo compute the set $S$, we need to know the shortest distance from each cow to\nits closest non-infected cow. This can be done in $O(N)$ time by starting a\nmultisource BFS from all non-infected cows.\nSubtask 1 ($N = 10$):\nFor this case, we can just brute force through all subsets $S'$ of $S$. For each\n$v\\in S'$, we can do a BFS to find $B_T(v)$, and check if the resulting sets\ncover $I$. This takes $O(2^N \\cdot N^2)$ time per query.\nBrandon's code:\n\nN = int(input())\ninfected = [c == '1' for c in input()]\nadj = [[] for _ in range(N)]\n\nfor _ in range(1, N):\n    u, v = [int(x) for x in input().split()]\n    adj[u-1].append(v-1)\n    adj[v-1].append(u-1)\n\ndist = []\n\nfor u in range(N):\n    dist.append([N+1 for _ in range(N)])\n    bfs_queue = []\n    dist[u][u] = 0\n    bfs_queue.append(u)\n    bfs_queue_idx = 0\n    while len(bfs_queue) != bfs_queue_idx:\n        v = bfs_queue[bfs_queue_idx]\n        for w in adj[v]:\n            if dist[u][w] > dist[u][v] + 1:\n                dist[u][w] = dist[u][v] + 1\n                bfs_queue.append(w)\n        bfs_queue_idx += 1\n\ndef works(Sprime, T):\n    infected_by_Sprime = [False for _ in range(N)]\n    for u in Sprime:\n        for v in range(N):\n            if dist[u][v] <= T:\n                infected_by_Sprime[v] = True\n    for u in range(N):\n        if infected_by_Sprime[u] != infected[u]:\n            return False\n    return True\n\ndef query(T):\n    S = []\n    for u in range(N):\n        u_works = True\n        for v in range(N):\n            if dist[u][v] <= T and not infected[v]:\n                u_works = False\n        if u_works:\n            S.append(u)\n    \n    if not works(S, T):\n        return -1\n    ans = len(S)\n    for i in range(2**len(S)):\n        Sprime = []\n        for j in range(len(S)):\n            if i // (2**j) % 2 == 1:\n                Sprime.append(S[j])\n        if works(Sprime, T):\n            ans = min(ans, len(Sprime))\n    return ans\n\nQ = int(input())\nfor _ in range(Q):\n    T = int(input())\n    print(query(T))\n\nSubtask 2 (all cows infected):\nWe can answer each query in $O(N)$ time using a greedy strategy. First, some\ndefinitions: \n\"Choosing\" a cow means that we set it to be initially infected.A cow is \"covered\" if it is within a distance $T$ of some chosen cow.\nOur goal in this subtask is to choose the minimum number of cows so that all\ncows are covered.\nRoot the tree at any cow (the solution code roots the tree at the first cow). \nThe following greedy procedure covers all the cows in $c$'s subtree at a\ndistance at least $T$ away from $c$:\nRecursively apply the procedure to the subtrees of $c$'s children.Compute the distance from $c$ to its farthest uncovered descendant\n(guaranteed to be at most $T$).If the distance in step 2 is exactly $T$, choose cow $c$. Now, all cows in\n$c$'s subtree are covered.Special case: If $c$ is the root and there is an uncovered descendant of\n$c$, choose $c$.Return the distance from $c$ to its farthest uncovered descendant if such a\ndescendant exists (such a descendant will later be covered by some cow outside\nof $c$'s subtree), or otherwise the distance from $c$ to its closest chosen\ndescendant (this descendant has the potential to cover cows outside of $c$'s\nsubtree).\nIn addition, this procedure constructs an optimal solution because \nIf the distance from step 2 is less than $T$, and $c$ is not the root of the\ntree, it is always at least as good to choose the parent of $c$ instead of $c$,\nsince choosing the parent of $c$ will cover all the uncovered cows inside of\n$c$'s subtree and more cows outside of $c$'s subtree. Thus, we should not choose\n$c$.If the distance from step 2 is exactly $T$ and we have already fixed which\ncows to choose in each of the child subtrees, then cow $c$ is the only cow that\ncan cover the uncovered descendant, so we must choose $c$.\nBen's code:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\n#define mp make_pair\n#define f first\n#define s second\n\n#define sz(x) int((x).size())\n#define rsz resize\n#define pb push_back\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define rep(a) F0R(_, a)\n\nvector<vi> adj;\nstring infected;\nint N;\n\nint n, ans;\n\n// state:\n// dist d to closest chosen: {1, d}\n// dist d to farthest uncovered: {-1, d}\n\npi comb(pi a, pi b) {\n\tif (a > b) swap(a, b);\n\tif (b.f == -1) return max(a, b);\n\tif (a.f == 1) return min(a, b);\n\tassert(a.f == -1 && b.f == 1);\n\tif (a.s + b.s > n) return a;  // uncovered\n\treturn b;                     // covered\n}\n\npi dfs(int x, int p) {  // cover x's subtree\n\tpi best{-1, 0};\n\tfor (int y : adj[x])\n\t\tif (y != p) {\n\t\t\tpi d = dfs(y, x);\n\t\t\t++d.s;\n\t\t\tbest = comb(best, d);\n\t\t}\n\tif (best.f == -1 && (best.s == n || x == 0)) {  // need to choose x\n\t\tbest = {1, 0};\n\t\t++ans;\n\t}\n\treturn best;\n}\n\nint query() {\n\tans = 0;\n\tdfs(0, -1);\n\treturn ans;\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> N;\n\tcin >> infected;\n\tadj.rsz(N);\n\trep(N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t\tadj.at(a).pb(b), adj.at(b).pb(a);\n\t}\n\tint Q;\n\tcin >> Q;\n\trep(Q) {\n\t\tcin >> n;\n\t\tcout << query() << \"\\n\";\n\t}\n}\n\nSubtask 3 ($N\\leq 400$) Solution 1 (DP):\nOur approach for the remaining subtasks will be to use a tree-dp type approach. \nAs in the subtask 2 solution, root the tree arbitrarily. Unfortunately, just\nmaking the DP state \"min # of originally infected cows to cover subtree of $v$\" \ndoes not provide enough info, because we can cover infected nodes in a subtree\nvia starting cows outside the subtree.\nInstead, for each $0 \\leq t \\leq T$, we store the following:\n The min number of nodes we need to pick in the subtree such that all\ninfected cows with distance $\\ge t$ from the subtree root are covered, and  The min number of nodes we need to pick in the subtree such that all\ninfected cows are covered, plus our coverage extends distance $t$ outside the\ntree as well.\nWe can compute each of these in $O(\\# \\text{children})$ time given the\nchildren's DP states,  so this takes a total of $O(TN)$ per query. Since\n$T\\leq N$, this takes $O(N^2)$, which runs in time.\nSubtask 3 Solution 2 (Greedy):\nWe will describe an algorithm where initially we start with no chosen cows,  and\nwe greedily choose cows in $S$ until every infected cow is covered. \nDefine $U$ to be the set of nodes that have not been covered yet. Root the tree\narbitrarily and consider the highest depth infected cow $c \\in U$, where depth\nis defined as distance from the root. \nLet $S_c$ be all elements of $S$ that are distance within $T$ of $c$. Clearly,\nwe must choose some element $s \\in S_c$.\nWe claim that we can greedily choose the lowest depth node $s' \\in S_c$. \nConsider some other node $s \\in S_c$. For our greedy to be correct, it suffices\nto show that for all nodes $u \\in U$, if $s$ covers $u$, then $s'$ also covers\n$u$.\nThis is easy to prove if $s$ and $s'$ are both ancestors of $c$. Now, suppose\none of them is not an ancestor of $c$. Define $l = lca(c, s)$ and\n$l' = lca(c, s')$. Notice that $s$ covers all uncovered nodes $u \\in U$ that are\nalso in the subtree rooted at $l$ because $c$ is the highest depth uncovered\nnode, and similarly $s'$ covers all uncovered nodes in the subtree rooted at\n$l'$. From this, one can prove that $s$ covers the same uncovered nodes as the\nunique node with the same depth as $s$ which is also an ancestor of $c$.\nCombining this with the proof for the case where $s$ and $s'$ are both ancestors\nof $c$, the greedy is proven.\nSo, the algorithm is to repeatedly find the highest depth node $c$ that has not\nbeen covered, and choose the lowest depth node in $S_c$ to cover it. This can be\ndone naively in $O(N^2)$ per query (though on most test cases, it runs much\nfaster than this worst-case bound would suggest).\nRichard's code: \n\n#include <bits/stdc++.h>\nusing namespace std;\n \nconst int MOD = 1e9+7;\nconst int mx = 100005;\n \nint N;\nint dist_to_nonsick[mx];\nvector<int> adj[mx];\nint depth[mx];\nvector<int> sorted_by_depth;\nstring sick;\nint k;\n \nvoid genDepth(int node, int p = -1, int d = 0){\n\tdepth[node] = d;\n\tfor(auto u: adj[node]){\n\t\tif(u == p) continue;\n\t\tgenDepth(u, node, d+1);\n\t}\n}\n \nint dist_to_coverer[mx];\n \nint searchForCoverer(int node, int p = -1, int d = 0){\n\tpair<int, int> res = make_pair(MOD, -1);\n\tif(dist_to_nonsick[node] > k){\n\t\tres = min(res, make_pair(depth[node], node));\n\t}\n \n\tif(d+1 <= k){\n\t\tfor(auto u: adj[node]){\n\t\t\tif(u == p) continue;\n\t\t\tint other_res = searchForCoverer(u, node, d+1);\n\t\t\tif(other_res != -1){\n\t\t\t\t//keep track of minimum depth node within distance k\n\t\t\t\tres = min(res, make_pair(depth[other_res], other_res));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn res.second;\n}\n \nvoid setCoverer(int node, int d = 0){\n\tif(dist_to_coverer[node] <= d){\n\t\treturn;\n\t}\n\tdist_to_coverer[node] = d;\n\t\n\tfor(auto u: adj[node]){\n\t\tsetCoverer(u, d+1);\n\t}\n}\n \nvoid solve(int _k){\n\tk = _k;\n\tfor(int i = 1; i <= N; i++){\n\t\tdist_to_coverer[i] = k+1; //minimum distance to a coverer\n\t}\n \n\tint ans = 0;\n\tfor(int i = int(sorted_by_depth.size())-1; i >= 0; i--){ //start with highest depth nodes\n\t\tint to_cover = sorted_by_depth[i];\n\t\tif(sick[to_cover] == '0') continue;\n\t\tif(dist_to_coverer[to_cover] <= k) continue;\n \n\t\t//this node must be covered\n\t\tans++;\n\t\tint coverer = searchForCoverer(to_cover);\n \n\t\tif(coverer == -1){ //can't be covered\n\t\t\tans = -1;\n\t\t\tbreak;\n\t\t}\n \n\t\t//update dist_to_coverer\n\t\tsetCoverer(coverer);\n\t}\n\tcout << ans << \"\\n\";\n}\n \nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> N;\n\tcin >> sick; sick = \"?\" + sick;\n\tfor(int i = 1; i <= N-1; i++){\n\t\tint a, b; cin >> a >> b;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n \n\t// Compute minimum distance to a cow that is not sick with BFS\n\tfor(int i = 1; i <= N; i++){\n\t\tdist_to_nonsick[i] = MOD;\n\t}\n\tqueue<pair<int, int>> nonsick_q;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(sick[i] == '0'){\n\t\t\tnonsick_q.push(make_pair(i, 0));\n\t\t\tdist_to_nonsick[i] = 0;\n\t\t}\n\t}\n \n\twhile(nonsick_q.size()){\n\t\tpair<int, int> a = nonsick_q.front(); nonsick_q.pop();\n\t\tint node = a.first;\n\t\tint d = a.second;\n\t\tif(dist_to_nonsick[node] < d) continue;\n\t\tfor(auto u: adj[node]){\n\t\t\tif(dist_to_nonsick[u] > d+1){\n\t\t\t\tdist_to_nonsick[u] = d+1;\n\t\t\t\tnonsick_q.push(make_pair(u, dist_to_nonsick[u]));\n\t\t\t}\n\t\t}\n\t}\n \n\tgenDepth(1);\n \n\t//sort nodes by depth\n\tfor(int i = 1; i <= N; i++) sorted_by_depth.push_back(i);\n\tsort(begin(sorted_by_depth), end(sorted_by_depth), [&](int a, int b){\n\t\treturn depth[a] < depth[b];\n\t});\n \n\tint Q; cin >> Q;\n\tfor(int i = 1; i <= Q; i++){\n\t\tint nights; cin >> nights;\n\t\tsolve(nights);\n\t}\n}\n\nFull Solution 1:\nWe will answer each query in $O(N)$. This solution follows from  generalizing\nthe subtask 2 greedy solution or removing unnecessary states from the subtask 3\nDP solution (it turns out that we need to keep at most two states for each\nsubtree). For a node $v$, let $closest_S(v)$ denote the distance from $v$ to its\nclosest node in\n$S$.\nFor any vertex $v$, let $I_v$ be the set of infected cows in $v$'s subtree, and\nlet $S_v$ be the set of source cows in $v$'s subtree. In addition, let $I_v'$ be\nthe set of infected cows in $v$'s subtree that are distance greater than\n$T-closest_S(parent_v)$ away from $parent_v$. When all cows are infected, $I_v'$\nis precisely the set of all cows in $v$'s subtree distance at least $T$ away\nfrom $v$.  Observe that every node in $I_v'$ must be covered by some node\ninside $v$'s subtree, and every node in $I_v\\setminus I_v'$ would be covered by\nchoosing the closest cow to $parent_v$. Intuitively, $I_v\\setminus I_v'$ is the\nset of all cows in $v$'s subtree that might be covered by some node outside of\n$v$'s subtree (though they might instead be covered by some node inside $v$'s\nsubtree).\nLet $f(v)$ be the smallest number of nodes in $S_v$ we need to pick so that\nevery node in $I_v'$ is covered. Clearly $f(v) \\geq \\sum_{u\\in C_v} f(u)$. In\nfact the following is also true:\nLemma: $f(v) \\leq 1 + \\sum_{u\\in C_v} f(u)$.\nProof: We will show that all of $I_v$ can be covered by at most\n$1 + \\sum_{u\\in C_v} f(u)$ source nodes (one of which need not be in $v$'s\nsubtree). Choosing all of these source nodes (excluding any outside of $v$'s\nsubtree) would cover $I_v'$.\nSuppose that, in each subtree, we pick $f(u)$ sources in $S_u$ that cover\n$I_u'$, and also we are in the best possible DP state (states are defined in the\nsolution above). Here, \"every infected node in $u$'s subtree is covered, as is\neverything distance $T$ outside of $u$\" is the best case, followed by \"every\ninfected node in $u$'s subtree is covered, as is everything distance $T-1$\noutside of $u$\", etc.,  and then \"every infected node $u$'s subtree is covered,\nbut nothing outside the subtree is\" is better than  \"every infected node in\n$u$'s subtree is covered except $u$\", which is better than \"the deepest\nuncovered infected node is at depth 1\", which is better than \"the deepest\nuncovered infected node is at depth 2\", etc.\nNow, suppose $u_1, \\ldots, u_k$ are the children such that\n$I_{u_1}, \\ldots, I_{u_k}$ are not fully covered. Suppose their deepest\nuncovered children are at depth $d_1, \\ldots, d_k$, respectively with respect to\n$v$.  Without loss of generality suppose $d_1 = \\max(d_1, \\ldots, d_k)$. By\nassumption,  there exists some source node $w$ such that\n$d(w, parent_{u_1})=d(w,v) \\leq T - d_1$. Then, $d(w, v) \\leq T-d_i$ for every\n$i$, so adding $w$ to the set of sources covers all of $I_v$. This completes the\nproof (note that $w$ covers $v$ if needed also). $\\Box$\nSince the answer to the query is just $f(\\text{root})$, we just need to figure\nout when the difference $f(v) - \\sum_{u\\in C_v} f(u)$ is $0$ or $1$. To do this,\nwhen computing the DP, we additionally store what the \"best case\" is. We can do\nthis in $O(\\#\\text{children})$ for each node with some preprocessing. Then, the\ndifference is one precisely when there is an uncovered node in $I_v'$, in which\ncase we can choose the closest node in $S$ to $v$. This newly chosen node is\nguaranteed to cover all uncovered nodes in $I_v$ (any nodes in $v$'s subtree not\ncovered by this new node are part of $I_c'$ for some child $c$ of $v$, which\nshould have been covered already). Note that due to our earlier observation\nabout $I_v'$, this node will be in $v$'s subtree.\nBen's code:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\n#define mp make_pair\n#define f first\n#define s second\n\n#define sz(x) int((x).size())\n#define rsz resize\n#define pb push_back\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define rep(a) F0R(_, a)\n\nvector<vi> adj;\nstring infected;\nvi closest_not_infected;\nint N;\n\nvi closest_ok;\nint n, ans;\n\n// state:\n// dist d to closest chosen: {1, d}\n// dist d to farthest uncovered: {-1, d}\n// nothing: {0, 0}\n\npi comb(pi a, pi b) {\n\tif (a > b) swap(a, b);\n\tif (a.f == 0) return b;\n\tif (b.f == 0) return a;\n\tif (b.f == -1) return max(a, b);\n\tif (a.f == 1) return min(a, b);\n\tassert(a.f == -1 && b.f == 1);\n\tif (a.s + b.s > n) return a;  // uncovered\n\treturn b;                     // covered\n}\n\npi dfs(int x, int p) {  // cover x's subtree\n\tpi best{infected.at(x) == '1' ? -1 : 0, 0};\n\tfor (int y : adj[x])\n\t\tif (y != p) {\n\t\t\tpi d = dfs(y, x);\n\t\t\tif (d.f != 0) ++d.s;\n\t\t\tbest = comb(best, d);\n\t\t}\n\tif (best.f == -1) {\n\t\t// check that choosing closest node in S to x would cover everything in\n\t\t// x's subtree\n\t\tassert(best.s + closest_ok.at(x) <= n);\n\t\tif (p == -1 || best.s + 1 + closest_ok[p] > n) {\n\t\t\t// there's something that must be covered by something in x's\n\t\t\t// subtree\n\t\t\t// choose closest node in S to x, which will be in x's\n\t\t\t// subtree\n\t\t\t++ans;\n\t\t\tbest = {1, closest_ok.at(x)};\n\t\t}\n\t}\n\treturn best;\n}\n\nvi multi_bfs(const vi &sources) {\n\tvi ret(N, N + 1);\n\tqueue<int> q;\n\tfor (int i : sources) {\n\t\tret.at(i) = 0;\n\t\tq.push(i);\n\t}\n\twhile (sz(q)) {\n\t\tint x = q.front();\n\t\tq.pop();\n\t\tfor (int y : adj.at(x))\n\t\t\tif (ret.at(x) + 1 < ret.at(y)) {\n\t\t\t\tret.at(y) = ret.at(x) + 1;\n\t\t\t\tq.push(y);\n\t\t\t}\n\t}\n\treturn ret;\n}\n\nint query() {\n\tvi origins;  // S in the analysis\n\tF0R(i, N) if (closest_not_infected.at(i) > n) origins.pb(i);\n\t// distance from each node to closest element of S\n\tclosest_ok = multi_bfs(origins);\n\tF0R(i, N)\n\tif (infected.at(i) == '1' && closest_ok.at(i) > n)\n\t\treturn -1;  // i can't be covered by anything in S\n\tans = 0;\n\tdfs(0, -1);\n\treturn ans;\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> N;\n\tcin >> infected;\n\tadj.rsz(N);\n\trep(N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t\tadj.at(a).pb(b), adj.at(b).pb(a);\n\t}\n\tvi sources;\n\tF0R(i, N) if (infected.at(i) == '0') sources.pb(i);\n\tclosest_not_infected = multi_bfs(sources);\n\tint Q;\n\tcin >> Q;\n\trep(Q) {\n\t\tcin >> n;\n\t\tcout << query() << \"\\n\";\n\t}\n}\n\nFull Solution 2:\nWe can use centroid decomposition in \nthe subtask 3 greedy solution to answer queries in $O(N\\log{N})$.\nSpecifically, using centroid decomposition, we can do the following tasks.\nIn $O(N\\log N)$ time, for every node $v$, find the minimum depth node  $s$\nwithin distance $T$ of $v$ satisfying $s \\in S$.In $O(\\log N)$ time, mark a node as chosen.In $O(\\log N)$ time, compute the distance from a node to its nearest chosen\nnode.\nWe leave the details as an exercise to the reader.\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1357_platinum_a_graph_problem": {"name": "A Graph Problem", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1357", "test_data_link": "http://www.usaco.org/current/data/prob2_platinum_dec23.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob2_platinum_dec23.html", "contest_link": "http://www.usaco.org/index.php?page=dec23results", "inner_contest_link": null, "problem_level": "platinum", "cp_id": "1357", "problem_id": "1357_platinum_a_graph_problem", "description": "\nTo improve her mathematical knowledge, Bessie has been taking a graph theory\ncourse and finds herself stumped by the following problem.  Please help her!\n\nYou are given a connected, undirected graph with vertices labeled $1\\dots N$ and\nedges labeled $1\\dots M$ ($2\\le N\\le 2\\cdot 10^5$, $N-1\\le M\\le 4\\cdot 10^5$).\nFor each vertex $v$ in the graph, the following process is conducted:\n\u200b\nLet $S=\\{v\\}$ and $h=0$.While $|S|<N$, \n\u200b\nOut of all edges with exactly one endpoint in $S$, let $e$ be the edge with\nthe minimum label.Add the endpoint of $e$ not in $S$ to $S$.Set $h=10h+e$.\n\u200b\nReturn $h\\pmod{10^9+7}$.\n\u200b\nDetermine all the return values of this process.\n\u200b\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$ and $M$.\n\u200b\nThen follow $M$ lines, the $e$th containing the endpoints $(a_e,b_e)$ of the \n$e$th edge ($1\\le a_e<b_e\\le N$). It is guaranteed that these edges form a\nconnected graph, and at most one edge connects each pair of vertices.\n\n\u200b\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput $N$ lines, where the $i$th line should contain the return value of the\nprocess starting at vertex $i$.\n\nSAMPLE INPUT:\n3 2\n1 2\n2 3\nSAMPLE OUTPUT: \n12\n12\n21\n\nSAMPLE INPUT:\n5 6\n1 2\n3 4\n2 4\n2 3\n2 5\n1 5\nSAMPLE OUTPUT: \n1325\n1325\n2315\n2315\n5132\n\nConsider starting at $i=3$. First, we choose edge $2$, after which\n$S = \\{3, 4\\}$ and $h = 2$. Second, we choose edge $3$, after which\n$S = \\{2, 3, 4\\}$ and $h = 23$. Third, we choose edge $1$, after which\n$S = \\{1, 2, 3, 4\\}$ and $h = 231$. Finally, we choose edge $5$, after which\n$S = \\{1, 2, 3, 4, 5\\}$ and $h = 2315$. The answer for $i=3$ is therefore\n$2315$.\n\nSAMPLE INPUT:\n15 14\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n9 10\n10 11\n11 12\n12 13\n13 14\n14 15\nSAMPLE OUTPUT: \n678925929\n678925929\n678862929\n678787329\n678709839\n678632097\n178554320\n218476543\n321398766\n431520989\n542453212\n653475435\n764507558\n875540761\n986574081\n\nMake sure to output the answers modulo $10^9+7$.\n\nSCORING:\nInput 4: $N,M\\le 2000$Inputs 5-6: $N\\le 2000$Inputs 7-10: $N\\le 10000$Inputs 11-14: $a_e+1=b_e$ for all $e$Inputs 15-23: No additional constraints.\n\n\nProblem credits: Benjamin Qi\n", "num_tests": 23, "solution": "\n(Analysis by Andrew Gu, Anand John)\nSubtask 1:\nWe can directly perform the process according to the problem statement. Maintain\na priority queue of edges between $S$ and $[N]\\setminus S$ to find the one with\nthe minimum label. This will take $O(M\\log N)$ time. We should also maintain the\nvalue of $h\\pmod{10^9+7}$ rather than $h$ itself. Overall, the runtime is\n$O(NM\\log N)$.\nSubtask 2:\nObserve that the edges are chosen according to Prim's algorithm, which will find\na minimum spanning tree.  We can do a first pass to find the minimum spanning\ntree and only keep the $N-1$ edges that are part of it.  Then use the solution\nof subtask 1 to solve the problem in $O(N^2\\log N)$ time.\nSubtask 3:\nObserve that the edges are selected according to Prim's algorithm, so they will\nalways form the unique minimum spanning tree of the graph. We need to understand\nhow the answers for different vertices are related. Assume that instead of the\n$h = 10h+e$ operation, $h$ is an array and we append $e$ to it. Given an array,\nwe can retrieve the original value, e.g. $[1, 20, 9] \\mapsto 309$. Then we may\ncalculate the arrays for all vertices at once using Kruskal's algorithm as\nfollows:\nInitially, every vertex has an empty array.When we have an edge $e = (u, v)$ which connects two components, let $h_u$\nand $h_v$ be the current arrays for $u$ and $v$, respectively. First, append $e$\nto every vertex in one of the two components. Then append $h_u$ to every vertex\nin the connected component of $v$ and vice versa.\nThis is because when the edge $(u, v)$ is added, the next edges that Prim's\nalgorithm will explore are exactly what was obtained by starting at $u$. There\nare $N-1$ useful edges and we update the $h$ values for $O(N)$ vertices in each\nstep, but maintaining the whole array adds an extra factor of $N$. Instead of\nmaintaining the whole array, we maintain the ordered pair of length and value\n$\\pmod{10^9+7}$. These take $O(1)$ memory and can be combined in $O(1)$ time if\nwe precalculate the powers of $10$ (see the code for details). The overall time\ncomplexity is $O(N^2+M\\alpha(N))$.\nImplementation (note that we overload the \"+\" operator):\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9+7;\nconst int N = 2e5+5;\nint pw[N], fa[N];\n\nvector<int> component[N];\n\nusing val = pair<int, int>; // (len, residue)\n\nval operator + (const val& a, const val& b) {\n  return {a.first+b.first, (1LL*pw[b.first]*a.second+b.second)%MOD};\n}\n\nval& operator += (val& a, const val& b) {\n  a = a + b;\n  return a;\n}\n\nval res[N];\n\nint root(int x) {\n  return (fa[x] == x ? x : fa[x] = root(fa[x]));\n}\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n  pw[0] = 1;\n  for (int i = 1; i < N; i++) pw[i] = 10LL*pw[i-1]%MOD;\n  iota(fa, fa+N, 0);\n  int n, m;\n  cin >> n >> m;\n\n  for (int i = 0; i < n; i++) component[i].emplace_back(i);\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--, v--;\n    int ru = root(u);\n    int rv = root(v);\n    if (ru != rv) {\n      val du = make_pair(1, i) + res[u];\n      val dv = make_pair(1, i) + res[v];\n      for (int x: component[ru]) res[x] += dv;\n      for (int x: component[rv]) res[x] += du;\n      fa[ru] = rv;\n      component[rv].insert(component[rv].end(), component[ru].begin(), component[ru].end());\n    }\n  }\n  for (int i = 0; i < n; i++) cout << res[i].second << '\\n';\n}\n\nNote that in following parts, we will use \"value\" to refer to these ordered\npairs in the code above and \"addition\" to the operation that combines them.\nSubtask 4:\nAccording to the condition, the connected components will always be consecutive\nranges. We need to be able to obtain the value at a particular point and add a\nvalue on a range. This can be done with a segment tree, solving the problem in\n$O(M\\log N)$ time. (This is idea is part of full solution 2, so refer to that for\nthe implementation.)\nFull solution 1:\nLet's maintain a disjoint-set union with only path compression with the\nfollowing invariant: at any point, to obtain the current value at a vertex $v$,\nstart at $v$ and walk up to the root in the data structure, adding up all the\nvalues along the way in order. Note that we can perform path compression here by\nalso updating the values as we compress. Recall that to perform an update of\nconnecting $u$ and $v$, we must add $(1, i) + h_u$ to everything in the\ncomponent of $v$ and $(1, i) + h_v$ to everything in the component of $u$, then\ncombine the components.  This can be done as follows:\nAdd $h_u$ to the vertex at the root of $v$'s component in the data\nstructure, and vice versa.Make the two roots children of a new vertex in the data structure with value\n$0$. This vertex won't correspond to any of the vertices in the original\ngraph.\nThe time complexity of the below implementation is $O(M\\log N)$ because we use a\ndisjoint set union with only path compression, not union by rank. This can be\ntheoretically improved by using a separate data structure to find the minimum\nspanning tree but there is no practical improvement in speed.\nImplementation:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9+7;\nconst int N = 4e5+5;\nint pw[N], fa[N];\n\nusing val = pair<int, int>; // (len, residue)\n\nval operator + (const val& a, const val& b) {\n  return {a.first+b.first, (1LL*pw[b.first]*a.second+b.second)%MOD};\n}\n\nval dp[N];\n\nint root(int x) {\n  if (fa[x] == x) return x;\n  int v = root(fa[x]);\n  if (fa[x] == v) return v;\n  dp[x] = dp[x] + dp[fa[x]];\n  return fa[x] = v;\n}\n\nval get(int x) {\n  return root(x) == x ? dp[x] : dp[x] + get(fa[x]);\n}\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n  pw[0] = 1;\n  for (int i = 1; i < N; i++) pw[i] = 10LL*pw[i-1]%MOD;\n  iota(fa, fa+N, 0);\n  int n, m;\n  cin >> n >> m;\n\n  int next_vtx = n;\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--, v--;\n    int ru = root(u), rv = root(v);\n    if (ru == rv) continue;\n    val du = get(u), dv = get(v);\n    dp[ru] = dp[ru] + make_pair(1, i) + dv;\n    dp[rv] = dp[rv] + make_pair(1, i) + du;\n    fa[ru] = fa[rv] = next_vtx++;\n  }\n  for (int i = 0; i < n; i++) cout << get(i).second << '\\n';\n}\n\nFull solution 2:\nIt turns out that we can relabel the vertices of the tree in such a way that as\nwe perform Kruskal's algorithm, the connected components are always consecutive\nranges of numbers. First, we explain how to find the relabeling in a first pass\nof creating the minimum spanning tree.  For every connected component, maintain\na rightmost vertex and a leftmost vertex. When an edge between $u$ and $v$ is\nformed, we declare that the label of the leftmost vertex of $v$'s component will\nbe one more than the label of the rightmost vertex of $u$'s component. The\nleftmost vertex of the combined component is the leftmost vertex of $u$'s\ncomponent and the rightmost vertex is the rightmost vertex of $v$'s component.\nAfter forming all these consecutive pairs, we can compute the correct labeling.\nWith the relabeling, we can use the approach of subtask 4 to solve the problem\nin $O(M\\log N)$ time.\nImplementation:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9+7;\nconst int N = 2e5+5;\nint pw[N], fa[N], L[N], R[N], nxt[N], relabel[N];\n\nusing val = pair<int, int>; // (len, residue)\n\nval operator + (const val& a, const val& b) {\n  return {a.first+b.first, (1LL*pw[b.first]*a.second+b.second)%MOD};\n}\n\nval& operator += (val& a, const val& b) {\n  a = a + b;\n  return a;\n}\n\nval lazy[4*N], cur[4*N];\n\nvoid push(int v) {\n  lazy[2*v] += lazy[v];\n  cur[2*v] += lazy[v];\n  lazy[2*v+1] += lazy[v];\n  cur[2*v+1] += lazy[v];\n  lazy[v] = make_pair(0, 0);\n}\n\nval query(int v, int tl, int tr, int i) {\n  if (tl == tr) return cur[v];\n  push(v);\n  int tm = (tl+tr)/2;\n  if (i <= tm) return query(2*v, tl, tm, i);\n  else return query(2*v+1, tm+1, tr, i);\n}\n\nvoid add_on_range(int v, int tl, int tr, int l, int r, val x) {\n  if (l > tr || r < tl) return;\n  if (l <= tl && tr <= r) {\n    cur[v] += x;\n    lazy[v] += x;\n    return;\n  }\n  push(v);\n  int tm = (tl+tr)/2;\n  add_on_range(2*v, tl, tm, l, r, x);\n  add_on_range(2*v+1, tm+1, tr, l, r, x);\n}\n\nint root(int x) {\n  return fa[x] == x ? x : fa[x] = root(fa[x]);\n}\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n  pw[0] = 1;\n  for (int i = 1; i < N; i++) pw[i] = 10LL*pw[i-1]%MOD;\n  iota(fa, fa+N, 0);\n  iota(L, L+N, 0);\n  iota(R, R+N, 0);\n  int n, m;\n  cin >> n >> m;\n\n  // find the relabeling\n  vector<tuple<int, int, int>> useful_edges;\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    cin >> u >> v;\n    int ru = root(u);\n    int rv = root(v);\n    if (ru == rv) continue;\n    useful_edges.emplace_back(u, v, i);\n    nxt[R[ru]] = L[rv];\n    fa[ru] = rv;\n    L[rv] = L[ru];\n  }\n  vector<int> seq;\n  int v = L[root(1)];\n  seq.push_back(v);\n  while (nxt[v]) {\n    v = nxt[v];\n    seq.push_back(v);\n  }\n  assert(seq.size() == n);\n  for (int i = 0; i < n; i++) relabel[seq[i]] = i+1;\n\n  // apply subtask 4 solution\n  iota(fa, fa+N, 0);\n  iota(L, L+N, 0);\n  iota(R, R+N, 0);\n  for (auto& [u, v, i]: useful_edges) {\n    u = relabel[u];\n    v = relabel[v];\n    val du = query(1, 1, n, u);\n    val dv = query(1, 1, n, v);\n    u = root(u);\n    v = root(v);\n    add_on_range(1, 1, n, L[u], R[u], make_pair(1, i) + dv);\n    add_on_range(1, 1, n, L[v], R[v], make_pair(1, i) + du);\n    fa[u] = v;\n    L[v] = min(L[v], L[u]);\n    R[v] = max(R[v], R[u]);\n  }\n  for (int i = 1; i <= n; i++) cout << query(1, 1, n, relabel[i]).second << '\\n';\n}\n\nFull solution 3:\nWe can actually optimize the solution in subtask 3 using small-to-large merging.\nNote that only two different values are being added each time we add an edge\n$(u,v)$: $h_u$, and $h_v$. WLOG assume $u$ is in the smaller component by size.\nThen, we can normally add $h_v-h_u$ to each node in the component of $u$ and\nhave a lazy value that tells us to add $h_u$ to each node in the newly merged\ncomponent. Because we only add directly to the smaller component, we only do\n$O(N\\log N)$ additions. We can perform subtraction like this since the $h\\mapsto\n10h+e$ operation is invertible. Specifically, it inverts to $h\\mapsto (h-e)/10$.\nThis gives a total time complexity of $O(N\\log N + M)$.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9+7;\nconst int N = 2e5+5;\nint pw[N], ipw[N], fa[N], sz[N];\n\nvector<int> component[N];\n\nusing val = pair<int, int>; // (len, residue)\n\nval operator + (const val& a, const val& b) {\n  return {a.first+b.first, (1LL*pw[b.first]*a.second+b.second)%MOD};\n}\n\nval& operator += (val& a, const val& b) {\n  a = a + b;\n  return a;\n}\n\nval operator - (const val& a, const val& b) {\n  return {a.first-b.first, 1LL*(a.second-b.second+MOD)*ipw[b.first]%MOD};\n}\n\nval lazy[N], res[N];\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n  pw[0] = ipw[0] = 1;\n  for (int i = 1; i < N; i++) pw[i] = 10LL*pw[i-1]%MOD;\n  //700000005 = 10^-1 mod 1e9+7\n  for (int i = 1; i < N; i++) ipw[i] = 700000005LL*ipw[i-1]%MOD;\n\n  iota(fa, fa+N, 0);\n  fill(sz, sz+N, 1);\n  int n, m;\n  cin >> n >> m;\n\n  for (int i = 0; i < n; i++) component[i].emplace_back(i);\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--, v--;\n    int ru = fa[u];\n    int rv = fa[v];\n\n    if (ru != rv) {\n      // ensure that u is part of the smaller component\n      if(sz[ru] > sz[rv]) swap(u,v), swap(ru, rv);\n\n      val du = make_pair(1, i) + res[u] + lazy[ru];\n      val dv = make_pair(1, i) + res[v] + lazy[rv];\n      lazy[rv] += du;\n      for (int x: component[ru]) res[x] += lazy[ru] + dv - lazy[rv];\n\n      for (int x: component[ru]) fa[x] = rv;\n      sz[rv] += sz[ru];\n      component[rv].insert(component[rv].end(), component[ru].begin(), component[ru].end());\n    }\n  }\n  for (int i = 0; i < n; i++) res[i] += lazy[fa[i]];\n  for (int i = 0; i < n; i++) cout << res[i].second << '\\n';\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1358_platinum_train_scheduling": {"name": "Train Scheduling", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1358", "test_data_link": "http://www.usaco.org/current/data/prob3_platinum_dec23.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob3_platinum_dec23.html", "contest_link": "http://www.usaco.org/index.php?page=dec23results", "inner_contest_link": null, "problem_level": "platinum", "cp_id": "1358", "problem_id": "1358_platinum_train_scheduling", "description": "\n**Note: The memory limit for this problem is 512MB, twice the default.**\nBessie has taken on a new job as a train dispatcher! There are two train\nstations: $A$ and $B$. Due to budget constraints, there is only a single track\nconnecting the stations. If a train departs a station at time $t$, then it will\narrive at the other station at time $t+T$ ($1\\le T\\le 10^{12}$).\n\nThere are $N$ ($1\\le N\\le 5000$) trains whose departure times need to be\nscheduled. The $i$th train must leave station $s_i$ at time $t_i$ or later\n($s_i\\in \\{A, B\\}, 0\\le t_i\\le 10^{12}$).  It is not permitted to have trains\ngoing in opposite directions along the track at the same time (since they would\ncrash).  However, it is permitted to have many trains on the track going in the\nsame direction at the same time (assume trains  have negligible size).\n\nHelp Bessie schedule the departure times of all trains such that there are no\ncrashes and the total delay is minimized. If train $i$ is scheduled to leave at\ntime $a_i\\ge t_i$, the total delay is defined as $\\sum_{i=1}^N(a_i-t_i)$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$ and $T$.\n\nThen $N$ lines follow, where the $i$th line  contains the station $s_i$  and\ntime $t_i$ corresponding to the $i$th train.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe minimum possible total delay over all valid schedules.\n\nSAMPLE INPUT:\n1 95\nB 63\nSAMPLE OUTPUT: \n0\n\nThe only train leaves on time.\nSAMPLE INPUT:\n4 1\nB 3\nB 2\nA 1\nA 3\nSAMPLE OUTPUT: \n1\n\nThere are two optimal schedules. One option is to have trains $2,3,4$ leave on\ntime and train $1$ leave after a one-minute delay. Another is to have trains\n$1,2,3$ leave on time and train $4$ leave after a one-minute delay.\n\nSAMPLE INPUT:\n4 10\nA 1\nB 2\nA 3\nA 21\nSAMPLE OUTPUT: \n13\n\nThe optimal schedule is to have trains $1$ and $3$ leave on time, train $2$\nleave at time $13$, and train $4$ leave at time $23$.  The total delay is\n$0+11+0+2=13$.\n\nSAMPLE INPUT:\n8 125000000000\nB 17108575619\nB 57117098303\nA 42515717584\nB 26473500855\nA 108514697534\nB 110763448122\nB 117731666682\nA 29117227954\nSAMPLE OUTPUT: \n548047356974\n\nSCORING:\nInputs 5-6: $N \\le 15$Inputs 7-10: $N \\le 100$Inputs 11-14: $N \\le 500$Inputs 15-18: $N\\le 2000$Inputs 19-24: No additional constraints\n\n\nProblem credits: Brandon Wang\n", "num_tests": 24, "solution": "\n(Analysis by Benjamin Chen)\nSubtask 1 ($N \\leq 15$)\nA brute force approach works since the number of orders in which the trains can\nleave is small. Assume that the trains are sorted by time. For each train, the\nnext train that will leave is the train with the smallest time that hasn't left\nyet from either from station $A$ or $B$, so this gives $O(2^N)$ orderings of\ntrains. Given an ordering, we can simulate by minimizing the departure time of\neach train.\nRichard Qi's implementation:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define sz(x) int((x).size())\n\nll T;\nvector<ll> tim_station[2];\nll ans = 1e18;\n\nvoid searchInds(int a, int b, ll leave_tim, bool leave_station, ll delay) {\n    if (a == sz(tim_station[0]) && b == sz(tim_station[1])) {\n        ans = min(ans, delay);\n        return;\n    }\n\n    if (a < sz(tim_station[0])) {\n        if (leave_station == 0) {\n            ll actual_leave = max(tim_station[0][a], leave_tim);\n            searchInds(a + 1, b, actual_leave, 0,\n                       delay + actual_leave - tim_station[0][a]);\n        } else {\n            ll actual_leave = max(tim_station[0][a], leave_tim + T);\n            searchInds(a + 1, b, actual_leave, 0,\n                       delay + actual_leave - tim_station[0][a]);\n        }\n    }\n    if (b < sz(tim_station[1])) {\n        if (leave_station == 1) {\n            ll actual_leave = max(tim_station[1][b], leave_tim);\n            searchInds(a, b + 1, actual_leave, 1,\n                       delay + actual_leave - tim_station[1][b]);\n        } else {\n            ll actual_leave = max(tim_station[1][b], leave_tim + T);\n            searchInds(a, b + 1, actual_leave, 1,\n                       delay + actual_leave - tim_station[1][b]);\n        }\n    }\n}\n\nint main() {\n    cin.tie(0)->sync_with_stdio(0);\n    int N;\n    cin >> N >> T;\n\n    for (int i = 1; i <= N; i++) {\n        char s;\n        ll t;\n        cin >> s >> t;\n        tim_station[s - 'A'].push_back(t);\n    }\n    sort(tim_station[0].begin(), tim_station[0].end());\n    sort(tim_station[1].begin(), tim_station[1].end());\n\n    if (sz(tim_station[0])) searchInds(1, 0, tim_station[0][0], 0, 0LL);\n    if (sz(tim_station[1])) searchInds(0, 1, tim_station[1][0], 1, 0LL);\n    cout << ans << \"\\n\";\n}\n\nSubtask 2 ($N \\leq 100$)\nLet $0$ represent the left side and $1$ represent the right side of the track.\nDefine $\\texttt{departure_time}[s][i]$ to be the time the $i$th train on the\n$s$th side is expected to leave.\nIn an optimal solution, after we send a train off from one side, we can either\nwait to send the next train off from the same side, or we will wait $T$ time\nuntil that train reaches the other side and now we can send trains off from the\nother side.\nWe use a dp represented by $(s, a, b, t)$, which represents the minimum delay\nafter $a$ trains have left from side $s$ and $b$ trains have left from the other\nside, and the current time is $t$, where we currently are considering sending\noff trains from the $s$th side.\nA key observation is that we only have to consider $t$ in the form of\n$\\texttt{departure_time}[s][i] + T*x$, or some multiple of $T$ after the\ndeparture time of a train. The reason being that there is no reason to wait\nunless we wait fully until the next train is ready to send off. Moreover,\n$x \\leq N$ since there is no reason to switch sides more than the number of\ntrains we have to send off. So the number of distinct $t$ is bounded by the\n$N^2$, giving a $O(N^4)$ dp.\nFrom $(s, a, b, t)$, we either can transition to\n$(s, a+1, b, \\text{max}(t, \\text{time}[s][a+1]))$ by sending off the next train\nor $(1-s, b, a, t+T)$ by switching sides.\nSubtask 3 ($N \\leq 500$)\nFor this subtask, we can drop $t$ from our state altogether. Let\n$\\texttt{dp}[s][a][b]$ represent the min cost of sending the $a$th train on time\nfrom side $s$ and having already sent off $b$ trains on the other side, where\nthe $a$th train on side $s$ leaves after the $b$th train on the other side.\nFor transitions, we consider the next train that will be sent on time. Either we\nwait for the next train on side $s$, transitioning to $(s, a+1, b)$, or we will\nswitch sides $k\\leq N$ times (while sending off trains whenever possible), and\nthen wait for the next train on that side. This gives $O(N^2)$ states with\n$O(N)$ transitions, giving an overall time complexity of $O(N^3)$.\nBenjamin Qi's implementation (note that the DP states are indexed slightly differently\nthan in the explanation above):\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n#define all(x) begin(x), end(x)\ntemplate <class T> using V = vector<T>;\n\nusing ll = int64_t;\n\nconst ll BIG = 1e18;\n\ntemplate <class T> void ckmin(T &a, T b) { a = min(a, b); }\n\nint main() {\n    cin.tie(0)->sync_with_stdio(0);\n    int N;\n    ll T;\n    array<V<ll>, 2> times;\n    cin >> N >> T;\n    for (int i = 0; i < N; ++i) {\n        char s;\n        ll t;\n        cin >> s >> t;\n        times[s == 'B'].push_back(t);\n    }\n    for (int i = 0; i < 2; ++i) sort(all(times[i]));\n    V<V<array<ll, 2>>> dp(size(times[0]) + 1,\n                          V<array<ll, 2>>(size(times[1]) + 1, {BIG, BIG}));\n    if (size(times[0])) dp.at(1).at(0).at(0) = 0;\n    if (size(times[1])) dp.at(0).at(1).at(1) = 0;\n    ll ans = BIG;\n    for (int i = 0; i <= size(times[0]); ++i)\n        for (int j = 0; j <= size(times[1]); ++j) {\n            for (int side : {0, 1}) {\n                if (dp.at(i).at(j).at(side) == BIG) continue;\n                array<int, 2> cur{i, j};\n\n                // check that train last sent from side is\n                // the latest train sent\n                assert(cur.at(side ^ 1) == 0 ||\n                       times.at(side).at(cur.at(side) - 1) >\n                           times.at(side ^ 1).at(cur.at(side ^ 1) - 1));\n\n                // stay on same side\n                ll val = dp.at(i).at(j).at(side);\n                if (cur.at(side) < size(times.at(side)))\n                    ckmin(dp.at(i + (side == 0)).at(j + (side == 1)).at(side),\n                          val);\n\n                // switch sides k times\n                ll t = times.at(side).at(cur.at(side) - 1);\n                for (int k = 1; k <= N; ++k) {\n                    t += T;\n                    const int s = (side + k) & 1;\n                    for (; cur.at(s) < size(times.at(s)) &&\n                           times.at(s).at(cur.at(s)) <= t;\n                         ++cur.at(s)) {  // send off all trains on current side\n                                         // departing at time <= t\n                        val += t - times.at(s).at(cur.at(s));\n                    }\n                    if (cur.at(s) == size(times.at(s))) {\n                        if (cur.at(s ^ 1) == size(times.at(s ^ 1)))\n                            ckmin(ans, val);\n                    } else {\n                        ckmin(dp.at(cur.at(0) + (s == 0))\n                                  .at(cur.at(1) + (s == 1))\n                                  .at(s),\n                              val);\n                    }\n                }\n            }\n        }\n    cout << ans << \"\\n\";\n}\n\nSubtask 4 ($N \\leq 2000$)\nThis subtask allows for less efficient full solutions or $O(N^2\\log N)$ to pass.\nFull Solution\nNotice that in the solution in subtask $3$, there is a lot of redundancy in the\ntransitions when switching sides. Specifically, the transitions when switching\nsides are almost exactly the same for different values of $b$. This motivates us\nto define an additional dp state $\\texttt{dp2}[s][a]$ as the min cost of sending\nthe $a$th train on time from side $s$, then switching sides (and sending off all\nbacklogged trains on the other side if possible).\nFrom $\\texttt{dp}[s][a][b]$, we either send off the next train on the same side,\nrepresented by $\\texttt{dp}[s][a+1][b]$, or we decide to switch sides, which is\n$\\texttt{dp2}[s][a]$ (we assume the $a$th train on side $s$ leaves after the\n$b$th train on other side, so this is valid). In this case we have $O(1)$\ntransitions for $O(N^2)$ states.\nFrom $\\texttt{dp2}[s][a]$, we can switch sides $k\\leq N$ times (sending off\ntrains whenever we can) until eventually deciding to wait for a train, which is\nsome state in $\\texttt{dp}$. In this case we have $O(N)$ states with $O(N)$\ntransitions out of them.\nOverall, this dp runs in $O(N^2)$. Make sure to process dp states in increasing\norder of the time when the $a$th train on side $s$ leaves.\nBenjamin Qi's implementation:\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n#define all(x) begin(x), end(x)\ntemplate <class T> using V = vector<T>;\n\nusing ll = int64_t;\n\nconst ll BIG = 1e18;\n\ntemplate <class T> void ckmin(T &a, T b) { a = min(a, b); }\n\nint main() {\n    cin.tie(0)->sync_with_stdio(0);\n    int N;\n    ll T;\n    array<V<ll>, 2> times;\n    cin >> N >> T;\n    for (int i = 0; i < N; ++i) {\n        char s;\n        ll t;\n        cin >> s >> t;\n        times[s == 'B'].push_back(t);\n    }\n    for (int i = 0; i < 2; ++i) sort(all(times[i]));\n    V<V<array<ll, 2>>> dp(size(times[0]) + 1,\n                          V<array<ll, 2>>(size(times[1]) + 1, {BIG, BIG}));\n    if (size(times[0])) dp.at(1).at(0).at(0) = 0;\n    if (size(times[1])) dp.at(0).at(1).at(1) = 0;\n    array<int, 2> sent_so_far{};\n    ll ans = BIG;\n    auto process_all = [&](int side) {\n        const int i = ++sent_so_far[side];\n        ll t = times[side].at(i - 1) + T;\n        ll dp2 = BIG, add = 0;\n        array<int, 2> cur{i, 0};\n\n        // transition to dp or dp2\n        auto get_dp = [&](int i, int j) {\n            if (side) swap(i, j);\n            return dp.at(i).at(j).at(side);\n        };\n        auto upd_dp = [&](int i, int j, ll v) {\n            if (side) swap(i, j);\n            ckmin(dp.at(i).at(j).at(side), v);\n        };\n        for (int j = (int)size(times[side ^ 1]); j >= 0; --j) {\n            if (j < size(times[side ^ 1]) && times[side ^ 1].at(j) <= t) {\n                add += t - times[side ^ 1].at(j);\n                if (cur[1] == 0) cur[1] = j + 1;\n            }\n            ll v = get_dp(i, j);\n            if (v != BIG) {\n                assert(j == 0 ||\n                       times.at(side).at(i - 1) > times.at(side ^ 1).at(j - 1));\n                // stay on same side\n                if (i < size(times[side])) upd_dp(i + 1, j, v);\n                // or transition to dp2\n                ckmin(dp2, v + add);\n            }\n        }\n\n        // switch sides k times, transition from dp2 to dp\n        if (side) swap(cur[0], cur[1]);\n        for (int k = 1; k <= N; ++k, t += T) {\n            const int s = (side + k) & 1;\n            for (; cur.at(s) < size(times.at(s)) &&\n                   times.at(s).at(cur.at(s)) <= t;\n                 ++cur.at(s)) {  // send off all trains on current side\n                                 // departing at time <= t\n                dp2 += t - times.at(s).at(cur.at(s));\n            }\n            if (cur.at(s) == size(times.at(s))) {\n                if (cur.at(s ^ 1) == size(times.at(s ^ 1))) ckmin(ans, dp2);\n            } else {\n                ckmin(\n                    dp.at(cur.at(0) + (s == 0)).at(cur.at(1) + (s == 1)).at(s),\n                    dp2);\n            }\n        }\n    };\n    // process states in increasing order of departure time\n    while (sent_so_far[0] < size(times[0]) && sent_so_far[1] < size(times[1])) {\n        if (times[0].at(sent_so_far[0]) < times[1].at(sent_so_far[1]))\n            process_all(0);\n        else process_all(1);\n    }\n    for (int side : {0, 1})\n        while (sent_so_far[side] < size(times[side])) process_all(side);\n    cout << ans << \"\\n\";\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": ["\n**Note: The memory limit for this problem is 512MB, twice the default."], "runtime_limit": 2, "memory_limit": 512}, "1353_gold_flight_routes": {"name": "Flight Routes", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1353", "test_data_link": "http://www.usaco.org/current/data/prob1_gold_dec23.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob1_gold_dec23.html", "contest_link": "http://www.usaco.org/index.php?page=dec23results", "inner_contest_link": null, "problem_level": "gold", "cp_id": "1353", "problem_id": "1353_gold_flight_routes", "description": "\nBessie recently discovered that her favorite pop artist, Elsie Swift, is\nperforming in her new Eras Tour! Unfortunately, tickets are selling out fast, so\nBessie is thinking of flying to another city to attend the concert. The Eras\ntour is happening in $N$ ($2\\le N\\le 750$) cities labeled $1\\dots N$, and for\neach pair of cities $(i,j)$ with $i<j$ there either exists a single direct\nflight from $i$ to $j$ or not.\n\nA flight route from city $a$ to city $b$ ($a<b$) is a sequence of $k\\ge 2$ cities\n$a=c_1<c_2<\\dots<c_k=b$ such that for each $1\\le i<k$, there is a direct flight\nfrom city $c_i$ to city $c_{i+1}$. For every pair of cities $(i,j)$ with $i<j$,\nyou are given the parity of the number of flight routes between them (0 for\neven, 1 for odd). \n\nWhile planning her travel itinerary, Bessie got distracted and now wants to know\nhow many pairs of cities have direct flights between them. It can be  shown that\nthe answer is uniquely determined.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$.\n\nThen follow $N-1$ lines. The $i$th line contains $N-i$ integers. The $j$th \ninteger of the $i$th line is equal to the parity of the number of flight routes\nfrom $i$ to $i+j$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput the number of pairs of cities with direct flights between them.\n\nSAMPLE INPUT:\n3\n11\n1\nSAMPLE OUTPUT: \n2\n\nThere are two direct flights: $1\\to 2$ and $2\\to 3$. There is one flight route\nfrom $1$ to $2$ and $2$ to $3$, each consisting of a single direct flight. There\nis one flight route from $1$ to $3$ ($1\\to 2\\to 3$).\n\nSAMPLE INPUT:\n5\n1111\n101\n01\n1\nSAMPLE OUTPUT: \n6\n\nThere are six direct flights $1\\to 2, 1\\to 4, 1\\to 5, 2\\to 3, 3\\to 5, 4\\to 5$.\nThese result in the following numbers of flight routes:\n\n\nFlight Route Counts:\n\n            dest\n          1 2 3 4 5\n\n       1  0 1 1 1 3 \n       2  0 0 1 0 1 \nsource 3  0 0 0 0 1 \n       4  0 0 0 0 1 \n       5  0 0 0 0 0\n\nwhich is equivalent to the sample input after taking all the numbers $\\pmod{2}$.\n\nSCORING:\nInputs 3-4: $N\\le 6$Inputs 5-12: $N\\le 100$Inputs 13-22: No additional constraints.\n\n\nProblem credits: Benjamin Qi\n", "num_tests": 22, "solution": "\n(Analysis by Benjamin Qi)\nSubtask 1: $N\\le 6$\nConsider all $2^{N(N-1)/2}$ ways to either have a direct flight or not between\neach pair of cities. For each of these ways, check whether it will produce the\ninput by iterating over all $2^N$ subsets of cities and checking whether that\nsubset forms a valid flight route. The overall runtime is $O(2^{N(N-1)/2}\\cdot 2^N)=O(2^{N(N+1)/2})$.\nSubtask 2: $N\\le 100$\nSuppose we want to determine whether there is a direct flight from $l$ to $r$.\nFirst, determine whether there is a direct flight from $l'$ to $r'$ for all \n$(l',r')\\neq (l,r)$ satisfying $l\\le l' <r'\\le r$. Then, compute the parity of\nthe number of flight routes from $l$ to $r$ excluding the potential direct\nflight from $l$ to $r$. There is a direct flight from $l$ to $r$ if the computed\nparity does not match the parity given in the input. \nComputing the parity of the number of flight routes from $l$ to $r$ excluding\nthe potential direct flight from $l$ to $r$ can be done in  $O(N^2)$ time (see\nthe function $\\texttt{count_routes_excluding_direct}(l,r)$ in the code below).\nFor $l\\le i\\le r$, let $\\text{routes_to}_{l}(i)$ denote the parity of the number\nof flight routes from $l$ to $i$  using only the previously computed direct\nflights, or $1$ if $l=i$. Also, let $\\text{direct}[j][i]$ denote whether there\nis a direct flight from $j$ to $i$. Then for $l<i\\le r$ we have the relation\n$\\text{routes_to}_{l}(i)\\equiv\\sum_{j=l}^{i-1}\\text{routes_to}_l(j)\\cdot \\text{direct}[j][i]\\pmod{2}$.\nUsing this, we can compute $\\text{routes_to}_{l}(i)$ in increasing order from\n$i=l+1$ to\n$i=r$.\nTime Complexity: The function\n$\\texttt{count_routes_excluding_direct}(l,r)$ is called $O(N^2)$ times and each\ncall takes $O(N^2)$ time, so the overall runtime is\n$O(N^2\\cdot N^2)=O(N^4)$.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T> using V = vector<T>;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint N;\n\tcin >> N;\n\tV<V<int>> routes(N, V<int>(N));\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = i + 1; j < N; ++j) routes[i][j] = s.at(j - i - 1) - '0';\n\t}\n\tV<V<int>> direct(N, V<int>(N));\n\tauto count_routes_excluding_direct = [&](int l, int r) {\n\t\tV<int> routes_to(N);\n\t\troutes_to[l] = 1;\n\t\tfor (int i = l + 1; i <= r; ++i)\n\t\t\tfor (int j = l; j < i; ++j)\n\t\t\t\troutes_to[i] ^= routes_to[j] * direct[j][i];\n\t\treturn routes_to[r];\n\t};\n\tint ans = 0;\n\tfor (int i = N - 1; i >= 0; --i)\n\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\tdirect[i][j] = routes[i][j] ^ count_routes_excluding_direct(i, j);\n\t\t\tans += direct[i][j];\n\t\t}\n\tcout << ans << \"\\n\";\n}\n\nFull Solution: $N\\le 750$\nWe reduce the time complexity of the function\n$\\texttt{count_routes_excluding_direct}(l,r)$ to $O(N)$. Since\n$\\text{routes_to}_{l}(i)$ for $l<i<r$ is equal to the parity of the number of\nflight routes from $l$ to $i$, we can remove the loop over $i$ in the function\nand directly compute $\\text{routes_to}_{l}(r)$. The overall runtime is\n$O(N^3)$.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T> using V = vector<T>;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint N;\n\tcin >> N;\n\tV<V<int>> routes(N, V<int>(N));\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = i + 1; j < N; ++j) routes[i][j] = s.at(j - i - 1) - '0';\n\t}\n\tV<V<int>> direct(N, V<int>(N));\n\tauto count_routes_excluding_direct = [&](int l, int r) {\n\t\tint ret = 0;\n\t\tfor (int j = l; j < r; ++j) ret ^= routes[l][j] * direct[j][r];\n\t\treturn ret;\n\t};\n\tint ans = 0;\n\tfor (int i = N - 1; i >= 0; --i)\n\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\tdirect[i][j] = routes[i][j] ^ count_routes_excluding_direct(i, j);\n\t\t\tans += direct[i][j];\n\t\t}\n\tcout << ans << \"\\n\";\n}\n\nBonus: $N\\le 5000$\nTry solving this using bitsets.\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1354_gold_minimum_longest_trip": {"name": "Minimum Longest Trip", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1354", "test_data_link": "http://www.usaco.org/current/data/prob2_gold_dec23.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob2_gold_dec23.html", "contest_link": "http://www.usaco.org/index.php?page=dec23results", "inner_contest_link": null, "problem_level": "gold", "cp_id": "1354", "problem_id": "1354_gold_minimum_longest_trip", "description": "\nBessie is going on a trip in Cowland, which has $N$ ($2\\le N\\le 2\\cdot 10^5$)\ntowns numbered from $1$ to $N$ and $M$ ($1\\le M\\le 4\\cdot 10^5$) one-way roads.\nThe $i$th road runs from town $a_i$ to town $b_i$ and has label $l_i$\n($1\\le a_i,b_i\\le N$, $1\\le l_i\\le 10^9$).  \n\nA trip of length $k$ starting at town $x_0$ is a sequence of towns\n$x_0, x_1, \\ldots, x_k$, such that there is a road from town $x_i$ to town\n$x_{i+1}$ for all $0\\le i < k$. It is guaranteed that there are no trips of\ninfinite length in Cowland, and that no two roads connect the same pair of\ntowns.\n\nFor each town, Bessie wants to know the longest possible trip starting at it.\nFor some starting towns, there are multiple longest trips - out of these, she\nprefers the trip with the lexicographically minimum sequence of road labels.  A\nsequence is lexicographically smaller than another sequence of the same length\nif, at the first position in which they differ, the first sequence has a smaller\nelement than the second sequence.\n\nOutput the length and sum of road labels of Bessie's preferred trip starting at\neach town.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$ and $M$.\n\nThe next $M$ lines each contain three integers $a_i$, $b_i$, and $l_i$, denoting\na road from $a_i$ to $b_i$ with label $l_i$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput $N$ lines. The $i$th should contain two space-separated integers, the\nlength and sum of road labels of Bessie's preferred trip starting at town\n$i$.\n\n\nSAMPLE INPUT:\n4 5\n4 3 10\n4 2 10\n3 1 10\n2 1 10\n4 1 10\nSAMPLE OUTPUT: \n0 0\n1 10\n1 10\n2 20\n\nSAMPLE INPUT:\n4 5\n4 3 4\n4 2 2\n3 1 5\n2 1 10\n4 1 1\nSAMPLE OUTPUT: \n0 0\n1 10\n1 5\n2 12\n\nIn the following explanation, we let $a_i\\overset{l_i}\\to b_i$ represent the\nroad from $a_i$ to $b_i$ with label $l_i$.\n\nThere are several trips starting from vertex $4$, including\n$4 \\overset{4}\\to 3\\overset{5}\\to 1$, $4\\overset{1}\\to 1$, and\n$4\\overset{2}\\to 2\\overset{10}\\to 1$. Of these trips,\n$4 \\overset{4}\\to 3\\overset{5}\\to 1$ and $4\\overset{2}\\to 2\\overset{10}\\to 1$\nare the longest. These trips each have length 2, and their road label sequences\nare $[4,5]$ and $[2,10]$, respectively. $[2,10]$ is the lexicographically\nsmaller sequence, and its sum is $12$.\n\nSAMPLE INPUT:\n4 5\n4 3 2\n4 2 2\n3 1 5\n2 1 10\n4 1 1\nSAMPLE OUTPUT: \n0 0\n1 10\n1 5\n2 7\n\nSAMPLE INPUT:\n4 5\n4 3 2\n4 2 2\n3 1 10\n2 1 5\n4 1 1\nSAMPLE OUTPUT: \n0 0\n1 5\n1 10\n2 7\n\nSCORING:\nInputs 5-6: All labels are the same.Inputs 7-8: All labels are distinct.Inputs 9-10: $N,M\\le 5000$Inputs 11-20: No additional constraints.\n\n\nProblem credits: Claire Zhang and Spencer Compton\n", "num_tests": 20, "solution": "\n(Analysis by Claire Zhang) \nWe model Cowland as a directed acyclic graph with towns as nodes and roads as\nweighted directed edges.\nThroughout the code and analysis, say\n $\\text{len}[i]$ is the length of the longest path starting at $i$,  $i\\rightarrow j$ is the edge from $i$ to $j$, and  $l[i\\rightarrow j]$ is the label of edge $i\\rightarrow j$. \nFor all subtasks, it is required to process nodes in an order such that for all\nnodes, we visit its successors before visiting itself. We can process nodes in\nthis so called topological order by processing batches of nodes in order of\nincreasing $\\text{len}$, where we add a node to the next batch once we visit all\nits successors (see code).\nSubtask 1 (Labels are the same).\nIf all labels are $c$, we are asked to output $c\\cdot \\text{len}[i]$ for each\n$i$. We can compute $\\text{len}[i]$ in topological order, taking the max length\nover successors of $i$:\n\n#include<bits/stdc++.h>\nusing namespace std;\n \nconst int N=2e5+1;\nvector<vector<int>> radj[N];\nint deg[N], len[N];\n \nint main(){\n    int n,m;\n    cin >> n >> m;\n    long long c=0;\n    for(int i=0; i<m; i++){\n        int u,v,l; cin >> u >> v >> l;\n        c=l;\n        radj[v].push_back({u, l});\n        deg[u]++;\n    }\n    vector<int> nodes;\n    for(int i=1; i<=n; i++){\n        if(!deg[i]) nodes.push_back(i);\n    }\n \n    // bfs from sinks\n    while(int(nodes.size())){\n        vector<int> nodes2;\n \n        // update predecessors' deg and (possibly) len\n        for(int b:nodes){\n            for(auto e:radj[b]){\n                int a=e[0], l=e[1];\n                deg[a]--;\n                if(deg[a]==0){\n                    len[a]=len[b]+1;\n                    nodes2.push_back(a);\n                }\n            }\n        }\n        // next round's nodes to process\n        swap(nodes, nodes2);\n    }\n \n    for(int i=1; i<=n; i++) cout << len[i] << \" \" << c*len[i] << '\\n';\n}\n\nThe time complexity is $O(N+M)$.\nSubtask 2 (Labels are distinct).\nBessie's preferred path is the path $P$ with lexicographically minimal\n$\\text{value}(P):= (-\\text{len}(P), l^{P}_1, l^{P}_2, \\ldots, l^{P}_{\\text{len}(P)-1})$,\nwhere $l^P_j$ denotes the label of the $j$th edge on path $P$. If $l_j$ are\npairwise distinct, $l^{P}_1 \\ne l^{P'}_1$ for different paths $P$, $P'$, so it\nsuffices to only consider $(-\\text{len}(P), l^P_1)$. \nLet's modify the previous solution. For each node $i$, find the successor $j$\nwith minimum $(-\\text{len}[j], l[i\\rightarrow j])$. This is stored in\n$\\text{best}[i]$ in the code below. We keep track of the desired sums and update\n$\\text{sum}[i] = \\text{sum}[j]+l[i\\rightarrow j]$ in topological order.\n\n#include<bits/stdc++.h>\nusing namespace std;\n \nconst int N=2e5+1;\nvector<vector<int>> radj[N];\nvector<vector<long long>> cand[N];\nint deg[N];\npair<int, int> best[N];\nlong long sum[N];\n \nint main(){\n    int n,m;\n    cin >> n >> m;\n    for(int i=0; i<m; i++){\n        int u,v,l; cin >> u >> v >> l;\n        radj[v].push_back({u, l});\n        deg[u]++;\n    }\n    vector<int> nodes;\n    for(int i=1; i<=n; i++){\n        if(!deg[i]) nodes.push_back(i);\n    }\n \n    // bfs from sinks\n    while(int(nodes.size())){\n        vector<int> nodes2;\n \n        // update predecessors' deg and (possibly) best\n        for(int b:nodes){\n            for(auto e:radj[b]){\n                int a=e[0], l=e[1];\n                deg[a]--;\n                if(make_pair(best[b].first-1, l) < best[a]){\n                    best[a] = {best[b].first-1, l};\n                    sum[a] = sum[b]+l;\n                }\n                if(deg[a]==0){\n                    nodes2.push_back(a);\n                }\n            }\n        }\n        // next round's nodes to process\n        swap(nodes, nodes2);\n    }\n \n    for(int i=1; i<=n; i++) cout << -best[i].first << \" \" << sum[i] << '\\n';\n}\n\nThe time complexity is $O(N+M)$.\nSubtask 3 ($N,M \\le 5000$).\nNow we must consider the entire path:\n$\\text{value}(P):= (-\\text{len}(P), l^{P}_1, l^{P}_2, \\ldots, l^{P}_{\\text{len(P)}-1})$.\nLet's store the preferred path from each node $i$ that we've visited. It\nsuffices to store the next node on the path and the label of the edge to it.\nThis is stored as $\\text{nxt}[i]$ in the below code.\nStarting at each node $i$, we can compare the values of the $\\deg i$ candidate\npaths using each outward edge. Let $\\text{better}(i, j)$ be a function that\nreturns whether the preferred path from $i$ is better (has lexicographically\nsmaller value) than the preferred path from $j$, as well as the sum of the\nbetter path. $\\text{better}(i, j)$ can be computed by comparing\n the length of each path,  the edge weight of the first edge in\neach path, \n$\\text{better}(\\text{nxt}(i), \\text{nxt}(j))$ ($\\text{nxt}(i)$ refers to the\nsecond node on the preferred path from $i$, which is $\\texttt{nxt[i].first}$ in\nthe code) \n- breaking whenever the two quantities are different.\nFor each node $i$, we compare $O(\\deg i)$ paths; each comparison takes $O(N)$,\nand so the total time complexity is $O(\\sum_i \\deg i \\cdot N) = O(MN)$.\n\n#include<bits/stdc++.h>\nusing namespace std;\n \nconst int N=2e5+1;\nvector<vector<int>> radj[N];\nint deg[N], len[N];\npair<int, int> nxt[N];\nlong long sum[N];\n \n#define mp make_pair\n \nint main(){\n    int n,m;\n    cin >> n >> m;\n    for(int i=0; i<m; i++){\n        int u,v,l; cin >> u >> v >> l;\n        radj[v].push_back({u, l});\n        deg[u]++;\n    }\n    vector<int> nodes;\n    for(int i=1; i<=n; i++){\n        if(!deg[i]) nodes.push_back(i);\n    }\n \n    // process nodes in order of increasing longest path\n    while(int(nodes.size())){\n        vector<int> nodes2;\n \n        // determine which min.lex. path is better\n        auto better=[&](auto&& better, int a, int b)->int{\n            if(!len[a] and !len[b]) return 1;\n            if(mp(len[a], nxt[a].second) != mp(len[b], nxt[b].second)){\n                return 1+(mp(len[b], -nxt[b].second) > mp(len[a], -nxt[a].second));\n            }\n            return better(better, nxt[a].first, nxt[b].first);\n        };\n \n        // update best path nxt[a]\n        auto ckmin=[&](int a, pair<int, int> cand){\n            int b = cand.first;\n            if(!nxt[a].first){\n                nxt[a]=cand;\n                len[a]=len[cand.first]+1;\n                return;\n            }\n            len[0] = len[b] + 1;\n            nxt[0] = cand;\n            if(better(better, a, 0)==2){\n                len[a] = len[b] + 1;\n                nxt[a] = cand;\n            }\n        };\n \n        // update predecessors' deg and (possibly) nxt\n        for(int b:nodes){\n            sum[b] = sum[nxt[b].first] + nxt[b].second;\n            for(auto e:radj[b]){\n                int a=e[0], l=e[1];\n                deg[a]--;\n                ckmin(a, {b, l});\n                if(deg[a]==0){\n                    nodes2.push_back(a);\n                }\n            }\n        }\n        \n        // next round's nodes to process\n        swap(nodes, nodes2);\n    }\n \n    for(int i=1; i<=n; i++) cout << len[i] << \" \" << sum[i] << '\\n';\n}\n\nSubtask 4 ($N \\le 2\\cdot 10^5, M \\le 4\\cdot 10^5$).\nIf the preferred path from $i$ goes to $j$ in the first step, the rest of the\npath must be the preferred path starting at $j$. Thus, subtask 3 could recompare\nthe same pair of nodes multiple times. We can memoize $\\texttt{better}(i, j)$\nusing a map but this still could take $\\Omega(M\\sqrt{M})$ time and memory (try\nto think of a test case!). Instead, we maintain a rank function.\nFor each batch of nodes (batched by len), let's compute $\\text{rnk}[i]$ which\nsatisfies $\\text{rnk}[i] < \\text{rnk}[j]$ for all pairs of nodes $i,j$ such that\nthe preferred path is lexicographically smaller than the preferred path from\n$j$.  Then, to compute the ranks of the predecessors of nodes in this batch, it\nsuffices to sort 3-tuples, as in Subtask 2. Specifically,\n$\\text{nxt}(i) = \\text{argmin}_{j} (-\\text{len}[j], l[i\\rightarrow j], \\text{rnk}[j])$\nand $\\text{rnk}[i]$ is the index of\n$(l[i\\rightarrow \\text{nxt}(i)], \\text{rnk}[\\text{nxt}(i)])$ in a sorted list of\n$(l[k \\rightarrow \\text{nxt}[k]], \\text{rnk}[\\text{nxt}(k)])$, over all nodes\n$k$ in $i$'s batch. \n\n#include<bits/stdc++.h>\nusing namespace std;\n \nconst int N=2e5+1;\nvector<vector<int>> radj[N];\nvector<vector<long long>> cand[N];\nint deg[N], rnk[N], len[N];\nlong long sum[N];\n \nint main(){\n    int n, m;\n    cin >> n >> m;\n    for(int i=0; i<m; i++){\n        int u,v,l; cin >> u >> v >> l;\n        radj[v].push_back({u, l});\n        deg[u]++;\n    }\n    vector<int> nodes;\n    for(int i=1; i<=n; i++){\n        if(!deg[i]) nodes.push_back(i);\n    }\n \n    // bfs from sinks\n    while(int(nodes.size())){\n        vector<int> nodes2;\n \n        // update predecessors' deg, len, and cand\n        for(int u:nodes){\n            for(auto e:radj[u]){\n                int v=e[0], l=e[1];\n                cand[v].push_back({-len[u], l, rnk[u], sum[u]+l});\n                deg[v]--;\n                if(deg[v]==0){\n                    len[v]=len[u]+1;\n                    nodes2.push_back(v);\n                }\n            }\n        }\n        // next round's nodes to process\n        swap(nodes, nodes2);\n \n        // find the lex. min. path\n        vector<vector<long long>> v;\n        for(int i=0; i<nodes.size(); i++){\n            int x=nodes[i];\n            sort(cand[x].begin(), cand[x].end());\n            vector<long long> use=cand[x][0];\n            sum[x]=use[3];\n            v.push_back({use[1], use[2], x});\n        }\n \n        // rank this level's nodes\n        sort(v.begin(), v.end());\n        for(int i=0; i<v.size(); i++){\n            rnk[v[i][2]]=i;\n        }\n    }\n \n    for(int i=1; i<=n; i++) cout << len[i] << \" \" << sum[i] << '\\n';\n}\n\nThe time complexity is $O(M\\log N)$.\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1355_gold_haybale_distribution": {"name": "Haybale Distribution", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1355", "test_data_link": "http://www.usaco.org/current/data/prob3_gold_dec23.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob3_gold_dec23.html", "contest_link": "http://www.usaco.org/index.php?page=dec23results", "inner_contest_link": null, "problem_level": "gold", "cp_id": "1355", "problem_id": "1355_gold_haybale_distribution", "description": "\nFarmer John is distributing haybales across the farm!\n\nFarmer John's farm has $N$ $(1\\le N\\le 2\\cdot 10^5)$ barns, located at integer\npoints $x_1,\\dots, x_N$ $(0 \\le x_i \\le 10^6)$ on the number line. Farmer John's\nplan is to first have $N$ shipments of haybales delivered to some integer point\n$y$ $(0 \\le y \\le 10^6)$ and then distribute one shipment to each barn.\n\nUnfortunately, Farmer John's distribution service is very wasteful. In\nparticular, for some $a_i$ and $b_i$ $(1\\le a_i, b_i\\le 10^6)$, $a_i$ haybales\nare wasted per unit of distance left each shipment is transported, and $b_i$\nhaybales are wasted per unit of distance right each shipment is transported.\nFormally, for a shipment being transported from point $y$ to a barn at point\n$x$, the number of haybales wasted is given by \n\n$$\\begin{cases}\n a_i\\cdot (y-x) & \\text{if } y \\ge x \\\\\nb_i\\cdot (x-y) & \\text{if } x > y\n\\end{cases}.$$\nGiven $Q$ $(1\\le Q\\le 2\\cdot 10^5)$ independent queries each consisting of\npossible values of $(a_i,b_i)$, please help Farmer John determine the fewest\namount of haybales that will be wasted if he chooses $y$ optimally. \n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$.\n\nThe next line contains $x_1\\dots x_N$.\n\nThe next line contains $Q$.\n\nThe next $Q$ lines each contain two integers $a_i$ and $b_i$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput $Q$ lines, the $i$th line containing the answer for the $i$th query.\n\nSAMPLE INPUT:\n5\n1 4 2 3 10\n4\n1 1\n2 1\n1 2\n1 4\nSAMPLE OUTPUT: \n11\n13\n18\n30\n\nFor example, to answer the second query, it is optimal to select $y=2$. Then the\nnumber of wasted haybales is equal to\n$2(2-1)+2(2-2)+1(3-2)+1(4-2)+1(10-2)=1+0+1+2+8=13$.\n\nSCORING:\nInput 2: $N,Q\\le 10$Input 3: $N,Q\\le 500$Inputs 4-6: $N,Q\\le 5000$Inputs 7-16: No additional constraints.\n\n\nProblem credits: Benjamin Qi\n", "num_tests": 16, "solution": "\n(Analysis by David Hu, Benjamin Qi)\nSort all of the $x_i$ (zero-indexed) in increasing order. Consider some fixed\nindividual query $(a_i, b_i) = (a, b)$.\nSuppose that Farmer John delivers the haybales to some point\n$x_{i-1} < y < x_{i}$. Consider what happens if Farmer John instead delivers the\nhaybales to some point $x_{i-1} < y + d < x_{i}$. The total cost Farmer John\npays changes by $a \\cdot d$ for each of the $i$ haybales to the left of the\nstarting point and $-b \\cdot d$ for each of the $N - i$ haybales to the right of\nthe starting point, making an overall change of\n$a \\cdot i \\cdot d - b \\cdot (N-i) \\cdot d$. Since this is linear in $d$, the\ncost to start at point $y$ is linear in the range $y \\in [x_{i-1}, x_i]$. Thus\nit is always optimal for the haybales to be delivered to one of the $x_i$.\nFull Solution 1: $O(1)$ time per query\nSuppose Farmer John is deciding whether to deliver the haybales to $x_{i-1}$ or\n$x_{i}$.  Let the distance between $x_{i-1}$ and $x_i$ be $d>0$.\nIf he delivers the haybales to $x_{i-1}$, then the total cost for delivering\neach of the $i$ haybales $x_0, \\dots x_{i-1}$ is $d \\cdot\na$ less, but the total\ncost for delivering each of the $N-i$ haybales $x_i, \\dots\nx_{N-1}$ is\n$d \\cdot b$ more. Thus in order for $x_{i-1}$ to be a strictly better place to\ndeliver the haybales than $x_i$,\n$d \\cdot a \\cdot i > d \\cdot b \\cdot (N-i) \\implies \\frac{N-i}{i} < \\frac{a}{b} \\implies \\frac{N}{i} < \\frac{a + b}{b}\n\\implies i > \\frac{Nb}{a + b}$.\nWe conclude that the following statements hold (even when $d=0$):\nIf $i > \\left\\lfloor\\frac{Nb}{a + b}\\right\\rfloor$, it is at least as good\nto deliver the haybales to $x_{i-1}$ rather than $x_i$.If\n$i < \\left\\lfloor\\frac{Nb}{a + b}\\right\\rfloor$, it is at least as good to\ndeliver the haybales to $x_{i+1}$ rather than $x_i$.\nSo in fact we know the exact optimal location for Farmer John to deliver the\nhaybales to: it is $x_i$, where\n$i = \\left\\lfloor \\frac{Nb}{a+b} \\right\\rfloor$.\nTo answer queries in $O(1)$, we can precompute the sum of distances to all\nhaybales to the left of and to the right of each haybale.\nDavid's code:\n\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 2e5 + 13;\nint N, Q;\nint arr[MAXN];\nll lt[MAXN], rt[MAXN];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        cin >> arr[i];\n    }\n    sort(arr, arr + N);\n    for (int i = 1; i < N; i++) {\n        int d = arr[i] - arr[i - 1];\n        lt[i] = lt[i - 1] + (ll) d * i;\n    }\n    for (int i = N - 2; i >= 0; i--) {\n        int d = arr[i + 1] - arr[i];\n        rt[i] = rt[i + 1] + (ll) d * (N - 1 - i);\n    }\n    cin >> Q;\n    while(Q--) {\n        int a, b;\n        cin >> a >> b;\n        int idx = (ll) N * b / (a + b);\n        ll ans = lt[idx] * a + rt[idx] * b;\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n\nFull Solution 2: $O(\\log N)$ time per query\nFor a single $x$, the function in the problem statement is a \nconvex function of $y$. \nThe total number of haybales wasted across all $x$ is given by a sum of a convex\nfunctions, which is also convex. Any convex function is unimodal (specifically,\nit strictly decreases until the minimum is reached, then strictly increases),\nand thus can be minimized using binary or\nternary search.\nAs in the first full solution, we precompute prefix sums so that evaluating the\nnumber of wasted haybales when $y$ equals some $x_i$ takes $O(1)$ time.\nNote: Make sure to search only on distinct values of $x$, or you might end up\nwith the wrong answer.\nBen's code:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint N;\n\tcin >> N;\n\tvector<int> X(N);\n\tfor (int &x : X) cin >> x;\n\tsort(begin(X), end(X));\n\tint Q;\n\tcin >> Q;\n\tvector<int64_t> cum{0};\n\tfor (int x : X) cum.push_back(cum.back() + x);\n\tauto cumsum = [&](int l, int r) { return cum.at(r + 1) - cum.at(l); };\n\tvector<int> distinct_X{0};  // keep only distinct X[i]\n\tfor (int i = 1; i < N; ++i)\n\t\tif (X[i] > X[i - 1]) distinct_X.push_back(i);\n\twhile (Q--) {\n\t\tint A, B;\n\t\tcin >> A >> B;\n\t\tauto eval = [&](int idx) {\n\t\t\tint i = distinct_X.at(idx);\n\t\t\tint64_t ans = B * (cumsum(i, N - 1) - (int64_t)(N - i) * X[i]);\n\t\t\tans += A * ((int64_t)i * X[i] - cumsum(0, i - 1));\n\t\t\treturn ans;\n\t\t};\n\t\tint lo = 0, hi = size(distinct_X) - 1;\n\t\twhile (lo < hi) {\n\t\t\tint mid = (lo + hi) / 2;\n\t\t\tif (eval(mid) < eval(mid + 1)) hi = mid;\n\t\t\telse lo = mid + 1;\n\t\t}\n\t\tcout << eval(lo) << \"\\n\";\n\t}\n}\n\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1350_silver_bovine_acrobatics": {"name": "Bovine Acrobatics", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1350", "test_data_link": "http://www.usaco.org/current/data/prob1_silver_dec23.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob1_silver_dec23.html", "contest_link": "http://www.usaco.org/index.php?page=dec23results", "inner_contest_link": null, "problem_level": "silver", "cp_id": "1350", "problem_id": "1350_silver_bovine_acrobatics", "description": "\nFarmer John has decided to make his cows do some acrobatics! First,  FJ weighs\nhis cows and finds that they have $N$ ($1\\le N\\le 2\\cdot 10^5$) distinct\nweights. In particular, for each $i\\in [1,N]$, $a_i$ of his cows have a weight\nof $w_i$\n($1\\le a_i\\le 10^9, 1\\le w_i\\le 10^9$).\n\nHis most popular stunt involves the cows forming balanced towers. A\ntower is a sequence of cows where each cow is stacked on top of the next.\nA tower is balanced if every cow with a cow directly above it has weight\nat least $K$ ($1\\le K\\le 10^9$) greater than the weight of the cow directly\nabove it. Any cow can be part of at most one balanced tower.\n\nIf FJ wants to create at most $M$ ($1 \\le M \\le 10^9$) balanced towers of cows, at most\nhow many cows can be part of some tower?\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains three space-separated integers, $N$, $M$, and $K$.\n\nThe next $N$ lines contain two space-separated integers, $w_{i}$ and $a_i$. It\nis guaranteed that all $w_i$ are distinct.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput the maximum number of cows in balanced towers if FJ helps the cows form towers\noptimally.\n\nSAMPLE INPUT:\n3 5 2\n9 4\n7 6\n5 5\nSAMPLE OUTPUT: \n14\n\nFJ can create four balanced towers with cows of weights 5, 7, and 9, and one balanced tower with\ncows of weights 5 and 7.\n\nSAMPLE INPUT:\n3 5 3\n5 5\n7 6\n9 4\nSAMPLE OUTPUT: \n9\n\nFJ can create four balanced towers with cows of weights 5 and 9, and one balanced tower with a cow\nof weight 7. Alternatively, he can create four balanced towers with cows of weights 5 and\n9, and one balanced tower with a cow of weight 5.\n\nSCORING:\nIn inputs 3-5, $M \\leq 5000$ and the total number of cows does not exceed\n$5000$.In inputs 6-11, the total number of cows does not exceed $2\\cdot 10^5$.Inputs 12-17 have no additional constraints.\n\n\nProblem credits: Eric Hsu\n", "num_tests": 17, "solution": "\n(Analysis by Eric Hsu)\nSubtask 1:\nSolution 1: We can greedily build towers one at a time as such: process\nthe remaining cows from heaviest to lightest, adding a cow to the current tower\nif possible. Repeat this $M$ times, once for each tower.\nCode:\n\nN, M, K = map(int, input().split())\n \ncows = []\nfor _ in range(N):\n\tw, a = map(int, input().split())\n\tcows += [w] * a\ncows.sort(reverse=True)\n \nanswer = 0\nfor _ in range(M):\n\tremaining_cows = []\n\tcurrent_cow = 1e100 #arbitrary large number\n\tfor cow in cows:\n\t\tif cow + K <= current_cow:\n\t\t\tcurrent_cow = cow\n\t\t\tanswer += 1\n\t\telse:\n\t\t\tremaining_cows += [cow]\t\t\n \n\tif len(remaining_cows) == 0:\n\t\tbreak\n\tcows = remaining_cows\n \nprint(answer)\n\nTime Complexity: $O(c^2)$, where $c$ is the number of cows.\nSolution 2a: Process the cows from heaviest to lightest. When we process\na cow, we try to put it on any tower. This is always optimal since we could put\nany of the remaining cows on a tower that the current cow can be placed on, so\nit doesn't matter where we place the current cow. \nCode:\n\nN, M, K = map(int, input().split())\n \ncows = []\nfor _ in range(N):\n\tw, a = map(int, input().split())\n\tcows += [w] * a\ncows.sort(reverse=True)\n \nanswer = 0\ntowers = [1e100]*min(M, len(cows))\nfor cow in cows:\n\tfor i in range(M):\n\t\tif cow + K <= towers[i]:\n\t\t\ttowers[i] = cow\n\t\t\tanswer += 1\n\t\t\tbreak\n \nprint(answer)\n\n Solution 2b: Instead of placing the cow on an arbitrary tower, we only\ntry to place it on the tower with the heaviest cow on top. This is because if it\nis possible to place a cow on a tower, it is possible to place it on the tower\nwith the heaviest cow on top.\nTime Complexity: $O(c^2)$\nNote that the number of towers is bounded by the number of cows, since if the\nnumber of towers is greater than the number of cows, we can just remove the\nexcess towers. \nSubtask 2:\nWe can optimize  solution 2b  in  subtask 1  by speeding up the\nsearch for the heaviest cow. We can do this by keeping a sorted queue of towers\nwhere the front of the queue is the tower with the heaviest cow on top. When we\nplace the current cow on a tower, we move that tower to the back of the queue\nsince the current cow is lighter than all of the cows processed before it.\nTime complexity: $O(c\\log c)$, where the log factor comes from sorting the cows by weight.\nCode:\n\nfrom collections import deque\nN, M, K = map(int, input().split())\n \ncows = []\nfor _ in range(N):\n\tw, a = map(int, input().split())\n\tcows += [w] * a\ncows.sort(reverse=True)\n \nanswer = 0\ntowers = deque([1e100]*min(M, len(cows)))\nfor cow in cows:\n\tif cow + K <= towers[0]:\n\t\tanswer += 1\n\t\ttowers.popleft()\n\t\ttowers.append(cow)\n \nprint(answer)\n\nSubtask 3: Instead of processing individual cows and towers, compress\nthem into (weight, count) pairs. See the code for the details.  The time\ncomplexity of the remaining portion of the code after the sorting step is\nbounded by the number of insertions to and deletions from the queue.  Both of\nthese are at most $N$, so the time complexity of the remaining portion is\n$O(N)$.\nOverall time complexity: $O(N \\log N)$\nCode:\n\nfrom collections import deque\nN, M, K = map(int, input().split())\n \npairs = []\nfor _ in range(N):\n\tw, a = map(int, input().split())\n\tpairs.append([w, a])\npairs.sort(reverse = True)\n \ntowers = deque()\ntowers.append([1e100, M])\nanswer = 0\nfor w, a in pairs:\n\tremaining = a\n\twhile len(towers) > 0 and remaining > 0 and w + K <= towers[0][0]:\n\t\tif towers[0][1] > remaining:\n\t\t\ttowers[0][1] -= remaining\n\t\t\tremaining = 0\n\t\telse:\n\t\t\tremaining -= towers[0][1]\n\t\t\ttowers.popleft()\n\tcnt = a - remaining\n\tif cnt > 0:\n\t\ttowers.append([w, cnt])\n\t\tanswer += cnt\n\t\n \nprint(answer)\n\nUsing an ordered set rather than a deque can also pass with given constraints.\nDanny Mittal's code:\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n \npublic class BovineAcrobaticsBR {\n \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        int m = Integer.parseInt(tokenizer.nextToken());\n        int k = Integer.parseInt(tokenizer.nextToken());\n        CowGroup[] cowGroups = new CowGroup[n];\n        for (int j = 0; j < n; j++) {\n            tokenizer = new StringTokenizer(in.readLine());\n            int weight = Integer.parseInt(tokenizer.nextToken());\n            int amt = Integer.parseInt(tokenizer.nextToken());\n            cowGroups[j] = new CowGroup(weight, amt);\n        }\n        Arrays.sort(cowGroups, Comparator.comparingInt(group -> group.weight));\n \n        TreeSet<CowGroup> treeSet = new TreeSet<>(Comparator.comparingInt(group -> group.weight));\n        int towers = 0;\n        long answer = 0;\n        for (CowGroup group : cowGroups) {\n            int disp = group.amt;\n            while (disp > 0) {\n                CowGroup floor = treeSet.floor(new CowGroup(group.weight - k, 0));\n                if (floor == null) {\n                    break;\n                }\n                treeSet.remove(floor);\n                if (floor.amt <= disp) {\n                    disp -= floor.amt;\n                } else {\n                    treeSet.add(new CowGroup(floor.weight, floor.amt - disp));\n                    disp = 0;\n                }\n            }\n            towers -= group.amt - disp;\n            int canAdd = Math.min(group.amt, m - towers);\n            towers += canAdd;\n            answer += canAdd;\n            treeSet.add(new CowGroup(group.weight, canAdd));\n        }\n        System.out.println(answer);\n    }\n \n    static class CowGroup {\n        final int weight;\n        final int amt;\n \n        CowGroup(int weight, int amt) {\n            this.weight = weight;\n            this.amt = amt;\n        }\n    }\n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1351_silver_cycle_correspondence": {"name": "Cycle Correspondence", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1351", "test_data_link": "http://www.usaco.org/current/data/prob2_silver_dec23.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob2_silver_dec23.html", "contest_link": "http://www.usaco.org/index.php?page=dec23results", "inner_contest_link": null, "problem_level": "silver", "cp_id": "1351", "problem_id": "1351_silver_cycle_correspondence", "description": "\nFarmer John has $N$ barns ($3\\le N\\le 5\\cdot 10^5$), of which $K$\n($3\\le K\\le N$) distinct pairs of barns are connected.\n\nFirst, Annabelle assigns each barn a distinct integer label in the range\n$[1,N]$, and observes that the barns with labels $a_1,\\dots,a_K$  are connected\nin a cycle, in that order. That is, barns $a_i$ and $a_{i+1}$ are connected for\nall $1\\le i<K$, and barns $a_K$ and $a_1$ are also connected. All $a_i$ are\ndistinct.\n\nNext, Bessie also assigns each barn a distinct integer label in the range\n$[1,N]$ and observes that the barns with labels $b_1,\\dots,b_K$ are connected in\na cycle, in that order. All $b_i$ are distinct.\n\nSome (possibly none or all) barns are assigned the same label by Annabelle and\nBessie. Compute the maximum possible number of barns that are assigned the same\nlabel by Annabelle and Bessie.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$ and $K$.\n\nThe next line contains $a_1,\\dots, a_K$. \n\nThe next line contains $b_1,\\dots, b_K$.\n\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe maximum number of fixed points.\n\nSAMPLE INPUT:\n6 3\n1 2 3\n2 3 1\nSAMPLE OUTPUT: \n6\n\nAnnabelle and Bessie could have assigned the same label to every barn.\n\nSAMPLE INPUT:\n6 3\n1 2 3\n4 5 6\nSAMPLE OUTPUT: \n0\n\nAnnabelle and Bessie could not have assigned the same label to any barn.\n\nSAMPLE INPUT:\n6 4\n1 2 3 4\n4 3 2 5\nSAMPLE OUTPUT: \n4\n\nAnnabelle and Bessie could have assigned labels $2,3,4,6$ to the same barns.\n\nSCORING:\nInputs 4-5: $N \\le 8$Inputs 6-8: $N \\le 5000$Inputs\n9-15: No additional constraints\n\n\nProblem credits: Benjamin Qi\n", "num_tests": 15, "solution": "\n(Analysis by Andi Qu)\nAt first glance, this problem may seem like a messy graph problem with the barns\nforming some network. Luckily, the way the barns are connected means that we\ndon't have to construct a graph explicitly.\nThe key observation is that because there are $K$ barns in a cycle and $K$ total\npairs of connections, no two barns outside the cycle are connected. (Try drawing\nsome cycles and counting the connections to verify this fact!) This observation\nmeans that we can split the answer into a sum of two values: the number of\nsame-labelled barns (a) outside and (b) inside the cycle.\nIf a barn outside the cycle is labelled the same by Annabelle and Bessie, then\nits label must not appear in the lists $a_i$ or $b_i$. And because the total\nnumber of barns outside the cycle is no greater than the number of integers from\n$1$ to $N$ appearing in neither $a_i$ nor $b_i$, the maximum number of\nsame-labelled barns outside the cycle is exactly equal to that number. This\nvalue can be computed in $O(N)$ time with a set data structure.\nTo find the maximum number of same-labelled barns inside the cycle, imagine\nplacing the two cycles on top of each other and rotating one cycle until the\nmaximum number of labels align. Rotating a cycle and counting the number of\nalignments takes $O(N)$ time, so a straightforward implementation of this\nalgorithm would take $O(N^2)$ time. To speed it up, we can count the number of\nalignments for a particular rotation (say rotating $a_i$ to the right by $r$\npositions) by counting the number of positions $i$ where $a_i = b_{i + r}$\n(wrapping around as necessary). Specifically:\nWe start with a counter array $c_0, \\dots, c_{K - 1}$, initially all set to\nzeroes.We iterate over every value in $a_i$ and find the corresponding\nvalue $b_j = a_i$ if it exists.We then increment $c_r$ for $r = i - j$\nif $i \\geq j$, or $r = i - j + K$ if $j > i$.Finally, we take the\nmaximum $c_r$ at the end of this process as the answer.\n(Note that we also need to consider the case where the list $a_i$ or $b_i$ is\nreversed!)\nWith this improved algorithm, we no longer iterate over all barns each time we\ndo a rotation, so it runs in $O(N)$ time.\nAltogether, this solution runs in $O(N)$ time. $O(N \\log N)$-time solutions\nusing slower set data structures should also pass all test cases.\nPython code implementing this solution:\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nsame_outside = set(range(1, n + 1)) - set(a) - set(b)\n\ndef max_rotation(cycle_a, cycle_b):\n    position_a = {val: idx for idx, val in enumerate(cycle_a)}\n    with_offset = [0] * k\n    for idx, val in enumerate(cycle_b):\n        if val in position_a:\n            with_offset[idx - position_a[val]] += 1\n    return max(with_offset)\n\nprint(len(same_outside) +\n      max(max_rotation(a, b), max_rotation(a, b[::-1])))\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1352_silver_target_practice": {"name": "Target Practice", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1352", "test_data_link": "http://www.usaco.org/current/data/prob3_silver_dec23.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob3_silver_dec23.html", "contest_link": "http://www.usaco.org/index.php?page=dec23results", "inner_contest_link": null, "problem_level": "silver", "cp_id": "1352", "problem_id": "1352_silver_target_practice", "description": "\nBessie is a robovine, also known as a cowborg. She is on a number line trying to\nshoot a series of $T$ $(1 \\leq T \\leq 10^5)$ targets located at distinct\npositions. Bessie  starts at position $0$ and follows a string of $C$\n$(1 \\leq C \\leq 10^5)$ commands,  each one of L, F, or R:\n\nL: Bessie moves one unit to the left.R: Bessie moves one unit to the right.F: Bessie fires. If there is a target at Bessie's current position, it is\nhit and destroyed, and cannot be hit again.\nIf you are allowed to change up to one command in the string  to a different\ncommand before Bessie starts following it, what is the maximum number of targets\nthat Bessie can hit?\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $T$ and $C$.\n\nThe next line contains the locations of the $T$ targets, distinct integers in the range\n$[-C,C]$.\n\nThe next line contains the command string of length $C$, containing only the\ncharacters F, L, and R.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nPrint the maximum number of targets that Bessie can hit after changing up to one\ncommand  in the string.\n\nSAMPLE INPUT:\n3 7\n0 -1 1\nLFFRFRR\nSAMPLE OUTPUT: \n3\n\nIf you make no changes to the string, Bessie will hit two targets:\n\n\nCommand | Position | Total Targets Hit\n--------+----------+-------------------\nStart   |  0       | 0 \nL       | -1       | 0\nF       | -1       | 1\nF       | -1       | 1 (can't destroy target more than once)\nR       |  0       | 1\nF       |  0       | 2\nR       |  1       | 2\nR       |  2       | 2\n\nIf you change the last command from R to F, Bessie will hit all three targets:\n\n\nCommand | Position | Total Targets Hit\n--------+----------+-------------------\nStart   |  0       | 0 \nL       | -1       | 0\nF       | -1       | 1\nF       | -1       | 1 (can't destroy target more than once)\nR       |  0       | 1\nF       |  0       | 2\nR       |  1       | 2\nF       |  1       | 3\n\nSAMPLE INPUT:\n1 5\n0\nFFFFF\nSAMPLE OUTPUT: \n1\n\nIf the commands are left unchanged, the only target at 0 will be destroyed.\nSince a target cannot be destroyed multiple times, the answer is 1.\n\nSAMPLE INPUT:\n5 6\n1 2 3 4 5\nFFRFRF\nSAMPLE OUTPUT: \n3\n\nSCORING:\nInputs 4-6: $T,C \\le 1000$Inputs 7-15: No additional constraints.\n\n\nProblem credits: Suhas Nagar\n", "num_tests": 15, "solution": "\n(Analysis by Suhas Nagar)\nSubtask 1: $T,C \\leq 1000$\nWe can first attempt a brute force solution. Given a sequence, we can determine\nthe number of  targets that are hit by simulating Bessie's position and keeping\ntrack of hit targets in an array. We can attempt to exhaustively change every\ncharacter of the sequence to another,  simulate the number of targets hit, and\nthen take the maximum across all sequences. This gives us a solution of $O(TC)$\nfor the first subtask. \nBenjamin Qi's Python solution:\n\nT, C = map(int, input().split())\ntargets = list(map(int, input().split()))\n \ndef test(cand):\n     avail = [0] * (2*C+1)\n     for t in targets:\n          avail[t+C] = 1\n     ans = 0\n     cur = C\n     for c in cand:\n          if c == 'L':\n               cur -= 1\n\t  elif c == 'R':\n\t       cur += 1\n\t  else:\n\t       ans += avail[cur]\n\t       avail[cur] = 0\n     return ans\n\ncommands = input()\nmax_ans = 0\nfor i in range(len(commands)):\n     for c in \"LFR\":\n          max_ans = max(max_ans, test(commands[:i] + c + commands[i+1:]))\n \nprint(max_ans)\n\nFull Credit:\nTo improve our runtime, we make a few observations. Firstly, since we can only\nchange a  single character, Bessie's position cannot change by more than 2 from\nwhere she originally  was (ie changing an L to an R). From here, we can consider\nan alternate solution where we  calculate which targets are hit for all suffixes\nfor displacements of $-2, -1, 0, 1$, and $2$  from Bessie's original position.\nIf we know this information, we can iterate from left to  right, try changing\nevery character of the sequence, determine the displacement this causes for the\nsuffix, and use our precomputation to determine the total amount of hit targets.\nIf we naively  calculate the number of targets hit for every suffix, we are\nduplicating work  since suffixes share many common elements. However, this leads\nus to the optimal solution.\nLet $pref[i]$ be the targets hit with the first $i$ characters of the string.\nLet $suff[i][k]$  be the targets hit with the last $i$ characters of the string\nat a displacement of $k$. We can precompute all $pref[i]$ using our simulation\nsolution from before on the unchanged sequence. Now, we can iterate through our\nsequence in reverse order. Assuming no overlap between the  prefix and suffix\narrays, we can compute the number of targets we hit by changing the $i$-th \ncharacter as $pref[i-1]+suff[i+1][k]+hit[i]$ where $k$ is the displacement of\nchanging the  current character and $hit[i]$ is $1$ if we change the current\ncharacter to $F$ and there is an unhit target at our current position. Once we\nprocess the current character, we can update our  suffix target count to include\nthe current position under each displacement. This gives us a  solution in\n$O(T+C)$ to compute the number of targets when we change each character of the \nsequence.\nThere is one caveat however. We want our suffix targets to not double count\ntargets that have  already been hit in the prefix. If we want to add a target to\nour  suffix count but it has been hit in the prefix already, we can add it to a\nbuffer and only move it into our suffix array when we remove that target from\nthe prefix array.\n\nimport java.io.*;\nimport java.util.*;\n \npublic class TargetPractice {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int nloc = sc.nextInt();\n        int ncommands = sc.nextInt();\n        boolean[] locations = new boolean[2*ncommands+5];\n        for (int i = 0; i < nloc; i++){\n            locations[sc.nextInt()+ncommands] = true;\n        }\n        String command = sc.next();\n        HashMap<Integer, Integer> currentHit = new HashMap<>();\n        HashMap<Integer,Integer> whenHit = new HashMap<>();\n        int cur_pos = ncommands;\n        for (int i = 0; i < ncommands; i++){\n            if (command.charAt(i) == 'F'){\n                if (locations[cur_pos] && !currentHit.containsKey(cur_pos)){\n                    currentHit.put(cur_pos, i);\n                    whenHit.put(i,cur_pos);\n                }\n            }\n            cur_pos += (command.charAt(i) == 'L') ? -1 : 0;\n            cur_pos += (command.charAt(i) == 'R') ? 1 : 0;\n        }\n        int max = currentHit.size();\n        HashSet[] rightSide = new HashSet[5];\n        for (int i = 0; i < 5; i++) rightSide[i] = new HashSet<Integer>();\n        HashSet[] toBeAdded = new HashSet[5];\n        for (int i = 0; i < 5; i++) toBeAdded[i] = new HashSet<Integer>();\n        for (int i = ncommands-1; i >= 0; i--){\n            if (whenHit.containsKey(i)){\n                currentHit.remove(whenHit.get(i));\n                whenHit.remove(i);\n                for (int j = 0; j < 5; j++){\n                    if (toBeAdded[j].contains(cur_pos)){\n                        rightSide[j].add(cur_pos);\n                        toBeAdded[j].remove(cur_pos);\n                    }\n                }\n            }\n            cur_pos += (command.charAt(i) == 'L') ? 1 : 0;\n            cur_pos += (command.charAt(i) == 'R') ? -1 : 0;\n            switch (command.charAt(i)){\n                case 'L':\n                    // try F and add all displacement 1\n                    int addL = locations[cur_pos] && !currentHit.containsKey(cur_pos) && !rightSide[3].contains(cur_pos)? 1 : 0;\n                    max = Math.max(max, whenHit.size()+addL+rightSide[3].size());\n                    // try changing to R\n                    max = Math.max(max, whenHit.size()+rightSide[4].size());\n                    break;\n                case 'R':\n                    // try F and add all displacement 1\n                    int addR = locations[cur_pos] && !currentHit.containsKey(cur_pos) && !rightSide[1].contains(cur_pos) ? 1 : 0;\n                    max = Math.max(max, whenHit.size()+addR+rightSide[1].size());\n                    // try changing to L\n                    max = Math.max(max, whenHit.size()+rightSide[0].size());\n                     break;\n                case 'F':\n                    // Try changing to L\n                    max = Math.max(max, whenHit.size()+rightSide[1].size());\n                    // Try changing to R\n                    max = Math.max(max, whenHit.size()+rightSide[3].size());\n                    break;\n            }\n            if (command.charAt(i) == 'F') {\n                for (int j = cur_pos - 2; j <= cur_pos + 2; j++) {\n                    if (j < 0 || j >= locations.length) continue;\n                    if (locations[j]){\n                        if (currentHit.containsKey(j)) {\n                            toBeAdded[j - cur_pos + 2].add(j);\n                        }else{\n                            rightSide[j-cur_pos+2].add(j);\n                        }\n                    }\n                }\n            }\n \n        }\n        System.out.println(max);\n \n    }\n \n}\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1347_bronze_candy_cane_feast": {"name": "Candy Cane Feast", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1347", "test_data_link": "http://www.usaco.org/current/data/prob1_bronze_dec23.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob1_bronze_dec23.html", "contest_link": "http://www.usaco.org/index.php?page=dec23results", "inner_contest_link": null, "problem_level": "bronze", "cp_id": "1347", "problem_id": "1347_bronze_candy_cane_feast", "description": "\nFarmer John's cows have quite the sweet tooth, and they especially enjoy eating\ncandy canes!  FJ has $N$ total cows, each with a certain initial height and he\nwants to feed them  $M$ candy canes, each also of varying height\n($1\\le N,M\\le 2\\cdot 10^5$).  \n\nFJ plans to feed the candy canes one by one to the cows, in the order they are\ngiven in the input.  To feed a candy cane to his cows, he will hang the candy\ncane so that initially the candy cane is just touching the ground. The cows will\nthen line up one by one, in the order given by the input, and go up to the candy\ncane, each eating up to their height (since they cannot reach any higher). The\ncandy cane stays suspended in place where it is initially set up  and is not\nlowered to the ground, even after cows eat the bottom of the candy cane. It is \npossible a cow may eat nothing during her turn, if the base of the candy cane is\nalready above that cow's height.  After every cow has had their turn, the cows\ngrow in height by how many units of candy cane they ate, and Farmer John hangs\nthe next candy cane and the cows repeat the process again (with cow 1\nagain being the first to start eating the next candy cane).\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$ and $M$.\n\nThe next line contains the initial heights of the $N$ cows, each in the range\n$[1,10^9]$.\n\nThe next line contains the heights of the $M$ candy canes, each in the range\n$[1,10^9]$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe final heights of each of the $N$ cows on separate lines.\n\nNote that the large size of integers involved in this problem may require the\nuse of 64-bit integer data types (e.g., a \"long long\" in C/C++).\n\nSAMPLE INPUT:\n3 2\n3 2 5\n6 1\nSAMPLE OUTPUT: \n7\n2\n7\n\nThe first candy cane is $6$ units tall. \nThe first cow eats the portion of the first candy cane up to height $3$,\nafter which the remaining portion of the first candy cane occupies heights\n$[3,6]$. The second cow is not tall enough to eat any of the remaining portion of the\nfirst candy cane.\nThe third cow eats two additional units of the first candy cane. The\nremaining portion of the first candy cane, occupying heights $[5,6]$, is not\neaten.\nNext, each cow grows by the amount she ate, so the heights of the cows  become\n$[3+3, 2+0, 5+2]=[6, 2, 7]$.\n\nThe second candy cane is $1$ unit tall, and the first cow eats all of it.\n\nSCORING:\nInputs 2-10: $N, M \\le 10^3$Inputs 11-14: No additional constraints.\n\n\nProblem credits: Agastya Goel\n", "num_tests": 14, "solution": "\n(Analysis by Nick Wu)\nSubtask 1: $N, M \\le 10^3$.\nFor this subtask, it suffices to simulate the process, as that would take\n$\\mathcal{O}(NM)$ time.\nPython code is as follows:\n\nn, m = (int(x) for x in input().split())\nh = [int(x) for x in input().split()]\nfor curr in [int(x) for x in input().split()]:\n  idx = 0\n  taken = 0\n  while idx < n:\n    if h[idx] > taken:\n      inc = min(curr, h[idx]) - taken\n      h[idx] += inc\n      taken += inc\n    idx += 1\nfor x in h:\n  print(x)\n\nFull credit:\nOnly a small change is needed from the subtask solution to\nget full credit - specifically, if the candy cane is fully eaten, don't simulate\nthe remaining cows trying to eat the candy cane, just break out of that loop and\nstart the next iteration.\nWe can show that this process takes $\\mathcal{O}(M + N \\log 10^9)$ time. Note\nthat if any cow besides the first cow gets to eat any part of a given candy\ncane, this implies that the first cow was able to eat their height's worth of\ncandy cane and doubles in height. Under the bounds of the given problem, the cow\ncannot double in height more than $30$ times.\nAgastya Goel's C++ solution:\n\n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\n \nconst int MAXN = 2e5+5;\nll heights[MAXN];\nint n, m;\n \nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) cin >> heights[i];\n\tfor (int i = 0; i < m; i++) {\n\t\tint x; cin >> x;\n\t\tint l = 0;\n\t\tfor (int j = 0; j < n && l < x; j++) {\n\t\t\tint diff = max(0, (int)min(heights[j], (ll)x)-l);\n\t\t\theights[j] += diff;\n\t\t\tl += diff;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << heights[i] << '\\n';\n\t}\n}\n\nMy Java solution:\n\nimport java.io.*;\nimport java.util.*;\npublic class Solution {\n  public static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    StringTokenizer st = new StringTokenizer(br.readLine());\n    int n = Integer.parseInt(st.nextToken());\n    int q = Integer.parseInt(st.nextToken());\n    long[] h = new long[n];\n    st = new StringTokenizer(br.readLine());\n    for(int i = 0; i < n; i++) {\n      h[i] = Long.parseLong(st.nextToken());\n    }\n    st = new StringTokenizer(br.readLine());\n    while(q-- > 0) {\n      long curr = Long.parseLong(st.nextToken());\n      long taken = 0;\n      for(int i = 0; i < n && taken < curr; i++) {\n        long inc = Math.min(curr, h[i]) - taken;\n        if(inc > 0) {\n          h[i] += inc;\n          taken += inc;\n        }\n      }\n    }\n    for(int i = 0; i < n; i++) pw.println(h[i]);\n    pw.close();  \n  }\n}\n\nBenjamin Qi's Python solution:\n\nN, M = map(int, input().split())\n \ncows = list(map(int, input().split()))\nhaybales = map(int, input().split())\n \nfor h in haybales:\n\tif h <= cows[0]:\n\t\tcows[0] += h\n\telse:\n\t\th_so_far = 0\n\t\tfor i in range(N):\n\t\t\tif cows[i] > h_so_far:\n\t\t\t\tnext_h = min(cows[i], h)\n\t\t\t\tcows[i] += next_h - h_so_far\n\t\t\t\th_so_far = next_h\n \n \nfor c in cows:\n\tprint(c)\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1348_bronze_cowntact_tracing_2": {"name": "Cowntact Tracing 2", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1348", "test_data_link": "http://www.usaco.org/current/data/prob2_bronze_dec23.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob2_bronze_dec23.html", "contest_link": "http://www.usaco.org/index.php?page=dec23results", "inner_contest_link": null, "problem_level": "bronze", "cp_id": "1348", "problem_id": "1348_bronze_cowntact_tracing_2", "description": "\nFarmer John has $N$ cows in a line ($1 \\leq N \\leq 3\\cdot 10^5$). Unfortunately,\nthere is a sickness spreading throughout. \n\nInitially, some cows start off infected. Every night, an infected cow spreads\nthe sickness to the cows on their left and right (if they exist). Once a cow is\ninfected, she stays infected.\n\nAfter some amount of nights, Farmer John realizes that the issue has gotten out\nof control, so he tests his cows to determine who has the sickness. Find the\nminimum number of cows that could have started with the sickness. \n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$, the number of cows that Farmer John has.\n\nThe next line contains an $N$ character bitstring of only $1$s and $0$s where a\n$1$ represents an infected cow and a $0$ represents an uninfected cow after some\nnumber of nights.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput a single integer: the minimum number of cows that could have started \nwith the sickness.\n\nSAMPLE INPUT:\n5\n11111\nSAMPLE OUTPUT: \n1\n\nSuppose the middle cow was the only cow to start off infected. Then the cows \nwould be infected in the following order:\n\n\n0 nights:    00100 (the third cow is initially infected)\n1 night:  -> 01110 (the second and fourth cows are now infected)\n2 nights: -> 11111 (the first and fifth cows are now infected)\n3 nights: -> 11111 (all cows already were infected, so no additional cows are infected)\n          -> ...\n\nAfter two or more nights, the final state of the cows would look like the input.\nThere are many other initial states and number of nights that could have\nproduced the input state, such as:\n\n\n0 nights:    10001\n1 night:  -> 11011\n2 nights: -> 11111\n\nor:\n\n\n0 nights:    01001\n1 night:  -> 11111\n\nor:\n\n\n0 nights:    01000\n1 night:  -> 11100\n2 nights: -> 11110\n3 nights: -> 11111\n\nAll of these initial states contain at least one infected cow.\n\nSAMPLE INPUT:\n6\n011101\nSAMPLE OUTPUT: \n4\n\nThe only initial state and number of nights that could have led to this final\nstate is if no nights have passed and each of the four infected cows in the\ninput started off with the sickness.\n\nSCORING:\nInputs 3-7: $N \\le 1000$Inputs 8-12: No additional constraints.\n\n\nProblem credits: Suhas Nagar\n", "num_tests": 12, "solution": "\n(Analysis by Suhas Nagar)\nThe number of days $D$ is uncertain, but if we knew the number of days that have\npassed from  the initial configuration, solving the problem would be easier,\nsince we can think of each initially infected cow as a window of $2D+1$ ones\n(since the infection spreads D units to the left and right of the originally\ninfected cow) and we want to cover the infected cows in the input with the\nminimal amount of these windows. \nWe first notice that our windows can overlap. Suppose we wanted to cover 8 cows\nwith windows of size 5. It is fine to use two windows and have a two cow\noverlap, because an already infected cow cannot get reinfected. \nThis leads us to see that if there are multiple values of $D$ that allow for an\nend state to be feasible, the maximal value of $D$ will always correspond to the\nminimum  number of initial cows, since we want to prioritize each window\ncovering the most amount of cows.\nSeemingly, the maximum window that we can use would be the minimum contiguous\nregion of $1$s in the  input, as if the window we pick was any larger, that\nregion would be impossible to cover.  However, there are two special cases. \nCase 1 (End Pieces): If there is a group of $I$ infected cows on either end of\nour list,  it is possible for the initial infected cow to have been the one on\nthe very edge, in which  case our maximum window could be up to $2*I-1$ instead\nof just\n$I$\nCase 2 (Even Pieces): If there is a group of $I$ infected cows where $I$ is\neven, it is  impossible for this to have been covered by a single cow. Instead,\nwe must have had at least  two cows, so the maximum window in this case is $I-1$\ninstead of $I$.\nNow, we can calculate the maximum value of $D$ possible by taking the minimum\nwindows across  the end, even, and odd cases and then summing the ceiling of\n$\\frac{I}{D}$ for every contiguous  group of $I$ infected cows.\n\nimport java.io.*;\nimport java.util.*;\n\npublic class CowntactTracing2 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(in.readLine());\n        String s = in.readLine();\n        ArrayList<Integer> segments = new ArrayList<>();\n        int region = 0;\n        for (int i = 0; i < n; i++){\n            if (s.charAt(i) == '1'){\n                region++;\n            }else{\n                if (region > 0) segments.add(region);\n                region = 0;\n            }\n        }\n        if (region > 0) segments.add(region);\n        int[] minBlock = {Integer.MAX_VALUE, Integer.MAX_VALUE};\n        int minEnd = Integer.MAX_VALUE;\n        int sind = 0; int eind = segments.size()-1;\n        if (s.charAt(0) == '1') {\n            minEnd = Math.min(minEnd, segments.get(0));\n            sind++;\n        }\n        if (s.charAt(n-1) == '1') {\n            minEnd = Math.min(minEnd, segments.get(eind));\n            eind--;\n        }\n        for (int i = sind; i <= eind; i++){\n            minBlock[segments.get(i)%2] = Math.min(minBlock[segments.get(i)%2], segments.get(i));\n        }\n        int daySpread = Math.min(minEnd*2-1, Math.min(minBlock[0]-1, minBlock[1]));\n        int numInfected = 0;\n        for (int block : segments){\n            numInfected += (block+daySpread-1)/daySpread;\n        }\n        System.out.println(numInfected);\n    }\n}\n\nAlternatively, we could have simulated all possible values of \"windows\" from $1$\nto $N$,  breaking when we find the first invalid window, and take the minimum\nacross all possible  values. We can break early since if we are unable to cover\nour input with some window, we  cannot use a larger window to cover it. The time\ncomplexity here is $O(N)$. Let the number  of regions of contiguous $1$s be $R$.\nWe iterate $R$ times for every window, and the maximum  window we check is\nbounded by $\\frac{N}{R}$ so we have $O(R*\\frac{N}{R}) = O(N)$\n\nimport java.io.*;\nimport java.util.*;\n\npublic class CowntactTracing2 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(in.readLine());\n        String s = in.readLine();\n        ArrayList<Integer> segments = new ArrayList<>();\n        int region = 0;\n        for (int i = 0; i < n; i++){\n            if (s.charAt(i) == '1'){\n                region++;\n            }else{\n                if (region > 0) segments.add(region);\n                region = 0;\n            }\n        }\n        if (region > 0) segments.add(region);\n        int numInfected = n;\n        outer: for (int window = 1; window <= n; window += 2){\n            int tempInfected = 0;\n            for (int i = 0; i <  segments.size(); i++){\n                int block = segments.get(i);\n                //if block is an end piece\n                if ((i == 0 && s.charAt(0) == '1') || (i == segments.size()-1 && s.charAt(n-1) == '1')){\n                    if (window > block*2-1) break outer;\n                }else {\n                    if (window > block) break outer;\n                }\n                tempInfected += (block+window-1)/window;\n            }\n            numInfected = Math.min(numInfected,tempInfected);\n        }\n        System.out.println(numInfected);\n    }\n}\n\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}, "1349_bronze_farmer_john_actually_farms": {"name": "Farmer John Actually Farms", "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1349", "test_data_link": "http://www.usaco.org/current/data/prob3_bronze_dec23.zip", "solution_link": "http://www.usaco.org/current/data/sol_prob3_bronze_dec23.html", "contest_link": "http://www.usaco.org/index.php?page=dec23results", "inner_contest_link": null, "problem_level": "bronze", "cp_id": "1349", "problem_id": "1349_bronze_farmer_john_actually_farms", "description": "\nFarmer John is growing $N$ ($1 \\leq N \\leq 2\\cdot 10^5$) plants of asparagus on\nhis farm! However some of his plants have genetic differences, so some plants\nwill grow faster than others. The initial height of the $i$th plant is $h_i$\ninches, and after each day, the $i$th plant grows by $a_i$ inches. \n\nFJ likes some of his plants more than others, and he wants some specific plants\nto be taller than others. He gives you an array of distinct values\n$t_1,\\dots,t_N$ containing all integers from $0$ to $N-1$ and he wants the $i$th\nplant to have exactly $t_i$ other plants that are taller than it. Find the\nminimum number of days so that FJ's request is satisfied, or determine that it\nis impossible.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first will consist of an integer $T$, denoting the number of independent\ntest cases $(1 \\leq T \\leq 10)$.\n\nThe first line of each test case consists of an integer $N$.\n\nThe second line consists of $N$ integers $h_i$ $(1 \\leq h_i \\leq 10^9)$ denoting\nthe initial height of the $i$th plant in inches.\n\nThe third line consists of $N$ integers $a_i$ $(1 \\leq a_i \\leq 10^9)$ denoting\nthe number of inches the $i$th plant grows each day.\n\nThe fourth line consists of $N$ distinct integers $t_i$ denoting the array that\nFJ gives you.\n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed\n$2\\cdot 10^5$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput $T$ lines, the answer to each test case on a different line. If it is not\npossible, output $-1$.\n\nNote that the large size of integers involved in this problem may require the\nuse of 64-bit integer data types (e.g., a \"long long\" in C/C++).\nSAMPLE INPUT:\n6\n1\n10\n1\n0\n2\n7 3\n8 10\n1 0\n2\n3 6\n10 8\n0 1\n2\n7 3\n8 9\n1 0\n2\n7 7\n8 8\n0 1\n2\n7 3\n8 8\n1 0\nSAMPLE OUTPUT: \n0\n3\n2\n5\n-1\n-1\n\nIn the first sample input, there are 6 test cases.\n\nIn the first test case, there is only one plant, so the condition is satisfied\non day 0.\n\nIn the second test case, we need the first plant to be shorter than the second\nplant.  After day 1, the heights are 15 and 13.  After day 2, the heights are\nboth 23.  After day 3, the heights are 31 and 33, and that's the first day in\nwhich the condition is satisfied.\n\nThe third and fourth test cases are similar to the second.\n\nIn the fifth test case, both plants start with an initial height of 7 and a\ngrowth rate of 8.  So they will always have identical heights, and therefore the\ncondition is never satisfied.\n\nIn the sixth test case, the condition is not satisfied initially and the growth\nrates are the same. So the condition can never be satisfied.\n\nSAMPLE INPUT:\n2\n5\n7 4 1 10 12\n3 4 5 2 1\n2 1 0 3 4\n5\n4 10 12 7 1\n3 1 1 4 5\n2 4 3 1 0\nSAMPLE OUTPUT: \n4\n7\n\nIn the second sample input, there are 2 test cases.\n\nIn the first test case, the final heights after day 4 are 19, 20, 21, 18, 16.\n\nIn the second test case, the final heights after day 7 are 25, 17, 19, 35, 36.\n\nSCORING:\nInput 3: $N \\le 2$Inputs 4-5: $N \\le 50$ and $a_i, h_i \\le 10^3$Inputs 6-8: $N \\le 10^3$Inputs 9-13: No additional constraints.\n\n\nProblem credits: Chongtian Ma\n", "num_tests": 13, "solution": "\n(Analysis by Nick Wu, Chongtian Ma)\nSubtask 1: $N \\le 2$.\nConsider only two plants. Let $i$ and $j$ be indices such that $t_i=0$ and\n$t_j = 1$. If $h_i > h_j$, then we don't need to spend any time growing the\nplants. Otherwise, we can break it up into cases.\nIf $a_i > a_j$, after each day, plant $i$ grows $a_i - a_j$ more inches than\nplant $j$. The number of days it takes for plant $i$ to be at least one inch\ntaller is $\\left\\lceil\\frac{h_j - h_i + 1}{a_i - a_j}\\right\\rceil$.\nIf $a_i \\leq a_j$, there is no way for plant $i$ to be able to surpass plant $j$\nin height. We output $-1$.\nNick Wu's Python code:\n\ndef mintime(hi, ai, hj, aj):\n    # return the smallest time when plant i, with height h[i] and growth rate a[i]\n    # is strictly taller than plant j, with height h[j] and growth rate a[j]\n    # returns -1 if this is impossible\n    if hi > hj: return 0\n    if ai <= aj: return -1\n    return (hj-hi) // (ai-aj) + 1\n\ndef solve():\n    n = int(input())\n    assert n <= 2\n    h = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    t = [int(x) for x in input().split()]\n    if n == 1: return 0\n    if t[0] == 0:\n        return mintime(h[0], a[0], h[1], a[1])\n    else:\n        return mintime(h[1], a[1], h[0], a[0])\n \nt = int(input())\nfor _ in range(t):\n    print(solve())\n\nSubtask 2: $N \\le 50$ and $a_i, h_i \\le 10^3$.\nFrom the first subtask, we can observe that based on the bounds of $a_i$ and\n$h_i$, if there is a value of $x$ number of days that satisfies Farmer John's\nrequest, then it must be at most $1000$. Therefore, for this subtask, it\nsuffices to just check all times from $0$ to $1000$ and print the earliest one\nthat works, or otherwise, claim it is impossible.\nPython code is as follows:\n\ndef solve():\n    n = int(input())\n    h = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    t = [int(x) for x in input().split()]\n    assert n <= 50\n    assert max(a) <= 1000\n    assert max(h) <= 1000\n    for ret in range(1002):\n        heights = [h[i] + a[i] * ret for i in range(n)]\n        tcomp = [sum([heights[i] < heights[j] for j in range(n)]) for i in range(n)]\n        if tcomp == t:\n            return ret\n    return -1\n \nt = int(input())\nfor _ in range(t):\n    print(solve())\n\nSubtask 3: $N \\le 10^3$.\nWe'll leverage the $N=2$ subtask repeatedly here. If plants $i$ and $j$ have\n$t_i < t_j$, then we know that plant $i$ must eventually be taller than plant\n$j$. From the $N=2$ subtask, if $a_i > a_j$ and $h_i \\le h_j$,\nthat gives us a lower bound on what $x$ can be. We can take all of the lower\nbounds from all pairs of plants and use the strictest one as our candidate\nanswer. If at any point there is no valid value of $x$, then it is impossible to\nsatisfy FJ.\n\ndef mintime(hi, ai, hj, aj):\n    # return the smallest time when plant i, with height h[i] and growth rate a[i]\n    # is strictly taller than plant j, with height h[j] and growth rate a[j]\n    # returns -1 if this is impossible\n    if hi > hj: return 0\n    if ai <= aj: return -1\n    return (hj-hi) // (ai-aj) + 1\n\ndef solve():\n    n = int(input())\n    assert n <= 1000\n    h = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    t = [int(x) for x in input().split()]\n    ret = 0\n    for i in range(n):\n        for j in range(n):\n            if t[i] < t[j]:\n                candt = mintime(h[i], a[i], h[j], a[j])\n                if candt < 0:\n                    return -1\n                ret = max(ret, candt)\n    heights = [h[i] + a[i] * ret for i in range(n)]\n    tcomp = [sum([heights[i] < heights[j] for j in range(n)]) for i in range(n)]\n    if tcomp == t:\n        return ret\n    return -1\n \nt = int(input())\nfor _ in range(t):\n    print(solve())\n\nFull credit:\nTo get full credit on this problem, we claim that it is sufficient to only check\npairs of plants $i$ and $j$ where $|t_i - t_j| = 1$. The reason for this is that\nthe relation of being taller or shorter than another plant is transitive - if\nyou have plants $i$, $j$, and $k$, where $t_i > t_j > t_k$, and plant $i$ is\nalways shorter than plant $k$, if plant $j$ is also shorter than plant $i$, then\nplant $j$ is necessarily shorter than plant $k$. Therefore, checking plants\nwhere $|t_i - t_j| > 1$ is unnecessary.\nTherefore, after sorting the plants in order of $t_i$, it takes $\\mathcal{O}(N)$\ntime to check that adjacent plants respect the height constraint. Sorting takes\n$\\mathcal{O}(N \\log N)$, so the final solution is $\\mathcal{O}(N \\log N)$.\nNote that because the $t_i$ values are $0,1,2,\\dots,N-1$ in some order, it is\npossible to order the plants directly without needing to sort them. If we\ninitialize another array $p$ where $p_i$ stores the index $j$ where $t_j = i$,\nwe may use $p_i$ in place of $i$. This solution is $\\mathcal{O}(N)$, though this\noptimization was not necessary to get full credit.\nChongtian Ma's C++ solution (which shows how to do it in linear time):\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nll ceil_div(ll a, ll b){\n\treturn (a + b - 1) / b;\n}\n \nint main(){\n    int T; cin >> T;\n    while(T--){\n        int N; cin >> N;\n        vector<ll> height(N), add(N), t(N);\n        for(ll& i: height) cin >> i;\n        for(ll& i: add) cin >> i;\n        for(ll& i: t) cin >> i;\n        vector<int> p(N);\n        for(int i = 0; i < N; i++){\n            p[t[i]] = i;\n        }\n        ll days = 0;\n        for(int i = N - 2; i >= 0; i--){\n            int small_idx = p[i + 1], big_idx = p[i];\n            ll h_diff = (height[small_idx] + add[small_idx] * days) - (height[big_idx] + add[big_idx] * days);\n            if(h_diff >= 0){\n                ll a_diff = add[big_idx] - add[small_idx];\n                if(a_diff <= 0){\n                    days = -1;\n                    break;\n                }\n                days += ceil_div(h_diff + 1, a_diff);\n            }\n        }\n        for(int i = N - 2; i >= 0; i--){\n            ll big_days = height[p[i]] + add[p[i]] * days;\n            ll small_days = height[p[i+1]] + add[p[i+1]] * days;\n            if(small_days >= big_days){\n                days = -1;\n                break;\n            }\n        }\n        cout << days << \"\\n\";\n    }\n}\n\nNick Wu's Java solution (with sorting):\n\nimport java.io.*;\nimport java.util.*;\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int t = Integer.parseInt(br.readLine());\n        while(t-- > 0) {\n            int n = Integer.parseInt(br.readLine());\n            int[] h = readArray(br, n);\n            int[] a = readArray(br, n);\n            int[] p = readArray(br, n);\n            long ret = 0;\n            int[] ordByGoalHeight = new int[n];\n            for(int i = 0; i < n; i++) ordByGoalHeight[i] = i;\n            ordByGoalHeight = Arrays.stream(ordByGoalHeight).boxed().sorted((i, j) -> p[j] - p[i]).mapToInt(i -> i).toArray();\n            for(int i = 0; i + 1 < n; i++) {\n                int smaller = ordByGoalHeight[i];\n                int larger = ordByGoalHeight[i + 1];\n                if(h[smaller] >= h[larger] && a[larger] > a[smaller]) {\n                    ret = Math.max(ret, ceilingDiv(h[smaller] - h[larger] + 1, a[larger] - a[smaller]));\n                }\n            }\n            long[] trueHeights = new long[n];\n            for(int i = 0; i < n; i++) {\n                trueHeights[i] = h[i] + a[i] * ret;\n            }\n            for(int i = 0; i + 1 < n && ret >= 0; i++) {\n                int smaller = ordByGoalHeight[i];\n                int larger = ordByGoalHeight[i + 1];\n                if(trueHeights[smaller] >= trueHeights[larger]) ret = -1;\n            }\n            pw.println(ret);\n        }\n        pw.close();\n    }\n    private static long ceilingDiv(long a, long b) {\n        // a and b are both positive\n        return (a + b - 1) / b;\n    }\n    private static int[] readArray(BufferedReader br, int n) throws IOException {\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int[] ret = new int[n];\n        for(int i = 0; i < n; i++) {\n            ret[i] = Integer.parseInt(st.nextToken());\n        }\n        return ret;\n    }\n}\n\nNick Wu's Python solution (also with sorting):\n\ndef ceilingDiv(a, b):\n    return (a + b - 1) // b\n \ndef solve():\n    n = int(input())\n    h = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    t = [int(x) for x in input().split()]\n    ord = [i for i in range(n)]\n    ord.sort(key=lambda x: t[x])\n    ret = 0\n    for ordi in range(n-1):\n        i = ord[ordi]\n        j = ord[ordi+1]\n        if h[i] < h[j] and a[i] > a[j]:\n            ret = max(ret, ceilingDiv(h[j] - h[i] + 1, a[i] - a[j]))\n    for i in range(n):\n        h[i] += a[i] * ret\n    for ordi in range(n-1):\n        i = ord[ordi]\n        j = ord[ordi+1]\n        if h[i] <= h[j]: return -1\n    return ret\n \nt = int(input())\nfor _ in range(t):\n    print(solve())\n\n", "runtime_limit_sentences": [], "memory_limit_sentences": [], "runtime_limit": 2, "memory_limit": 256}}